/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@tko/build.reference/dist/build.reference.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tko/build.reference/dist/build.reference.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*!\n * The TKO Reference Build ðŸ¥Š  @tko/build.reference@4.0.0-alpha9.0\n * (c) The Knockout.js Team - https://tko.io\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  //\n  // Array utilities\n  //\n  // Note that the array functions may be called with\n  // Array-like things, such as NodeList.\n\n  const {isArray} = Array;\n\n  function arrayForEach (array, action, thisArg) {\n    if (arguments.length > 2) { action = action.bind(thisArg); }\n    for (let i = 0, j = array.length; i < j; ++i) {\n      action(array[i], i, array);\n    }\n  }\n\n  function arrayIndexOf (array, item) {\n    return (isArray(array) ? array : [...array]).indexOf(item)\n  }\n\n  function arrayFirst (array, predicate, predicateOwner) {\n    return (isArray(array) ? array : [...array])\n      .find(predicate, predicateOwner)\n  }\n\n  function arrayMap (array = [], mapping, thisArg) {\n    if (arguments.length > 2) { mapping = mapping.bind(thisArg); }\n    return array === null ? [] : Array.from(array, mapping)\n  }\n\n  function arrayRemoveItem (array, itemToRemove) {\n    var index = arrayIndexOf(array, itemToRemove);\n    if (index > 0) {\n      array.splice(index, 1);\n    } else if (index === 0) {\n      array.shift();\n    }\n  }\n\n  function arrayGetDistinctValues (array = []) {\n    const seen = new Set();\n    if (array === null) { return [] }\n    return (isArray(array) ? array : [...array])\n      .filter(item => seen.has(item) ? false : seen.add(item))\n  }\n\n  function arrayFilter (array, predicate, thisArg) {\n    if (arguments.length > 2) { predicate = predicate.bind(thisArg); }\n    return array === null ? [] : (isArray(array) ? array : [...array]).filter(predicate)\n  }\n\n  function arrayPushAll (array, valuesToPush) {\n    if (isArray(valuesToPush)) {\n      array.push.apply(array, valuesToPush);\n    } else {\n      for (var i = 0, j = valuesToPush.length; i < j; i++) { array.push(valuesToPush[i]); }\n    }\n    return array\n  }\n\n  function addOrRemoveItem (array, value, included) {\n    var existingEntryIndex = arrayIndexOf(typeof array.peek === 'function' ? array.peek() : array, value);\n    if (existingEntryIndex < 0) {\n      if (included) { array.push(value); }\n    } else {\n      if (!included) { array.splice(existingEntryIndex, 1); }\n    }\n  }\n\n  function makeArray (arrayLikeObject) {\n    return Array.from(arrayLikeObject)\n  }\n\n  function range (min, max) {\n    min = typeof min === 'function' ? min() : min;\n    max = typeof max === 'function' ? max() : max;\n    var result = [];\n    for (var i = min; i <= max; i++) { result.push(i); }\n    return result\n  }\n\n  // Go through the items that have been added and deleted and try to find matches between them.\n  function findMovesInArrayComparison (left, right, limitFailedCompares) {\n    if (left.length && right.length) {\n      var failedCompares, l, r, leftItem, rightItem;\n      for (failedCompares = l = 0; (!limitFailedCompares || failedCompares < limitFailedCompares) && (leftItem = left[l]); ++l) {\n        for (r = 0; rightItem = right[r]; ++r) {\n          if (leftItem.value === rightItem.value) {\n            leftItem.moved = rightItem.index;\n            rightItem.moved = leftItem.index;\n            right.splice(r, 1);         // This item is marked as moved; so remove it from right list\n            failedCompares = r = 0;     // Reset failed compares count because we're checking for consecutive failures\n            break\n          }\n        }\n        failedCompares += r;\n      }\n    }\n  }\n\n  const statusNotInOld = 'added';\n  const statusNotInNew = 'deleted';\n\n      // Simple calculation based on Levenshtein distance.\n  function compareArrays (oldArray, newArray, options) {\n      // For backward compatibility, if the third arg is actually a bool, interpret\n      // it as the old parameter 'dontLimitMoves'. Newer code should use { dontLimitMoves: true }.\n    options = (typeof options === 'boolean') ? { dontLimitMoves: options } : (options || {});\n    oldArray = oldArray || [];\n    newArray = newArray || [];\n\n    if (oldArray.length < newArray.length) { return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, options) } else { return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, options) }\n  }\n\n  function compareSmallArrayToBigArray (smlArray, bigArray, statusNotInSml, statusNotInBig, options) {\n    var myMin = Math.min,\n      myMax = Math.max,\n      editDistanceMatrix = [],\n      smlIndex, smlIndexMax = smlArray.length,\n      bigIndex, bigIndexMax = bigArray.length,\n      compareRange = (bigIndexMax - smlIndexMax) || 1,\n      maxDistance = smlIndexMax + bigIndexMax + 1,\n      thisRow, lastRow,\n      bigIndexMaxForRow, bigIndexMinForRow;\n\n    for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {\n      lastRow = thisRow;\n      editDistanceMatrix.push(thisRow = []);\n      bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);\n      bigIndexMinForRow = myMax(0, smlIndex - 1);\n      for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {\n        if (!bigIndex) {\n          thisRow[bigIndex] = smlIndex + 1;\n        } else if (!smlIndex) {\n           // Top row - transform empty array into new array via additions\n          thisRow[bigIndex] = bigIndex + 1;\n        } else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1]) {\n          thisRow[bigIndex] = lastRow[bigIndex - 1];\n        } else {                  // copy value (no edit)\n          var northDistance = lastRow[bigIndex] || maxDistance;       // not in big (deletion)\n          var westDistance = thisRow[bigIndex - 1] || maxDistance;    // not in small (addition)\n          thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;\n        }\n      }\n    }\n\n    var editScript = [], meMinusOne, notInSml = [], notInBig = [];\n    for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {\n      meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;\n      if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex - 1]) {\n        notInSml.push(editScript[editScript.length] = {     // added\n          'status': statusNotInSml,\n          'value': bigArray[--bigIndex],\n          'index': bigIndex });\n      } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {\n        notInBig.push(editScript[editScript.length] = {     // deleted\n          'status': statusNotInBig,\n          'value': smlArray[--smlIndex],\n          'index': smlIndex });\n      } else {\n        --bigIndex;\n        --smlIndex;\n        if (!options.sparse) {\n          editScript.push({\n            'status': 'retained',\n            'value': bigArray[bigIndex] });\n        }\n      }\n    }\n\n      // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of\n      // smlIndexMax keeps the time complexity of this algorithm linear.\n    findMovesInArrayComparison(notInBig, notInSml, !options.dontLimitMoves && smlIndexMax * 10);\n\n    return editScript.reverse()\n  }\n\n  //\n  // This becomes ko.options\n  // --\n  //\n  // This is the root 'options', which must be extended by others.\n\n  var _global;\n\n  try { _global = window; } catch (e) { _global = __webpack_require__.g; }\n\n  var options = {\n    deferUpdates: false,\n\n    useOnlyNativeEvents: false,\n\n    protoProperty: '__ko_proto__',\n\n      // Modify the default attribute from `data-bind`.\n    defaultBindingAttribute: 'data-bind',\n\n      // Enable/disable <!-- ko binding: ... -> style bindings\n    allowVirtualElements: true,\n\n      // Global variables that can be accessed from bindings.\n    bindingGlobals: _global,\n\n      // An instance of the binding provider.\n    bindingProviderInstance: null,\n\n    // Whether the `with` binding creates a child context when used with `as`.\n    createChildContextWithAs: false,\n\n      // jQuery will be automatically set to _global.jQuery in applyBindings\n      // if it is (strictly equal to) undefined.  Set it to false or null to\n      // disable automatically setting jQuery.\n    jQuery: _global && _global.jQuery,\n\n    Promise: _global && _global.Promise,\n\n    taskScheduler: null,\n\n    debug: false,\n\n    global: _global,\n    document: _global.document,\n\n      // Filters for bindings\n      //   data-bind=\"expression | filter_1 | filter_2\"\n    filters: {},\n\n    // Used by the template binding.\n    includeDestroyed: false,\n    foreachHidesDestroyed: false,\n\n    onError: function (e) { throw e },\n\n    set: function (name, value) {\n      options[name] = value;\n    },\n\n    // Overload getBindingHandler to have a custom lookup function.\n    getBindingHandler (/* key */) {},\n    cleanExternalData (/* node, callback */) {}\n  };\n\n  Object.defineProperty(options, '$', {\n    get: function () { return options.jQuery }\n  });\n\n  //\n\n  function catchFunctionErrors (delegate) {\n    if (!options.onError) { return delegate }\n    return (...args) => {\n      try {\n        return delegate(...args)\n      } catch (err) {\n        options.onError(err);\n      }\n    }\n  }\n\n  function deferError (error) {\n    safeSetTimeout(function () { throw error }, 0);\n  }\n\n  function safeSetTimeout (handler, timeout) {\n    return setTimeout(catchFunctionErrors(handler), timeout)\n  }\n\n  //\n\n  function throttle (callback, timeout) {\n    var timeoutInstance;\n    return function (...args) {\n      if (!timeoutInstance) {\n        timeoutInstance = safeSetTimeout(function () {\n          timeoutInstance = undefined;\n          callback(...args);\n        }, timeout);\n      }\n    }\n  }\n\n  function debounce (callback, timeout) {\n    var timeoutInstance;\n    return function (...args) {\n      clearTimeout(timeoutInstance);\n      timeoutInstance = safeSetTimeout(() => callback(...args), timeout);\n    }\n  }\n\n  //\n\n  const ieVersion = options.document && (function () {\n    var version = 3, div = options.document.createElement('div'), iElems = div.getElementsByTagName('i');\n\n      // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment\n    while (\n          div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',\n          iElems[0]\n      ) {}\n\n    if (!version) {\n      const userAgent = window.navigator.userAgent;\n      // Detect IE 10/11\n      return ua.match(/MSIE ([^ ]+)/) || ua.match(/rv:([^ )]+)/)\n    }\n    return version > 4 ? version : undefined\n  }());\n\n  //\n  // Object functions\n  //\n\n  function hasOwnProperty(obj, propName) {\n    return Object.prototype.hasOwnProperty.call(obj, propName)\n  }\n\n  function extend (target, source) {\n    if (source) {\n      for (var prop in source) {\n        if (hasOwnProperty(source, prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n    return target\n  }\n\n  function objectForEach (obj, action) {\n    for (var prop in obj) {\n      if (hasOwnProperty(obj, prop)) {\n        action(prop, obj[prop]);\n      }\n    }\n  }\n\n  function objectMap (source, mapping, thisArg) {\n    if (!source) { return source }\n    if (arguments.length > 2) { mapping = mapping.bind(thisArg); }\n    var target = {};\n    for (var prop in source) {\n      if (hasOwnProperty(source, prop)) {\n        target[prop] = mapping(source[prop], prop, source);\n      }\n    }\n    return target\n  }\n  function getObjectOwnProperty (obj, propName) {\n    return hasOwnProperty(obj, propName) ? obj[propName] : undefined\n  }\n\n  function clonePlainObjectDeep (obj, seen) {\n    if (!seen) { seen = []; }\n\n    if (!obj || typeof obj !== 'object' ||\n          obj.constructor !== Object ||\n          seen.indexOf(obj) !== -1) {\n      return obj\n    }\n\n      // Anything that makes it below is a plain object that has not yet\n      // been seen/cloned.\n    seen.push(obj);\n\n    var result = {};\n    for (var prop in obj) {\n      if (hasOwnProperty(obj, prop)) {\n        result[prop] = clonePlainObjectDeep(obj[prop], seen);\n      }\n    }\n    return result\n  }\n\n  /**\n   * JSON.stringify, but inserts `...` for objects that are referenced\n   * multiple times, preventing infinite recursion.\n   */\n  function safeStringify (value) {\n    const seen = new Set();\n    return JSON.stringify(value, (k, v) => {\n      if (seen.has(v)) { return '...' }\n      if (typeof v === 'object') { seen.add(v); }\n      return v\n    })\n  }\n\n\n  /**\n   * Promises/A+ compliant isThenable (per section 1.2)\n   */\n  function isThenable (object) {\n    const objectType = typeof object;\n    const thenableType = objectType === 'object' || objectType === 'function';\n    return thenableType && object !== null && typeof object.then === 'function'\n  }\n\n  function testOverwrite () {\n    try {\n      Object.defineProperty(function x () {}, 'length', {});\n      return true\n    } catch (e) {\n      return false\n    }\n  }\n\n  const functionSupportsLengthOverwrite = testOverwrite();\n\n  function overwriteLengthPropertyIfSupported (fn, descriptor) {\n    if (functionSupportsLengthOverwrite) {\n      Object.defineProperty(fn, 'length', descriptor);\n    }\n  }\n\n  //\n  // String (and JSON)\n  //\n\n  function stringTrim (string) {\n    return string === null || string === undefined ? ''\n          : string.trim\n              ? string.trim()\n              : string.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, '')\n  }\n\n  function stringStartsWith (string, startsWith) {\n    string = string || '';\n    if (startsWith.length > string.length) { return false }\n    return string.substring(0, startsWith.length) === startsWith\n  }\n\n  function parseJson (jsonString) {\n    if (typeof jsonString === 'string') {\n      jsonString = stringTrim(jsonString);\n      if (jsonString) {\n        if (JSON && JSON.parse) // Use native parsing where available\n              { return JSON.parse(jsonString) }\n        return (new Function('return ' + jsonString))() // Fallback on less safe parsing for older browsers\n      }\n    }\n    return null\n  }\n\n  //\n  // ES6 Symbols\n  //\n\n  var useSymbols = typeof Symbol === 'function';\n\n  function createSymbolOrString (identifier) {\n    return useSymbols ? Symbol(identifier) : identifier\n  }\n\n  //\n\n  // For details on the pattern for changing node classes\n  // see: https://github.com/knockout/knockout/issues/1597\n  var cssClassNameRegex = /\\S+/g;\n\n  function toggleDomNodeCssClass (node, classNames, shouldHaveClass) {\n    var addOrRemoveFn;\n    if (!classNames) { return }\n    if (typeof node.classList === 'object') {\n      addOrRemoveFn = node.classList[shouldHaveClass ? 'add' : 'remove'];\n      arrayForEach(classNames.match(cssClassNameRegex), function (className) {\n        addOrRemoveFn.call(node.classList, className);\n      });\n    } else if (typeof node.className['baseVal'] === 'string') {\n          // SVG tag .classNames is an SVGAnimatedString instance\n      toggleObjectClassPropertyString(node.className, 'baseVal', classNames, shouldHaveClass);\n    } else {\n          // node.className ought to be a string.\n      toggleObjectClassPropertyString(node, 'className', classNames, shouldHaveClass);\n    }\n  }\n\n  function toggleObjectClassPropertyString (obj, prop, classNames, shouldHaveClass) {\n      // obj/prop is either a node/'className' or a SVGAnimatedString/'baseVal'.\n    var currentClassNames = obj[prop].match(cssClassNameRegex) || [];\n    arrayForEach(classNames.match(cssClassNameRegex), function (className) {\n      addOrRemoveItem(currentClassNames, className, shouldHaveClass);\n    });\n    obj[prop] = currentClassNames.join(' ');\n  }\n\n  //\n\n  var jQueryInstance = options.global && options.global.jQuery;\n\n  //\n\n  function domNodeIsContainedBy (node, containedByNode) {\n    if (node === containedByNode) { return true }\n    if (node.nodeType === 11) { return false } // Fixes issue #1162 - can't use node.contains for document fragments on IE8\n    if (containedByNode.contains) { return containedByNode.contains(node.nodeType !== 1 ? node.parentNode : node) }\n    if (containedByNode.compareDocumentPosition) { return (containedByNode.compareDocumentPosition(node) & 16) == 16 }\n    while (node && node != containedByNode) {\n      node = node.parentNode;\n    }\n    return !!node\n  }\n\n  function domNodeIsAttachedToDocument (node) {\n    return domNodeIsContainedBy(node, node.ownerDocument.documentElement)\n  }\n\n  function anyDomNodeIsAttachedToDocument (nodes) {\n    return !!arrayFirst(nodes, domNodeIsAttachedToDocument)\n  }\n\n  function tagNameLower (element) {\n      // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.\n      // Possible future optimization: If we know it's an element from an XHTML document (not HTML),\n      // we don't need to do the .toLowerCase() as it will always be lower case anyway.\n    return element && element.tagName && element.tagName.toLowerCase()\n  }\n\n  function isDomElement (obj) {\n    if (window.HTMLElement) {\n      return obj instanceof HTMLElement\n    } else {\n      return obj && obj.tagName && obj.nodeType === 1\n    }\n  }\n\n  function isDocumentFragment (obj) {\n    if (window.DocumentFragment) {\n      return obj instanceof DocumentFragment\n    } else {\n      return obj && obj.nodeType === 11\n    }\n  }\n\n  //\n\n  const datastoreTime = new Date().getTime();\n  const dataStoreKeyExpandoPropertyName = `__ko__${datastoreTime}`;\n  const dataStoreSymbol = Symbol('Knockout data');\n  var dataStore;\n  let uniqueId = 0;\n\n  /*\n   * We considered using WeakMap, but it has a problem in IE 11 and Edge that\n   * prevents using it cross-window, so instead we just store the data directly\n   * on the node. See https://github.com/knockout/knockout/issues/2141\n   */\n  const modern = {\n    getDataForNode (node, createIfNotFound) {\n      let dataForNode = node[dataStoreSymbol];\n      if (!dataForNode && createIfNotFound) {\n        dataForNode = node[dataStoreSymbol] = {};\n      }\n      return dataForNode\n    },\n\n    clear (node) {\n      if (node[dataStoreSymbol]) {\n        delete node[dataStoreSymbol];\n        return true\n      }\n      return false\n    }\n  };\n\n  /**\n   * Old IE versions have memory issues if you store objects on the node, so we\n   * use a separate data storage and link to it from the node using a string key.\n   */\n  const IE = {\n    getDataforNode (node, createIfNotFound) {\n      let dataStoreKey = node[dataStoreKeyExpandoPropertyName];\n      const hasExistingDataStore = dataStoreKey && (dataStoreKey !== 'null') && dataStore[dataStoreKey];\n      if (!hasExistingDataStore) {\n        if (!createIfNotFound) {\n          return undefined\n        }\n        dataStoreKey = node[dataStoreKeyExpandoPropertyName] = 'ko' + uniqueId++;\n        dataStore[dataStoreKey] = {};\n      }\n      return dataStore[dataStoreKey]\n    },\n\n    clear (node) {\n      const dataStoreKey = node[dataStoreKeyExpandoPropertyName];\n      if (dataStoreKey) {\n        delete dataStore[dataStoreKey];\n        node[dataStoreKeyExpandoPropertyName] = null;\n        return true // Exposing 'did clean' flag purely so specs can infer whether things have been cleaned up as intended\n      }\n      return false\n    }\n  };\n\n  const {getDataForNode, clear} = ieVersion ? IE : modern;\n\n  /**\n   * Create a unique key-string identifier.\n   */\n  function nextKey () {\n    return (uniqueId++) + dataStoreKeyExpandoPropertyName\n  }\n\n  function get (node, key) {\n    const dataForNode = getDataForNode(node, false);\n    return dataForNode && dataForNode[key]\n  }\n\n  function set (node, key, value) {\n    // Make sure we don't actually create a new domData key if we are actually deleting a value\n    var dataForNode = getDataForNode(node, value !== undefined /* createIfNotFound */);\n    dataForNode && (dataForNode[key] = value);\n  }\n\n  function getOrSet (node, key, value) {\n    const dataForNode = getDataForNode(node, true, /* createIfNotFound */);\n    return dataForNode[key] || (dataForNode[key] = value)\n  }\n\n  var domData = /*#__PURE__*/Object.freeze({\n    nextKey: nextKey,\n    get: get,\n    set: set,\n    getOrSet: getOrSet,\n    clear: clear\n  });\n\n  //\n\n  var domDataKey = nextKey();\n  // Node types:\n  // 1: Element\n  // 8: Comment\n  // 9: Document\n  var cleanableNodeTypes = { 1: true, 8: true, 9: true };\n  var cleanableNodeTypesWithDescendants = { 1: true, 9: true };\n\n  function getDisposeCallbacksCollection (node, createIfNotFound) {\n    var allDisposeCallbacks = get(node, domDataKey);\n    if ((allDisposeCallbacks === undefined) && createIfNotFound) {\n      allDisposeCallbacks = [];\n      set(node, domDataKey, allDisposeCallbacks);\n    }\n    return allDisposeCallbacks\n  }\n  function destroyCallbacksCollection (node) {\n    set(node, domDataKey, undefined);\n  }\n\n  function cleanSingleNode (node) {\n      // Run all the dispose callbacks\n    var callbacks = getDisposeCallbacksCollection(node, false);\n    if (callbacks) {\n      callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)\n      for (let i = 0; i < callbacks.length; i++) { callbacks[i](node); }\n    }\n\n      // Erase the DOM data\n    clear(node);\n\n      // Perform cleanup needed by external libraries (currently only jQuery, but can be extended)\n    for (let i = 0, j = otherNodeCleanerFunctions.length; i < j; ++i) {\n      otherNodeCleanerFunctions[i](node);\n    }\n\n    if (options.cleanExternalData) {\n      options.cleanExternalData(node);\n    }\n\n      // Clear any immediate-child comment nodes, as these wouldn't have been found by\n      // node.getElementsByTagName('*') in cleanNode() (comment nodes aren't elements)\n    if (cleanableNodeTypesWithDescendants[node.nodeType]) {\n      cleanNodesInList(node.childNodes, true /* onlyComments */);\n    }\n  }\n\n  function cleanNodesInList (nodeList, onlyComments) {\n    const cleanedNodes = [];\n    let lastCleanedNode;\n    for (var i = 0; i < nodeList.length; i++) {\n      if (!onlyComments || nodeList[i].nodeType === 8) {\n        cleanSingleNode(cleanedNodes[cleanedNodes.length] = lastCleanedNode = nodeList[i]);\n        if (nodeList[i] !== lastCleanedNode) {\n          while (i-- && arrayIndexOf(cleanedNodes, nodeList[i]) === -1) {}\n        }\n      }\n    }\n  }\n\n  // Exports\n  function addDisposeCallback (node, callback) {\n    if (typeof callback !== 'function') { throw new Error('Callback must be a function') }\n    getDisposeCallbacksCollection(node, true).push(callback);\n  }\n\n  function removeDisposeCallback (node, callback) {\n    var callbacksCollection = getDisposeCallbacksCollection(node, false);\n    if (callbacksCollection) {\n      arrayRemoveItem(callbacksCollection, callback);\n      if (callbacksCollection.length === 0) { destroyCallbacksCollection(node); }\n    }\n  }\n\n  function cleanNode (node) {\n    // First clean this node, where applicable\n    if (cleanableNodeTypes[node.nodeType]) {\n      cleanSingleNode(node);\n\n      // ... then its descendants, where applicable\n      if (cleanableNodeTypesWithDescendants[node.nodeType]) {\n        cleanNodesInList(node.getElementsByTagName(\"*\"));\n      }\n    }\n    return node\n  }\n\n  function removeNode (node) {\n    cleanNode(node);\n    if (node.parentNode) { node.parentNode.removeChild(node); }\n  }\n\n  // Expose supplemental node cleaning functions.\n  const otherNodeCleanerFunctions = [];\n\n  function addCleaner (fn) {\n    otherNodeCleanerFunctions.push(fn);\n  }\n\n  function removeCleaner (fn) {\n    const fnIndex = otherNodeCleanerFunctions.indexOf(fn);\n    if (fnIndex >= 0) { otherNodeCleanerFunctions.splice(fnIndex, 1); }\n  }\n\n  // Special support for jQuery here because it's so commonly used.\n  // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData\n  // so notify it to tear down any resources associated with the node & descendants here.\n  function cleanjQueryData (node) {\n    var jQueryCleanNodeFn = jQueryInstance ? jQueryInstance.cleanData : null;\n\n    if (jQueryCleanNodeFn) {\n      jQueryCleanNodeFn([node]);\n    }\n  }\n\n  otherNodeCleanerFunctions.push(cleanjQueryData);\n\n  //\n\n  // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)\n  var knownEvents = {},\n    knownEventTypesByEventName = {};\n\n  var keyEventTypeName = (options.global.navigator && /Firefox\\/2/i.test(options.global.navigator.userAgent)) ? 'KeyboardEvent' : 'UIEvents';\n\n  knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];\n\n  knownEvents['MouseEvents'] = [\n    'click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover',\n    'mouseout', 'mouseenter', 'mouseleave'];\n\n  objectForEach(knownEvents, function (eventType, knownEventsForType) {\n    if (knownEventsForType.length) {\n      for (var i = 0, j = knownEventsForType.length; i < j; i++) { knownEventTypesByEventName[knownEventsForType[i]] = eventType; }\n    }\n  });\n\n  function isClickOnCheckableElement (element, eventType) {\n    if ((tagNameLower(element) !== 'input') || !element.type) return false\n    if (eventType.toLowerCase() != 'click') return false\n    var inputType = element.type;\n    return (inputType == 'checkbox') || (inputType == 'radio')\n  }\n\n  // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406\n  var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true };\n  let jQueryEventAttachName;\n\n  function registerEventHandler (element, eventType, handler, eventOptions = false) {\n    const wrappedHandler = catchFunctionErrors(handler);\n    const mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];\n    const mustUseNative = Boolean(eventOptions);\n\n    if (!options.useOnlyNativeEvents && !mustUseAttachEvent && !mustUseNative && jQueryInstance) {\n      if (!jQueryEventAttachName) {\n        jQueryEventAttachName = (typeof jQueryInstance(element).on === 'function') ? 'on' : 'bind';\n      }\n      jQueryInstance(element)[jQueryEventAttachName](eventType, wrappedHandler);\n    } else if (!mustUseAttachEvent && typeof element.addEventListener === 'function') {\n      element.addEventListener(eventType, wrappedHandler, eventOptions);\n    } else if (typeof element.attachEvent !== 'undefined') {\n      const attachEventHandler = function (event) { wrappedHandler.call(element, event); };\n      const attachEventName = 'on' + eventType;\n      element.attachEvent(attachEventName, attachEventHandler);\n\n      // IE does not dispose attachEvent handlers automatically (unlike with addEventListener)\n      // so to avoid leaks, we have to remove them manually. See bug #856\n      addDisposeCallback(element, function () {\n        element.detachEvent(attachEventName, attachEventHandler);\n      });\n    } else {\n      throw new Error(\"Browser doesn't support addEventListener or attachEvent\")\n    }\n  }\n\n  function triggerEvent (element, eventType) {\n    if (!(element && element.nodeType)) { throw new Error('element must be a DOM node when calling triggerEvent') }\n\n      // For click events on checkboxes and radio buttons, jQuery toggles the element checked state *after* the\n      // event handler runs instead of *before*. (This was fixed in 1.9 for checkboxes but not for radio buttons.)\n      // IE doesn't change the checked state when you trigger the click event using \"fireEvent\".\n      // In both cases, we'll use the click method instead.\n    var useClickWorkaround = isClickOnCheckableElement(element, eventType);\n\n    if (!options.useOnlyNativeEvents && jQueryInstance && !useClickWorkaround) {\n      jQueryInstance(element).trigger(eventType);\n    } else if (typeof document.createEvent === 'function') {\n      if (typeof element.dispatchEvent === 'function') {\n        var eventCategory = knownEventTypesByEventName[eventType] || 'HTMLEvents';\n        var event = document.createEvent(eventCategory);\n        event.initEvent(eventType, true, true, options.global, 0, 0, 0, 0, 0, false, false, false, false, 0, element);\n        element.dispatchEvent(event);\n      } else { throw new Error(\"The supplied element doesn't support dispatchEvent\") }\n    } else if (useClickWorkaround && element.click) {\n      element.click();\n    } else if (typeof element.fireEvent !== 'undefined') {\n      element.fireEvent('on' + eventType);\n    } else {\n      throw new Error(\"Browser doesn't support triggering events\")\n    }\n  }\n\n  //\n\n  function moveCleanedNodesToContainerElement (nodes) {\n      // Ensure it's a real array, as we're about to reparent the nodes and\n      // we don't want the underlying collection to change while we're doing that.\n    var nodesArray = makeArray(nodes);\n    var templateDocument = (nodesArray[0] && nodesArray[0].ownerDocument) || document;\n\n    var container = templateDocument.createElement('div');\n    for (var i = 0, j = nodesArray.length; i < j; i++) {\n      container.appendChild(cleanNode(nodesArray[i]));\n    }\n    return container\n  }\n\n  function cloneNodes (nodesArray, shouldCleanNodes) {\n    for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {\n      var clonedNode = nodesArray[i].cloneNode(true);\n      newNodesArray.push(shouldCleanNodes ? cleanNode(clonedNode) : clonedNode);\n    }\n    return newNodesArray\n  }\n\n  function setDomNodeChildren (domNode, childNodes) {\n    emptyDomNode(domNode);\n    if (childNodes) {\n      for (var i = 0, j = childNodes.length; i < j; i++) { domNode.appendChild(childNodes[i]); }\n    }\n  }\n\n  function replaceDomNodes (nodeToReplaceOrNodeArray, newNodesArray) {\n    var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;\n    if (nodesToReplaceArray.length > 0) {\n      var insertionPoint = nodesToReplaceArray[0];\n      var parent = insertionPoint.parentNode;\n      for (var i = 0, j = newNodesArray.length; i < j; i++) { parent.insertBefore(newNodesArray[i], insertionPoint); }\n      for (i = 0, j = nodesToReplaceArray.length; i < j; i++) {\n        removeNode(nodesToReplaceArray[i]);\n      }\n    }\n  }\n\n  function setElementName (element, name) {\n    element.name = name;\n\n      // Workaround IE 6/7 issue\n      // - https://github.com/SteveSanderson/knockout/issues/197\n      // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/\n    if (ieVersion <= 7) {\n      try {\n        element.mergeAttributes(document.createElement(\"<input name='\" + element.name + \"'/>\"), false);\n      } catch (e) {} // For IE9 with doc mode \"IE9 Standards\" and browser mode \"IE9 Compatibility View\"\n    }\n  }\n\n  function emptyDomNode (domNode) {\n    while (domNode.firstChild) {\n      removeNode(domNode.firstChild);\n    }\n  }\n\n  //\n\n  function fixUpContinuousNodeArray (continuousNodeArray, parentNode) {\n      // Before acting on a set of nodes that were previously outputted by a template function, we have to reconcile\n      // them against what is in the DOM right now. It may be that some of the nodes have already been removed, or that\n      // new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been\n      // leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.\n      // So, this function translates the old \"map\" output array into its best guess of the set of current DOM nodes.\n      //\n      // Rules:\n      //   [A] Any leading nodes that have been removed should be ignored\n      //       These most likely correspond to memoization nodes that were already removed during binding\n      //       See https://github.com/knockout/knockout/pull/440\n      //   [B] Any trailing nodes that have been remove should be ignored\n      //       This prevents the code here from adding unrelated nodes to the array while processing rule [C]\n      //       See https://github.com/knockout/knockout/pull/1903\n      //   [C] We want to output a continuous series of nodes. So, ignore any nodes that have already been removed,\n      //       and include any nodes that have been inserted among the previous collection\n\n    if (continuousNodeArray.length) {\n          // The parent node can be a virtual element; so get the real parent node\n      parentNode = (parentNode.nodeType === 8 && parentNode.parentNode) || parentNode;\n\n          // Rule [A]\n      while (continuousNodeArray.length && continuousNodeArray[0].parentNode !== parentNode) { continuousNodeArray.splice(0, 1); }\n\n          // Rule [B]\n      while (continuousNodeArray.length > 1 && continuousNodeArray[continuousNodeArray.length - 1].parentNode !== parentNode) { continuousNodeArray.length--; }\n\n          // Rule [C]\n      if (continuousNodeArray.length > 1) {\n        var current = continuousNodeArray[0], last = continuousNodeArray[continuousNodeArray.length - 1];\n              // Replace with the actual new continuous node set\n        continuousNodeArray.length = 0;\n        while (current !== last) {\n          continuousNodeArray.push(current);\n          current = current.nextSibling;\n        }\n        continuousNodeArray.push(last);\n      }\n    }\n    return continuousNodeArray\n  }\n\n  function setOptionNodeSelectionState (optionNode, isSelected) {\n      // IE6 sometimes throws \"unknown error\" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.\n    if (ieVersion < 7) { optionNode.setAttribute('selected', isSelected); } else { optionNode.selected = isSelected; }\n  }\n\n  function forceRefresh (node) {\n      // Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209\n    if (ieVersion >= 9) {\n          // For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container\n      var elem = node.nodeType == 1 ? node : node.parentNode;\n      if (elem.style) { elem.style.zoom = elem.style.zoom; }\n    }\n  }\n\n  function ensureSelectElementIsRenderedCorrectly (selectElement) {\n      // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.\n      // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)\n      // Also fixes IE7 and IE8 bug that causes selects to be zero width if enclosed by 'if' or 'with'. (See issue #839)\n    if (ieVersion) {\n      var originalWidth = selectElement.style.width;\n      selectElement.style.width = 0;\n      selectElement.style.width = originalWidth;\n    }\n  }\n\n  /* eslint no-cond-assign: 0 */\n\n  var commentNodesHaveTextProperty = options.document && options.document.createComment('test').text === '<!--test-->';\n\n  var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\\s*ko(?:\\s+([\\s\\S]+))?\\s*-->$/ : /^\\s*ko(?:\\s+([\\s\\S]+))?\\s*$/;\n  var endCommentRegex = commentNodesHaveTextProperty ? /^<!--\\s*\\/ko\\s*-->$/ : /^\\s*\\/ko\\s*$/;\n  var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };\n\n  function isStartComment (node) {\n    return (node.nodeType == 8) && startCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue)\n  }\n\n  function isEndComment (node) {\n    return (node.nodeType == 8) && endCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue)\n  }\n\n  function isUnmatchedEndComment (node) {\n    return isEndComment(node) && !get(node, matchedEndCommentDataKey)\n  }\n\n  const matchedEndCommentDataKey = '__ko_matchedEndComment__';\n\n  function getVirtualChildren (startComment, allowUnbalanced) {\n    var currentNode = startComment;\n    var depth = 1;\n    var children = [];\n    while (currentNode = currentNode.nextSibling) {\n      if (isEndComment(currentNode)) {\n        set(currentNode, matchedEndCommentDataKey, true);\n        depth--;\n        if (depth === 0) { return children }\n      }\n\n      children.push(currentNode);\n\n      if (isStartComment(currentNode)) { depth++; }\n    }\n    if (!allowUnbalanced) { throw new Error('Cannot find closing comment tag to match: ' + startComment.nodeValue) }\n    return null\n  }\n\n  function getMatchingEndComment (startComment, allowUnbalanced) {\n    var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);\n    if (allVirtualChildren) {\n      if (allVirtualChildren.length > 0) { return allVirtualChildren[allVirtualChildren.length - 1].nextSibling }\n      return startComment.nextSibling\n    } else { return null } // Must have no matching end comment, and allowUnbalanced is true\n  }\n\n  function getUnbalancedChildTags (node) {\n      // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>\n      //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->\n    var childNode = node.firstChild, captureRemaining = null;\n    if (childNode) {\n      do {\n        if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes\n            { captureRemaining.push(childNode); } else if (isStartComment(childNode)) {\n              var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);\n              if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set\n                    { childNode = matchingEndComment; } else { captureRemaining = [childNode]; } // It's unbalanced, so start capturing from this point\n            } else if (isEndComment(childNode)) {\n              captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing\n            }\n      } while (childNode = childNode.nextSibling)\n    }\n    return captureRemaining\n  }\n\n  var allowedBindings = {};\n  var hasBindingValue = isStartComment;\n\n  function childNodes (node) {\n    return isStartComment(node) ? getVirtualChildren(node) : node.childNodes\n  }\n\n  function emptyNode (node) {\n    if (!isStartComment(node)) { emptyDomNode(node); } else {\n      var virtualChildren = childNodes(node);\n      for (var i = 0, j = virtualChildren.length; i < j; i++) { removeNode(virtualChildren[i]); }\n    }\n  }\n\n  function setDomNodeChildren$1 (node, childNodes) {\n    if (!isStartComment(node)) { setDomNodeChildren(node, childNodes); } else {\n      emptyNode(node);\n      const endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children\n      const parentNode = endCommentNode.parentNode;\n      for (var i = 0, j = childNodes.length; i < j; ++i) {\n        parentNode.insertBefore(childNodes[i], endCommentNode);\n      }\n    }\n  }\n\n  function prepend (containerNode, nodeToPrepend) {\n    if (!isStartComment(containerNode)) {\n      if (containerNode.firstChild) { containerNode.insertBefore(nodeToPrepend, containerNode.firstChild); } else { containerNode.appendChild(nodeToPrepend); }\n    } else {\n          // Start comments must always have a parent and at least one following sibling (the end comment)\n      containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);\n    }\n  }\n\n  function insertAfter (containerNode, nodeToInsert, insertAfterNode) {\n    if (!insertAfterNode) {\n      prepend(containerNode, nodeToInsert);\n    } else if (!isStartComment(containerNode)) {\n          // Insert after insertion point\n      if (insertAfterNode.nextSibling) { containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling); } else { containerNode.appendChild(nodeToInsert); }\n    } else {\n          // Children of start comments must always have a parent and at least one following sibling (the end comment)\n      containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);\n    }\n  }\n\n  function firstChild (node) {\n    if (!isStartComment(node)) {\n      if (node.firstChild && isEndComment(node.firstChild)) {\n        throw new Error('Found invalid end comment, as the first child of ' + node.outerHTML)\n      }\n      return node.firstChild\n    }\n    if (!node.nextSibling || isEndComment(node.nextSibling)) {\n      return null\n    }\n    return node.nextSibling\n  }\n\n  function lastChild (node) {\n    let nextChild = firstChild(node);\n    let lastChildNode;\n\n    do {\n      lastChildNode = nextChild;\n    } while (nextChild = nextSibling(nextChild))\n\n    return lastChildNode\n  }\n\n  function nextSibling (node) {\n    if (isStartComment(node)) {\n      node = getMatchingEndComment(node);\n    }\n\n    if (node.nextSibling && isEndComment(node.nextSibling)) {\n      if (isUnmatchedEndComment(node.nextSibling)) {\n        throw Error('Found end comment without a matching opening comment, as next sibling of ' + node.outerHTML)\n      }\n      return null\n    } else {\n      return node.nextSibling\n    }\n  }\n\n  function previousSibling (node) {\n    var depth = 0;\n    do {\n      if (node.nodeType === 8) {\n        if (isStartComment(node)) {\n          if (--depth === 0) {\n            return node\n          }\n        } else if (isEndComment(node)) {\n          depth++;\n        }\n      } else {\n        if (depth === 0) { return node }\n      }\n    } while (node = node.previousSibling)\n  }\n\n  function virtualNodeBindingValue (node) {\n    var regexMatch = (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);\n    return regexMatch ? regexMatch[1] : null\n  }\n\n  function normaliseVirtualElementDomStructure (elementVerified) {\n      // Workaround for https://github.com/SteveSanderson/knockout/issues/155\n      // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes\n      // that are direct descendants of <ul> into the preceding <li>)\n    if (!htmlTagsWithOptionallyClosingChildren[tagNameLower(elementVerified)]) { return }\n\n      // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags\n      // must be intended to appear *after* that child, so move them there.\n    var childNode = elementVerified.firstChild;\n    if (childNode) {\n      do {\n        if (childNode.nodeType === 1) {\n          var unbalancedTags = getUnbalancedChildTags(childNode);\n          if (unbalancedTags) {\n                      // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child\n            var nodeToInsertBefore = childNode.nextSibling;\n            for (var i = 0; i < unbalancedTags.length; i++) {\n              if (nodeToInsertBefore) { elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore); } else { elementVerified.appendChild(unbalancedTags[i]); }\n            }\n          }\n        }\n      } while (childNode = childNode.nextSibling)\n    }\n  }\n\n  var virtualElements = /*#__PURE__*/Object.freeze({\n    startCommentRegex: startCommentRegex,\n    endCommentRegex: endCommentRegex,\n    isStartComment: isStartComment,\n    isEndComment: isEndComment,\n    getVirtualChildren: getVirtualChildren,\n    allowedBindings: allowedBindings,\n    hasBindingValue: hasBindingValue,\n    childNodes: childNodes,\n    emptyNode: emptyNode,\n    setDomNodeChildren: setDomNodeChildren$1,\n    prepend: prepend,\n    insertAfter: insertAfter,\n    firstChild: firstChild,\n    lastChild: lastChild,\n    nextSibling: nextSibling,\n    previousSibling: previousSibling,\n    virtualNodeBindingValue: virtualNodeBindingValue,\n    normaliseVirtualElementDomStructure: normaliseVirtualElementDomStructure\n  });\n\n  //\n\n  var none = [0, '', ''],\n    table = [1, '<table>', '</table>'],\n    tbody = [2, '<table><tbody>', '</tbody></table>'],\n    colgroup = [ 2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n    tr = [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n    select = [1, \"<select multiple='multiple'>\", '</select>'],\n    fieldset = [1, '<fieldset>', '</fieldset>'],\n    map = [1, '<map>', '</map>'],\n    object = [1, '<object>', '</object>'],\n    lookup = {\n      'area': map,\n      'col': colgroup,\n      'colgroup': table,\n      'caption': table,\n      'legend': fieldset,\n      'thead': table,\n      'tbody': table,\n      'tfoot': table,\n      'tr': tbody,\n      'td': tr,\n      'th': tr,\n      'option': select,\n      'optgroup': select,\n      'param': object\n    },\n\n      // The canonical way to test that the HTML5 <template> tag is supported\n    supportsTemplateTag = options.document && 'content' in options.document.createElement('template');\n\n  function getWrap (tags) {\n    const m = tags.match(/^(?:<!--.*?-->\\s*?)*?<([a-z]+)[\\s>]/);\n    return (m && lookup[m[1]]) || none\n  }\n\n  function simpleHtmlParse (html, documentContext) {\n    documentContext || (documentContext = document);\n    var windowContext = documentContext['parentWindow'] || documentContext['defaultView'] || window;\n\n      // Based on jQuery's \"clean\" function, but only accounting for table-related elements.\n      // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's \"clean\" function directly\n\n      // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of\n      // a descendant node. For example: \"<div><!-- mycomment -->abc</div>\" will get parsed as \"<div>abc</div>\"\n      // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node\n      // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.\n\n      // Trim whitespace, otherwise indexOf won't work as expected\n    var tags = stringTrim(html).toLowerCase(), div = documentContext.createElement('div'),\n      wrap = getWrap(tags),\n      depth = wrap[0];\n\n      // Go to html and back, then peel off extra wrappers\n      // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.\n    var markup = 'ignored<div>' + wrap[1] + html + wrap[2] + '</div>';\n    if (typeof windowContext['innerShiv'] === 'function') {\n          // Note that innerShiv is deprecated in favour of html5shiv. We should consider adding\n          // support for html5shiv (except if no explicit support is needed, e.g., if html5shiv\n          // somehow shims the native APIs so it just works anyway)\n      div.appendChild(windowContext['innerShiv'](markup));\n    } else {\n      div.innerHTML = markup;\n    }\n\n      // Move to the right depth\n    while (depth--) { div = div.lastChild; }\n\n    return makeArray(div.lastChild.childNodes)\n  }\n\n  function templateHtmlParse (html, documentContext) {\n    if (!documentContext) { documentContext = document; }\n    var template = documentContext.createElement('template');\n    template.innerHTML = html;\n    return makeArray(template.content.childNodes)\n  }\n\n  function jQueryHtmlParse (html, documentContext) {\n      // jQuery's \"parseHTML\" function was introduced in jQuery 1.8.0 and is a documented public API.\n    if (jQueryInstance.parseHTML) {\n      return jQueryInstance.parseHTML(html, documentContext) || [] // Ensure we always return an array and never null\n    } else {\n          // For jQuery < 1.8.0, we fall back on the undocumented internal \"clean\" function.\n      var elems = jQueryInstance.clean([html], documentContext);\n\n          // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.\n          // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.\n          // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.\n      if (elems && elems[0]) {\n              // Find the top-most parent element that's a direct child of a document fragment\n        var elem = elems[0];\n        while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */) { elem = elem.parentNode; }\n              // ... then detach it\n        if (elem.parentNode) { elem.parentNode.removeChild(elem); }\n      }\n\n      return elems\n    }\n  }\n\n  /**\n   * parseHtmlFragment converts a string into an array of DOM Nodes.\n   * If supported, it uses <template>-tag parsing, falling back on\n   * jQuery parsing (if jQuery is present), and finally on a\n   * straightforward parser.\n   *\n   * @param  {string} html            To be parsed.\n   * @param  {Object} documentContext That owns the executing code.\n   * @return {[DOMNode]}              Parsed DOM Nodes\n   */\n  function parseHtmlFragment (html, documentContext) {\n      // Prefer <template>-tag based HTML parsing.\n    return supportsTemplateTag ? templateHtmlParse(html, documentContext)\n\n          // Benefit from jQuery's on old browsers, where possible\n          // NOTE: jQuery's HTML parsing fails on element names like tr-*.\n          // See: https://github.com/jquery/jquery/pull/1988\n          : (jQueryInstance ? jQueryHtmlParse(html, documentContext)\n\n          // ... otherwise, this simple logic will do in most common cases.\n          : simpleHtmlParse(html, documentContext))\n  }\n\n  function parseHtmlForTemplateNodes (html, documentContext) {\n    const nodes = parseHtmlFragment(html, documentContext);\n    return (nodes.length && nodes[0].parentElement) || moveCleanedNodesToContainerElement(nodes)\n  }\n\n  /**\n    * setHtml empties the node's contents, unwraps the HTML, and\n    * sets the node's HTML using jQuery.html or parseHtmlFragment\n    *\n    * @param {DOMNode} node Node in which HTML needs to be set\n    * @param {DOMNode} html HTML to be inserted in node\n    * @returns undefined\n    */\n  function setHtml (node, html) {\n    emptyDomNode(node);\n\n      // There's few cases where we would want to display a stringified\n      // function, so we unwrap it.\n    if (typeof html === 'function') {\n      html = html();\n    }\n\n    if ((html !== null) && (html !== undefined)) {\n      if (typeof html !== 'string') { html = html.toString(); }\n\n          // If the browser supports <template> tags, prefer that, as\n          // it obviates all the complex workarounds of jQuery.\n          //\n          // However, jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,\n          // for example <tr> elements which are not normally allowed to exist on their own.\n          // If you've referenced jQuery (and template tags are not supported) we'll use that rather than duplicating its code.\n      if (jQueryInstance && !supportsTemplateTag) {\n        jQueryInstance(node).html(html);\n      } else {\n              // ... otherwise, use KO's own parsing logic.\n        var parsedNodes = parseHtmlFragment(html, node.ownerDocument);\n\n        if (node.nodeType === 8) {\n          if (html === null) {\n            emptyNode(node);\n          } else {\n            setDomNodeChildren$1(node, parsedNodes);\n          }\n        } else {\n          for (var i = 0; i < parsedNodes.length; i++) { node.appendChild(parsedNodes[i]); }\n        }\n      }\n    }\n  }\n\n\n  function setTextContent (element, textContent) {\n    var value = typeof textContent === 'function' ? textContent() : textContent;\n    if ((value === null) || (value === undefined)) { value = ''; }\n\n      // We need there to be exactly one child: a text node.\n      // If there are no children, more than one, or if it's not a text node,\n      // we'll clear everything and create a single text node.\n    var innerTextNode = firstChild(element);\n    if (!innerTextNode || innerTextNode.nodeType != 3 || nextSibling(innerTextNode)) {\n      setDomNodeChildren$1(element, [element.ownerDocument.createTextNode(value)]);\n    } else {\n      innerTextNode.data = value;\n    }\n\n    forceRefresh(element);\n  }\n\n  var hasDomDataExpandoProperty = Symbol('Knockout selectExtensions hasDomDataProperty');\n\n  // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values\n  // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values\n  // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.\n  //\n  var selectExtensions = {\n    optionValueDomDataKey: nextKey(),\n\n    readValue: function (element) {\n      switch (tagNameLower(element)) {\n        case 'option':\n          if (element[hasDomDataExpandoProperty] === true) { return get(element, selectExtensions.optionValueDomDataKey) }\n          return element.value\n        case 'select':\n          return element.selectedIndex >= 0 ? selectExtensions.readValue(element.options[element.selectedIndex]) : undefined\n        default:\n          return element.value\n      }\n    },\n\n    writeValue: function (element, value, allowUnset) {\n      switch (tagNameLower(element)) {\n        case 'option':\n          if (typeof value === 'string') {\n            set(element, selectExtensions.optionValueDomDataKey, undefined);\n            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node\n              delete element[hasDomDataExpandoProperty];\n            }\n            element.value = value;\n          } else {\n                          // Store arbitrary object using DomData\n            set(element, selectExtensions.optionValueDomDataKey, value);\n            element[hasDomDataExpandoProperty] = true;\n                          // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.\n            element.value = typeof value === 'number' ? value : '';\n          }\n\n          break\n        case 'select':\n          if (value === '' || value === null) {\n            // A blank string or null value will select the caption\n            value = undefined;\n          }\n          var selection = -1;\n          for (let i = 0, n = element.options.length, optionValue; i < n; ++i) {\n            optionValue = selectExtensions.readValue(element.options[i]);\n            // Include special check to handle selecting a caption with a blank string value\n            if (optionValue === value || (optionValue === '' && value === undefined)) {\n              selection = i;\n              break\n            }\n          }\n          if (allowUnset || selection >= 0 || (value === undefined && element.size > 1)) {\n            element.selectedIndex = selection;\n            if (ieVersion === 6) {\n              // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread\n              // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread\n              // to apply the value as well.\n              safeSetTimeout(() => { element.selectedIndex = selection; }, 0);\n            }\n          }\n          break\n        default:\n          if ((value === null) || (value === undefined)) { value = ''; }\n          element.value = value;\n          break\n      }\n    }\n  };\n\n  //\n\n  var memos = {};\n\n  function randomMax8HexChars () {\n    return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1)\n  }\n\n  function generateRandomId () {\n    return randomMax8HexChars() + randomMax8HexChars()\n  }\n\n  function findMemoNodes (rootNode, appendToArray) {\n    if (!rootNode) { return }\n    if (rootNode.nodeType == 8) {\n      var memoId = parseMemoText(rootNode.nodeValue);\n      if (memoId != null) { appendToArray.push({ domNode: rootNode, memoId: memoId }); }\n    } else if (rootNode.nodeType == 1) {\n      for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++) { findMemoNodes(childNodes[i], appendToArray); }\n    }\n  }\n\n  function memoize (callback) {\n    if (typeof callback !== 'function') { throw new Error('You can only pass a function to memoization.memoize()') }\n    var memoId = generateRandomId();\n    memos[memoId] = callback;\n    return '<!--[ko_memo:' + memoId + ']-->'\n  }\n\n  function unmemoize (memoId, callbackParams) {\n    var callback = memos[memoId];\n    if (callback === undefined) { throw new Error(\"Couldn't find any memo with ID \" + memoId + \". Perhaps it's already been unmemoized.\") }\n    try {\n      callback.apply(null, callbackParams || []);\n      return true\n    } finally { delete memos[memoId]; }\n  }\n\n  function unmemoizeDomNodeAndDescendants (domNode, extraCallbackParamsArray) {\n    var memos = [];\n    findMemoNodes(domNode, memos);\n    for (var i = 0, j = memos.length; i < j; i++) {\n      var node = memos[i].domNode;\n      var combinedParams = [node];\n      if (extraCallbackParamsArray) { arrayPushAll(combinedParams, extraCallbackParamsArray); }\n      unmemoize(memos[i].memoId, combinedParams);\n      node.nodeValue = ''; // Neuter this node so we don't try to unmemoize it again\n      if (node.parentNode) { node.parentNode.removeChild(node); } // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)\n    }\n  }\n\n  function parseMemoText (memoText) {\n    var match = memoText.match(/^\\[ko_memo\\:(.*?)\\]$/);\n    return match ? match[1] : null\n  }\n\n  var memoization = /*#__PURE__*/Object.freeze({\n    memoize: memoize,\n    unmemoize: unmemoize,\n    unmemoizeDomNodeAndDescendants: unmemoizeDomNodeAndDescendants,\n    parseMemoText: parseMemoText\n  });\n\n  //\n\n  var taskQueue = [],\n    taskQueueLength = 0,\n    nextHandle = 1,\n    nextIndexToProcess = 0,\n    w = options.global;\n\n  if (w && w.MutationObserver && !(w.navigator && w.navigator.standalone)) {\n      // Chrome 27+, Firefox 14+, IE 11+, Opera 15+, Safari 6.1+, node\n      // From https://github.com/petkaantonov/bluebird * Copyright (c) 2014 Petka Antonov * License: MIT\n    options.taskScheduler = (function (callback) {\n      var div = w.document.createElement('div');\n      new w.MutationObserver(callback).observe(div, {attributes: true});\n      return function () { div.classList.toggle('foo'); }\n    })(scheduledProcess);\n  } else if (w && w.document && 'onreadystatechange' in w.document.createElement('script')) {\n      // IE 6-10\n      // From https://github.com/YuzuJS/setImmediate * Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola * License: MIT\n    options.taskScheduler = function (callback) {\n      var script = document.createElement('script');\n      script.onreadystatechange = function () {\n        script.onreadystatechange = null;\n        document.documentElement.removeChild(script);\n        script = null;\n        callback();\n      };\n      document.documentElement.appendChild(script);\n    };\n  } else {\n    options.taskScheduler = function (callback) {\n      setTimeout(callback, 0);\n    };\n  }\n\n  function processTasks () {\n    if (taskQueueLength) {\n          // Each mark represents the end of a logical group of tasks and the number of these groups is\n          // limited to prevent unchecked recursion.\n      var mark = taskQueueLength, countMarks = 0;\n\n          // nextIndexToProcess keeps track of where we are in the queue; processTasks can be called recursively without issue\n      for (var task; nextIndexToProcess < taskQueueLength;) {\n        if (task = taskQueue[nextIndexToProcess++]) {\n          if (nextIndexToProcess > mark) {\n            if (++countMarks >= 5000) {\n              nextIndexToProcess = taskQueueLength;   // skip all tasks remaining in the queue since any of them could be causing the recursion\n              deferError(Error(\"'Too much recursion' after processing \" + countMarks + ' task groups.'));\n              break\n            }\n            mark = taskQueueLength;\n          }\n          try {\n            task();\n          } catch (ex) {\n            deferError(ex);\n          }\n        }\n      }\n    }\n  }\n\n  function scheduledProcess () {\n    processTasks();\n\n      // Reset the queue\n    nextIndexToProcess = taskQueueLength = taskQueue.length = 0;\n  }\n\n  function scheduleTaskProcessing () {\n    options.taskScheduler(scheduledProcess);\n  }\n\n  function schedule (func) {\n    if (!taskQueueLength) {\n      scheduleTaskProcessing();\n    }\n\n    taskQueue[taskQueueLength++] = func;\n    return nextHandle++\n  }\n\n  function cancel (handle) {\n    var index = handle - (nextHandle - taskQueueLength);\n    if (index >= nextIndexToProcess && index < taskQueueLength) {\n      taskQueue[index] = null;\n    }\n  }\n\n  // For testing only: reset the queue and return the previous queue length\n  function resetForTesting () {\n    var length = taskQueueLength - nextIndexToProcess;\n    nextIndexToProcess = taskQueueLength = taskQueue.length = 0;\n    return length\n  }\n\n  var tasks = /*#__PURE__*/Object.freeze({\n    schedule: schedule,\n    cancel: cancel,\n    resetForTesting: resetForTesting,\n    runEarly: processTasks\n  });\n\n  /*\n    tko.util\n    ===\n\n  */\n\n  /**\n   * Create a subscribable symbol that's used to identify subscribables.\n   */\n  const SUBSCRIBABLE_SYM = Symbol('Knockout Subscribable');\n\n  function isSubscribable (instance) {\n    return (instance && instance[SUBSCRIBABLE_SYM]) || false\n  }\n\n  //\n\n  const outerFrames = [];\n  let currentFrame;\n  let lastId = 0;\n\n  // Return a unique ID that can be assigned to an observable for dependency tracking.\n  // Theoretically, you could eventually overflow the number storage size, resulting\n  // in duplicate IDs. But in JavaScript, the largest exact integral value is 2^53\n  // or 9,007,199,254,740,992. If you created 1,000,000 IDs per second, it would\n  // take over 285 years to reach that number.\n  // Reference http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.html\n  function getId () {\n    return ++lastId\n  }\n\n  function begin (options) {\n    outerFrames.push(currentFrame);\n    currentFrame = options;\n  }\n\n  function end () {\n    currentFrame = outerFrames.pop();\n  }\n\n  function registerDependency (subscribable) {\n    if (currentFrame) {\n      if (!isSubscribable(subscribable)) { throw new Error('Only subscribable things can act as dependencies') }\n      currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = getId()));\n    }\n  }\n\n  function ignore (callback, callbackTarget, callbackArgs) {\n    try {\n      begin();\n      return callback.apply(callbackTarget, callbackArgs || [])\n    } finally {\n      end();\n    }\n  }\n\n  function getDependenciesCount () {\n    if (currentFrame) { return currentFrame.computed.getDependenciesCount() }\n  }\n\n  function getDependencies () {\n    if (currentFrame) { return currentFrame.computed.getDependencies() }\n  }\n\n  function isInitial () {\n    if (currentFrame) { return currentFrame.isInitial }\n  }\n\n  var dependencyDetection = /*#__PURE__*/Object.freeze({\n    begin: begin,\n    end: end,\n    registerDependency: registerDependency,\n    ignore: ignore,\n    getDependenciesCount: getDependenciesCount,\n    getDependencies: getDependencies,\n    isInitial: isInitial,\n    ignoreDependencies: ignore\n  });\n\n  //\n\n  function deferUpdates (target) {\n    if (target._deferUpdates) { return }\n    target._deferUpdates = true;\n    target.limit(function (callback) {\n      let handle;\n      let ignoreUpdates = false;\n      return function () {\n        if (!ignoreUpdates) {\n          cancel(handle);\n          handle = schedule(callback);\n          try {\n            ignoreUpdates = true;\n            target.notifySubscribers(undefined, 'dirty');\n          } finally {\n            ignoreUpdates = false;\n          }\n        }\n      }\n    });\n  }\n\n  class Subscription {\n    constructor (target, observer, disposeCallback) {\n      this._target = target;\n      this._callback = observer.next;\n      this._disposeCallback = disposeCallback;\n      this._isDisposed = false;\n      this._domNodeDisposalCallback = null;\n    }\n\n    dispose () {\n      if (this._domNodeDisposalCallback) {\n        removeDisposeCallback(this._node, this._domNodeDisposalCallback);\n      }\n      this._isDisposed = true;\n      this._disposeCallback();\n    }\n\n    disposeWhenNodeIsRemoved (node) {\n      this._node = node;\n      addDisposeCallback(node, this._domNodeDisposalCallback = this.dispose.bind(this));\n    }\n\n    // TC39 Observable API\n    unsubscribe () { this.dispose(); }\n    get closed () { return this._isDisposed }\n  }\n\n  //\n\n  var primitiveTypes = {\n    'undefined': 1, 'boolean': 1, 'number': 1, 'string': 1\n  };\n\n  function valuesArePrimitiveAndEqual (a, b) {\n    var oldValueIsPrimitive = (a === null) || (typeof (a) in primitiveTypes);\n    return oldValueIsPrimitive ? (a === b) : false\n  }\n\n  function applyExtenders (requestedExtenders) {\n    var target = this;\n    if (requestedExtenders) {\n      objectForEach(requestedExtenders, function (key, value) {\n        var extenderHandler = extenders[key];\n        if (typeof extenderHandler === 'function') {\n          target = extenderHandler(target, value) || target;\n        } else {\n          options.onError(new Error('Extender not found: ' + key));\n        }\n      });\n    }\n    return target\n  }\n\n  /*\n                  --- DEFAULT EXTENDERS ---\n   */\n\n  // Change when notifications are published.\n  function notify (target, notifyWhen) {\n    target.equalityComparer = notifyWhen == 'always'\n          ? null  // null equalityComparer means to always notify\n          : valuesArePrimitiveAndEqual;\n  }\n\n  function deferred (target, option) {\n    if (option !== true) {\n      throw new Error('The \\'deferred\\' extender only accepts the value \\'true\\', because it is not supported to turn deferral off once enabled.')\n    }\n    deferUpdates(target);\n  }\n\n  function rateLimit (target, options$$1) {\n    var timeout, method, limitFunction;\n\n    if (typeof options$$1 === 'number') {\n      timeout = options$$1;\n    } else {\n      timeout = options$$1.timeout;\n      method = options$$1.method;\n    }\n\n      // rateLimit supersedes deferred updates\n    target._deferUpdates = false;\n\n    limitFunction = method === 'notifyWhenChangesStop' ? debounce : throttle;\n\n    target.limit(function (callback) {\n      return limitFunction(callback, timeout)\n    });\n  }\n\n  var extenders = {\n    notify: notify,\n    deferred: deferred,\n    rateLimit: rateLimit\n  };\n\n  /* eslint no-cond-assign: 0 */\n\n  // Descendants may have a LATEST_VALUE, which if present\n  // causes TC39 subscriptions to emit the latest value when\n  // subscribed.\n  const LATEST_VALUE = Symbol('Knockout latest value');\n\n  function subscribable () {\n    Object.setPrototypeOf(this, ko_subscribable_fn);\n    ko_subscribable_fn.init(this);\n  }\n\n  var defaultEvent = 'change';\n\n  var ko_subscribable_fn = {\n    [SUBSCRIBABLE_SYM]: true,\n    [Symbol.observable] () { return this },\n\n    init (instance) {\n      instance._subscriptions = { change: [] };\n      instance._versionNumber = 1;\n    },\n\n    subscribe (callback, callbackTarget, event) {\n      // TC39 proposed standard Observable { next: () => ... }\n      const isTC39Callback = typeof callback === 'object' && callback.next;\n\n      event = event || defaultEvent;\n      const observer = isTC39Callback ? callback : {\n        next: callbackTarget ? callback.bind(callbackTarget) : callback\n      };\n\n      const subscriptionInstance = new Subscription(this, observer, () => {\n        arrayRemoveItem(this._subscriptions[event], subscriptionInstance);\n        if (this.afterSubscriptionRemove) {\n          this.afterSubscriptionRemove(event);\n        }\n      });\n\n      if (this.beforeSubscriptionAdd) {\n        this.beforeSubscriptionAdd(event);\n      }\n\n      if (!this._subscriptions[event]) {\n        this._subscriptions[event] = [];\n      }\n      this._subscriptions[event].push(subscriptionInstance);\n\n      // Have TC39 `subscribe` immediately emit.\n      // https://github.com/tc39/proposal-observable/issues/190\n\n      if (isTC39Callback && LATEST_VALUE in this) {\n        observer.next(this[LATEST_VALUE]);\n      }\n\n      return subscriptionInstance\n    },\n\n    notifySubscribers (valueToNotify, event) {\n      event = event || defaultEvent;\n      if (event === defaultEvent) {\n        this.updateVersion();\n      }\n      if (this.hasSubscriptionsForEvent(event)) {\n        const subs = event === defaultEvent && this._changeSubscriptions\n          || [...this._subscriptions[event]];\n\n        try {\n          begin(); // Begin suppressing dependency detection (by setting the top frame to undefined)\n          for (let i = 0, subscriptionInstance; subscriptionInstance = subs[i]; ++i) {\n                      // In case a subscription was disposed during the arrayForEach cycle, check\n                      // for isDisposed on each subscription before invoking its callback\n            if (!subscriptionInstance._isDisposed) {\n              subscriptionInstance._callback(valueToNotify);\n            }\n          }\n        } finally {\n          end(); // End suppressing dependency detection\n        }\n      }\n    },\n\n    getVersion () {\n      return this._versionNumber\n    },\n\n    hasChanged (versionToCheck) {\n      return this.getVersion() !== versionToCheck\n    },\n\n    updateVersion () {\n      ++this._versionNumber;\n    },\n\n    hasSubscriptionsForEvent (event) {\n      return this._subscriptions[event] && this._subscriptions[event].length\n    },\n\n    getSubscriptionsCount (event) {\n      if (event) {\n        return this._subscriptions[event] && this._subscriptions[event].length || 0\n      } else {\n        var total = 0;\n        objectForEach(this._subscriptions, function (eventName, subscriptions) {\n          if (eventName !== 'dirty') {\n            total += subscriptions.length;\n          }\n        });\n        return total\n      }\n    },\n\n    isDifferent (oldValue, newValue) {\n      return !this.equalityComparer ||\n                 !this.equalityComparer(oldValue, newValue)\n    },\n\n    once (cb) {\n      const subs = this.subscribe((nv) => {\n        subs.dispose();\n        cb(nv);\n      });\n    },\n\n    when (test, returnValue) {\n      const current = this.peek();\n      const givenRv = arguments.length > 1;\n      const testFn = typeof test === 'function' ? test : v => v === test;\n      if (testFn(current)) {\n        return options.Promise.resolve(givenRv ? returnValue : current)\n      }\n      return new options.Promise((resolve, reject) => {\n        const subs = this.subscribe(newValue => {\n          if (testFn(newValue)) {\n            subs.dispose();\n            resolve(givenRv ? returnValue : newValue);\n          }\n        });\n      })\n    },\n\n    yet (test, ...args) {\n      const testFn = typeof test === 'function' ? test : v => v === test;\n      const negated = v => !testFn(v);\n      return this.when(negated, ...args)\n    },\n\n    next () { return new Promise(resolve => this.once(resolve)) },\n\n    toString () { return '[object Object]' },\n\n    extend: applyExtenders\n  };\n\n  // For browsers that support proto assignment, we overwrite the prototype of each\n  // observable instance. Since observables are functions, we need Function.prototype\n  // to still be in the prototype chain.\n  Object.setPrototypeOf(ko_subscribable_fn, Function.prototype);\n\n  subscribable.fn = ko_subscribable_fn;\n\n  //\n\n  function observable (initialValue) {\n    function Observable () {\n      if (arguments.length > 0) {\n              // Write\n              // Ignore writes if the value hasn't changed\n        if (Observable.isDifferent(Observable[LATEST_VALUE], arguments[0])) {\n          Observable.valueWillMutate();\n          Observable[LATEST_VALUE] = arguments[0];\n          Observable.valueHasMutated();\n        }\n        return this // Permits chained assignments\n      } else {\n              // Read\n        registerDependency(Observable); // The caller only needs to be notified of changes if they did a \"read\" operation\n        return Observable[LATEST_VALUE]\n      }\n    }\n\n    overwriteLengthPropertyIfSupported(Observable, { value: undefined });\n\n    Observable[LATEST_VALUE] = initialValue;\n\n    subscribable.fn.init(Observable);\n\n      // Inherit from 'observable'\n    Object.setPrototypeOf(Observable, observable.fn);\n\n    if (options.deferUpdates) {\n      deferUpdates(Observable);\n    }\n\n    return Observable\n  }\n\n  // Define prototype for observables\n  observable.fn = {\n    equalityComparer: valuesArePrimitiveAndEqual,\n    peek () { return this[LATEST_VALUE] },\n    valueHasMutated () {\n      this.notifySubscribers(this[LATEST_VALUE], 'spectate');\n      this.notifySubscribers(this[LATEST_VALUE]);\n    },\n    valueWillMutate () {\n      this.notifySubscribers(this[LATEST_VALUE], 'beforeChange');\n    },\n\n    modify (fn, peek = true) {\n      return this(fn(peek ? this.peek() : this()))\n    },\n\n    // Some observables may not always be writeable, notably computeds.\n    isWriteable: true\n  };\n\n  // Moved out of \"limit\" to avoid the extra closure\n  function limitNotifySubscribers (value, event) {\n    if (!event || event === defaultEvent) {\n      this._limitChange(value);\n    } else if (event === 'beforeChange') {\n      this._limitBeforeChange(value);\n    } else {\n      this._origNotifySubscribers(value, event);\n    }\n  }\n\n  // Add `limit` function to the subscribable prototype\n  subscribable.fn.limit = function limit (limitFunction) {\n    var self = this;\n    var selfIsObservable = isObservable(self);\n    var beforeChange = 'beforeChange';\n    var ignoreBeforeChange, notifyNextChange, previousValue, pendingValue, didUpdate;\n\n    if (!self._origNotifySubscribers) {\n      self._origNotifySubscribers = self.notifySubscribers;\n      self.notifySubscribers = limitNotifySubscribers;\n    }\n\n    var finish = limitFunction(function () {\n      self._notificationIsPending = false;\n\n      // If an observable provided a reference to itself, access it to get the latest value.\n      // This allows computed observables to delay calculating their value until needed.\n      if (selfIsObservable && pendingValue === self) {\n        pendingValue = self._evalIfChanged ? self._evalIfChanged() : self();\n      }\n      const shouldNotify = notifyNextChange || (\n        didUpdate && self.isDifferent(previousValue, pendingValue)\n      );\n      self._notifyNextChange = didUpdate = ignoreBeforeChange = false;\n      if (shouldNotify) {\n        self._origNotifySubscribers(previousValue = pendingValue);\n      }\n    });\n\n    Object.assign(self, {\n      _limitChange  (value, isDirty) {\n        if (!isDirty || !self._notificationIsPending) {\n          didUpdate = !isDirty;\n        }\n        self._changeSubscriptions = [...self._subscriptions[defaultEvent]];\n        self._notificationIsPending = ignoreBeforeChange = true;\n        pendingValue = value;\n        finish();\n      },\n\n      _limitBeforeChange (value) {\n        if (!ignoreBeforeChange) {\n          previousValue = value;\n          self._origNotifySubscribers(value, beforeChange);\n        }\n      },\n\n      _notifyNextChangeIfValueIsDifferent () {\n        if (self.isDifferent(previousValue, self.peek(true /* evaluate */))) {\n          notifyNextChange = true;\n        }\n      },\n\n      _recordUpdate () {\n        didUpdate = true;\n      }\n    });\n  };\n\n  Object.setPrototypeOf(observable.fn, subscribable.fn);\n\n  var protoProperty = observable.protoProperty = options.protoProperty;\n  observable.fn[protoProperty] = observable;\n\n  // Subclasses can add themselves to observableProperties so that\n  // isObservable will be `true`.\n  observable.observablePrototypes = new Set([observable]);\n\n  function isObservable (instance) {\n    const proto = typeof instance === 'function' && instance[protoProperty];\n    if (proto && !observable.observablePrototypes.has(proto)) {\n      throw Error('Invalid object that looks like an observable; possibly from another Knockout instance')\n    }\n    return !!proto\n  }\n\n  function unwrap (value) {\n    return isObservable(value) ? value() : value\n  }\n\n  function peek (value) {\n    return isObservable(value) ? value.peek() : value\n  }\n\n  function isWriteableObservable (instance) {\n    return isObservable(instance) && instance.isWriteable\n  }\n\n  //\n\n  var arrayChangeEventName = 'arrayChange';\n\n  function trackArrayChanges (target, options$$1) {\n      // Use the provided options--each call to trackArrayChanges overwrites the previously set options\n    target.compareArrayOptions = {};\n    if (options$$1 && typeof options$$1 === 'object') {\n      extend(target.compareArrayOptions, options$$1);\n    }\n    target.compareArrayOptions.sparse = true;\n\n      // Only modify the target observable once\n    if (target.cacheDiffForKnownOperation) {\n      return\n    }\n    let trackingChanges = false;\n    let cachedDiff = null;\n    let arrayChangeSubscription;\n    let pendingNotifications = 0;\n    let underlyingNotifySubscribersFunction;\n    let underlyingBeforeSubscriptionAddFunction = target.beforeSubscriptionAdd;\n    let underlyingAfterSubscriptionRemoveFunction = target.afterSubscriptionRemove;\n\n      // Watch \"subscribe\" calls, and for array change events, ensure change tracking is enabled\n    target.beforeSubscriptionAdd = function (event) {\n      if (underlyingBeforeSubscriptionAddFunction) {\n        underlyingBeforeSubscriptionAddFunction.call(target, event);\n      }\n      if (event === arrayChangeEventName) {\n        trackChanges();\n      }\n    };\n\n      // Watch \"dispose\" calls, and for array change events, ensure change tracking is disabled when all are disposed\n    target.afterSubscriptionRemove = function (event) {\n      if (underlyingAfterSubscriptionRemoveFunction) {\n        underlyingAfterSubscriptionRemoveFunction.call(target, event);\n      }\n      if (event === arrayChangeEventName && !target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n        if (underlyingNotifySubscribersFunction) {\n          target.notifySubscribers = underlyingNotifySubscribersFunction;\n          underlyingNotifySubscribersFunction = undefined;\n        }\n        if (arrayChangeSubscription) {\n          arrayChangeSubscription.dispose();\n        }\n        arrayChangeSubscription = null;\n        trackingChanges = false;\n      }\n    };\n\n    function trackChanges () {\n          // Calling 'trackChanges' multiple times is the same as calling it once\n      if (trackingChanges) {\n        return\n      }\n\n      trackingChanges = true;\n\n          // Intercept \"notifySubscribers\" to track how many times it was called.\n      underlyingNotifySubscribersFunction = target['notifySubscribers'];\n      target.notifySubscribers = function (valueToNotify, event) {\n        if (!event || event === defaultEvent) {\n          ++pendingNotifications;\n        }\n        return underlyingNotifySubscribersFunction.apply(this, arguments)\n      };\n\n          // Each time the array changes value, capture a clone so that on the next\n          // change it's possible to produce a diff\n      var previousContents = [].concat(target.peek() === undefined ? [] : target.peek());\n      cachedDiff = null;\n      arrayChangeSubscription = target.subscribe(function (currentContents) {\n        let changes;\n              // Make a copy of the current contents and ensure it's an array\n        currentContents = [].concat(currentContents || []);\n\n              // Compute the diff and issue notifications, but only if someone is listening\n        if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n          changes = getChanges(previousContents, currentContents);\n        }\n\n              // Eliminate references to the old, removed items, so they can be GCed\n        previousContents = currentContents;\n        cachedDiff = null;\n        pendingNotifications = 0;\n\n        if (changes && changes.length) {\n          target.notifySubscribers(changes, arrayChangeEventName);\n        }\n      });\n    }\n\n    function getChanges (previousContents, currentContents) {\n          // We try to re-use cached diffs.\n          // The scenarios where pendingNotifications > 1 are when using rate-limiting or the Deferred Updates\n          // plugin, which without this check would not be compatible with arrayChange notifications. Normally,\n          // notifications are issued immediately so we wouldn't be queueing up more than one.\n      if (!cachedDiff || pendingNotifications > 1) {\n        cachedDiff = trackArrayChanges.compareArrays(previousContents, currentContents, target.compareArrayOptions);\n      }\n\n      return cachedDiff\n    }\n\n    target.cacheDiffForKnownOperation = function (rawArray, operationName, args) {\n        // Only run if we're currently tracking changes for this observable array\n        // and there aren't any pending deferred notifications.\n      if (!trackingChanges || pendingNotifications) {\n        return\n      }\n      var diff = [],\n        arrayLength = rawArray.length,\n        argsLength = args.length,\n        offset = 0;\n\n      function pushDiff (status, value, index) {\n        return diff[diff.length] = { 'status': status, 'value': value, 'index': index }\n      }\n      switch (operationName) {\n        case 'push':\n          offset = arrayLength;\n        case 'unshift':\n          for (let index = 0; index < argsLength; index++) {\n            pushDiff('added', args[index], offset + index);\n          }\n          break\n\n        case 'pop':\n          offset = arrayLength - 1;\n        case 'shift':\n          if (arrayLength) {\n            pushDiff('deleted', rawArray[offset], offset);\n          }\n          break\n\n        case 'splice':\n              // Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].\n              // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n          var startIndex = Math.min(Math.max(0, args[0] < 0 ? arrayLength + args[0] : args[0]), arrayLength),\n            endDeleteIndex = argsLength === 1 ? arrayLength : Math.min(startIndex + (args[1] || 0), arrayLength),\n            endAddIndex = startIndex + argsLength - 2,\n            endIndex = Math.max(endDeleteIndex, endAddIndex),\n            additions = [], deletions = [];\n          for (let index = startIndex, argsIndex = 2; index < endIndex; ++index, ++argsIndex) {\n            if (index < endDeleteIndex) { deletions.push(pushDiff('deleted', rawArray[index], index)); }\n            if (index < endAddIndex) { additions.push(pushDiff('added', args[argsIndex], index)); }\n          }\n          findMovesInArrayComparison(deletions, additions);\n          break\n\n        default:\n          return\n      }\n      cachedDiff = diff;\n    };\n  }\n\n  // Expose compareArrays for testing.\n  trackArrayChanges.compareArrays = compareArrays;\n\n  // Add the trackArrayChanges extender so we can use\n  // obs.extend({ trackArrayChanges: true })\n  extenders.trackArrayChanges = trackArrayChanges;\n\n  //\n\n  function observableArray (initialValues) {\n    initialValues = initialValues || [];\n\n    if (typeof initialValues !== 'object' || !('length' in initialValues)) { throw new Error('The argument passed when initializing an observable array must be an array, or null, or undefined.') }\n\n    var result = observable(initialValues);\n    Object.setPrototypeOf(result, observableArray.fn);\n    trackArrayChanges(result);\n          // ^== result.extend({ trackArrayChanges: true })\n    overwriteLengthPropertyIfSupported(result, { get: () => result().length });\n    return result\n  }\n\n  function isObservableArray (instance) {\n    return isObservable(instance) && typeof instance.remove === 'function' && typeof instance.push === 'function'\n  }\n\n  observableArray.fn = {\n    remove (valueOrPredicate) {\n      var underlyingArray = this.peek();\n      var removedValues = [];\n      var predicate = typeof valueOrPredicate === 'function' && !isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate };\n      for (var i = 0; i < underlyingArray.length; i++) {\n        var value = underlyingArray[i];\n        if (predicate(value)) {\n          if (removedValues.length === 0) {\n            this.valueWillMutate();\n          }\n          if (underlyingArray[i] !== value) {\n            throw Error(\"Array modified during remove; cannot remove item\")\n          }\n          removedValues.push(value);\n          underlyingArray.splice(i, 1);\n          i--;\n        }\n      }\n      if (removedValues.length) {\n        this.valueHasMutated();\n      }\n      return removedValues\n    },\n\n    removeAll (arrayOfValues) {\n          // If you passed zero args, we remove everything\n      if (arrayOfValues === undefined) {\n        var underlyingArray = this.peek();\n        var allValues = underlyingArray.slice(0);\n        this.valueWillMutate();\n        underlyingArray.splice(0, underlyingArray.length);\n        this.valueHasMutated();\n        return allValues\n      }\n          // If you passed an arg, we interpret it as an array of entries to remove\n      if (!arrayOfValues) {\n        return []\n      }\n      return this['remove'](function (value) {\n        return arrayIndexOf(arrayOfValues, value) >= 0\n      })\n    },\n\n    destroy (valueOrPredicate) {\n      var underlyingArray = this.peek();\n      var predicate = typeof valueOrPredicate === 'function' && !isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate };\n      this.valueWillMutate();\n      for (var i = underlyingArray.length - 1; i >= 0; i--) {\n        var value = underlyingArray[i];\n        if (predicate(value)) {\n          value['_destroy'] = true;\n        }\n      }\n      this.valueHasMutated();\n    },\n\n    destroyAll (arrayOfValues) {\n          // If you passed zero args, we destroy everything\n      if (arrayOfValues === undefined) { return this.destroy(function () { return true }) }\n\n          // If you passed an arg, we interpret it as an array of entries to destroy\n      if (!arrayOfValues) {\n        return []\n      }\n      return this.destroy(function (value) {\n        return arrayIndexOf(arrayOfValues, value) >= 0\n      })\n    },\n\n    indexOf (item) {\n      return arrayIndexOf(this(), item)\n    },\n\n    replace (oldItem, newItem) {\n      var index = this.indexOf(oldItem);\n      if (index >= 0) {\n        this.valueWillMutate();\n        this.peek()[index] = newItem;\n        this.valueHasMutated();\n      }\n    },\n\n    sorted (compareFn) {\n      return [...this()].sort(compareFn)\n    },\n\n    reversed () {\n      return [...this()].reverse()\n    },\n\n    [Symbol.iterator]: function * () {\n      yield * this();\n    }\n  };\n\n  Object.setPrototypeOf(observableArray.fn, observable.fn);\n\n  // Populate ko.observableArray.fn with read/write functions from native arrays\n  // Important: Do not add any additional functions here that may reasonably be used to *read* data from the array\n  // because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale\n  arrayForEach(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {\n    observableArray.fn[methodName] = function () {\n          // Use \"peek\" to avoid creating a subscription in any computed that we're executing in the context of\n          // (for consistency with mutating regular observables)\n      var underlyingArray = this.peek();\n      this.valueWillMutate();\n      this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);\n      var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);\n      this.valueHasMutated();\n          // The native sort and reverse methods return a reference to the array, but it makes more sense to return the observable array instead.\n      return methodCallResult === underlyingArray ? this : methodCallResult\n    };\n  });\n\n  // Populate ko.observableArray.fn with read-only functions from native arrays\n  arrayForEach(['slice'], function (methodName) {\n    observableArray.fn[methodName] = function () {\n      var underlyingArray = this();\n      return underlyingArray[methodName].apply(underlyingArray, arguments)\n    };\n  });\n\n  // Expose for testing.\n  observableArray.trackArrayChanges = trackArrayChanges;\n\n  //\n\n  var maxNestedObservableDepth = 10; // Escape the (unlikely) pathological case where an observable's current value is itself (or similar reference cycle)\n\n  function toJS (rootObject) {\n    if (arguments.length == 0) { throw new Error('When calling ko.toJS, pass the object you want to convert.') }\n\n      // We just unwrap everything at every level in the object graph\n    return mapJsObjectGraph(rootObject, function (valueToMap) {\n          // Loop because an observable's value might in turn be another observable wrapper\n      for (var i = 0; isObservable(valueToMap) && (i < maxNestedObservableDepth); i++) { valueToMap = valueToMap(); }\n      return valueToMap\n    })\n  }\n\n  function toJSON (rootObject, replacer, space) {     // replacer and space are optional\n    var plainJavaScriptObject = toJS(rootObject);\n    return JSON.stringify(plainJavaScriptObject, replacer, space)\n  }\n\n  function mapJsObjectGraph (rootObject, mapInputCallback, visitedObjects) {\n    visitedObjects = visitedObjects || new objectLookup();\n\n    rootObject = mapInputCallback(rootObject);\n    var canHaveProperties = (typeof rootObject === 'object') && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof RegExp)) && (!(rootObject instanceof Date)) && (!(rootObject instanceof String)) && (!(rootObject instanceof Number)) && (!(rootObject instanceof Boolean));\n    if (!canHaveProperties) { return rootObject }\n\n    var outputProperties = rootObject instanceof Array ? [] : {};\n    visitedObjects.save(rootObject, outputProperties);\n\n    visitPropertiesOrArrayEntries(rootObject, function (indexer) {\n      var propertyValue = mapInputCallback(rootObject[indexer]);\n\n      switch (typeof propertyValue) {\n        case 'boolean':\n        case 'number':\n        case 'string':\n        case 'function':\n          outputProperties[indexer] = propertyValue;\n          break\n        case 'object':\n        case 'undefined':\n          var previouslyMappedValue = visitedObjects.get(propertyValue);\n          outputProperties[indexer] = (previouslyMappedValue !== undefined)\n                  ? previouslyMappedValue\n                  : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);\n          break\n      }\n    });\n\n    return outputProperties\n  }\n\n  function visitPropertiesOrArrayEntries (rootObject, visitorCallback) {\n    if (rootObject instanceof Array) {\n      for (var i = 0; i < rootObject.length; i++) { visitorCallback(i); }\n\n          // For arrays, also respect toJSON property for custom mappings (fixes #278)\n      if (typeof rootObject['toJSON'] === 'function') { visitorCallback('toJSON'); }\n    } else {\n      for (var propertyName in rootObject) {\n        visitorCallback(propertyName);\n      }\n    }\n  }\n\n  function objectLookup () {\n    this.keys = [];\n    this.values = [];\n  }\n\n  objectLookup.prototype = {\n    constructor: objectLookup,\n    save: function (key, value) {\n      var existingIndex = arrayIndexOf(this.keys, key);\n      if (existingIndex >= 0) { this.values[existingIndex] = value; } else {\n        this.keys.push(key);\n        this.values.push(value);\n      }\n    },\n    get: function (key) {\n      var existingIndex = arrayIndexOf(this.keys, key);\n      return (existingIndex >= 0) ? this.values[existingIndex] : undefined\n    }\n  };\n\n  //\n\n  function LAMBDA () {}\n\n  /**\n   * @ operator - recursively call the identifier if it's a function\n   * @param  {operand} a ignored\n   * @param  {operand} b The variable to be called (if a function) and unwrapped\n   * @return {value}   The result.\n   */\n  function unwrapOrCall (a, b) {\n    while (typeof b === 'function') { b = b(); }\n    return b\n  }\n\n  const operators = {\n    // unary\n    '@': unwrapOrCall,\n    '#': (a, b) => () => unwrap(b), // Convert to read-only.\n    '=>': LAMBDA,\n    '!': function not (a, b) { return !b },\n    '!!': function notnot (a, b) { return !!b },\n    '++': function preinc (a, b) { return ++b },\n    '--': function preinc (a, b) { return --b },\n    // mul/div\n    '*': function mul (a, b) { return a * b },\n    '/': function div (a, b) { return a / b },\n    '%': function mod (a, b) { return a % b },\n    // sub/add\n    '+': function add (a, b) { return a + b },\n    '-': function sub (a, b) { return (a || 0) - (b || 0) },\n    '&-': function neg (a, b) { return -1 * b },\n    // relational\n    '<': function lt (a, b) { return a < b },\n    '<=': function le (a, b) { return a <= b },\n    '>': function gt (a, b) { return a > b },\n    '>=': function ge (a, b) { return a >= b },\n    //    TODO: 'in': function (a, b) { return a in b; },\n    //    TODO: 'instanceof': function (a, b) { return a instanceof b; },\n    // equality\n    '==': function equal (a, b) { return a === b },\n    '!=': function ne (a, b) { return a !== b },\n    '===': function sequal (a, b) { return a === b },\n    '!==': function sne (a, b) { return a !== b },\n    // bitwise\n    '&': function bitAnd (a, b) { return a & b },\n    '^': function xor (a, b) { return a ^ b },\n    '|': function bitOr (a, b) { return a | b },\n    // logic\n    '&&': function logicAnd (a, b) { return a && b },\n    '||': function logicOr (a, b) { return a || b },\n    // Access\n    '.': function member (a, b) { return a[b] },\n    '[': function member (a, b) { return a[b] },\n    // conditional/ternary\n    // '?': ternary See Node.js\n    // Function-Call\n    'call': function callOp (a, b) { return a.apply(null, b) }\n  };\n\n  /* Order of precedence from:\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table\n  */\n\n    // Our operator - unwrap/call\n  operators['@'].precedence = 21;\n  operators['#'].precedence = 21;\n\n    // lambda\n  operators['=>'].precedence = 20;\n\n    // Member\n  operators['.'].precedence = 19;\n  operators['['].precedence = 19;\n\n    // Logical not\n  operators['!'].precedence = 16;\n  operators['!!'].precedence = 16; // explicit double-negative\n\n    // Prefix inc/dec\n  operators['++'].precedence = 16;\n  operators['--'].precedence = 16;\n  operators['&-'].precedence = 16;\n\n    // mul/div/remainder\n  operators['%'].precedence = 14;\n  operators['*'].precedence = 14;\n  operators['/'].precedence = 14;\n\n    // add/sub\n  operators['+'].precedence = 13;\n  operators['-'].precedence = 13;\n\n    // bitwise\n  operators['|'].precedence = 12;\n  operators['^'].precedence = 11;\n  operators['&'].precedence = 10;\n\n    // comparison\n  operators['<'].precedence = 11;\n  operators['<='].precedence = 11;\n  operators['>'].precedence = 11;\n  operators['>='].precedence = 11;\n\n    // operators['in'].precedence = 8;\n    // operators['instanceof'].precedence = 8;\n    // equality\n  operators['=='].precedence = 10;\n  operators['!='].precedence = 10;\n  operators['==='].precedence = 10;\n  operators['!=='].precedence = 10;\n\n    // logic\n  operators['&&'].precedence = 6;\n  operators['||'].precedence = 5;\n\n  operators['&&'].earlyOut = (a) => !a;\n  operators['||'].earlyOut = (a) => a;\n\n    // Call a function\n  operators['call'].precedence = 1;\n\n  const IS_EXPR_OR_IDENT = Symbol('Node - Is Expression Or Identifier');\n\n  class Node$1 {\n    constructor (lhs, op, rhs) {\n      this.lhs = lhs;\n      this.op = op;\n      this.rhs = rhs;\n    }\n\n    static get operators () { return operators }\n\n    get_leaf_value (leaf, context, globals, node) {\n      if (typeof leaf === 'function') {\n        // Expressions on observables are nonsensical, so we unwrap any\n        // function values (e.g. identifiers).\n        return unwrap(leaf())\n      }\n\n      // primitives\n      if (typeof leaf !== 'object' || leaf === null) { return leaf }\n\n      // Identifiers and Expressions\n      if (leaf[Node$1.isExpressionOrIdentifierSymbol]) {\n        // lhs is passed in as the parent of the leaf. It will be defined in\n        // cases like a.b.c as 'a' for 'b' then as 'b' for 'c'.\n        return unwrap(leaf.get_value(undefined, context, globals, node))\n      }\n\n      // Plain object/class.\n      return leaf\n    }\n\n    /**\n     * Return a function that calculates and returns an expression's value\n     * when called.\n     * @param  {array} ops  The operations to perform\n     * @return {function}   The function that calculates the expression.\n     *\n     * Note that for a lambda, we do not evaluate the RHS expression until\n     * the lambda is called.\n     */\n    get_value (notused, context, globals, node) {\n      var node = this;\n\n      if (node.op === LAMBDA) {\n        return () => node.get_leaf_value(node.rhs, context, globals, node)\n      }\n\n      const lhv = node.get_leaf_value(node.lhs, context, globals, node);\n      const earlyOut = node.op.earlyOut;\n\n      if (earlyOut && earlyOut(lhv)) { return lhv }\n      const rhv = node.get_leaf_value(node.rhs, context, globals, node);\n\n      return node.op(lhv, rhv, context, globals)\n    }\n\n    //\n    // Class variables.\n    //\n    static get isExpressionOrIdentifierSymbol () { return IS_EXPR_OR_IDENT }\n    get [IS_EXPR_OR_IDENT] () { return true }\n\n    static value_of (item, context, globals, node) {\n      if (item && item[Node$1.isExpressionOrIdentifierSymbol]) {\n        return item.get_value(item, context, globals, node)\n      }\n      return item\n    }\n\n    /**\n    *  Convert an array of nodes to an executable tree.\n    *  @return {object} An object with a `lhs`, `rhs` and `op` key, corresponding\n    *                      to the left hand side, right hand side, and\n    *                      operation function.\n    */\n    static create_root (nodes) {\n      var root, leaf, op, value;\n\n      // Prime the leaf = root node.\n      leaf = root = new Node$1(nodes.shift(), nodes.shift(), nodes.shift());\n\n      while (true) {\n        op = nodes.shift();\n        value = nodes.shift();\n        if (!op) {\n          break\n        }\n        if (op.precedence < root.op.precedence) {\n          // rebase\n          root = new Node$1(root, op, value);\n          leaf = root;\n        } else {\n          leaf.rhs = new Node$1(leaf.rhs, op, value);\n          leaf = leaf.rhs;\n        }\n      }\n      // console.log('tree', root)\n      return root\n    }\n  }\n\n  /**\n   * Because of cyclical dependencies on operators <-> Node <-> value_of,\n   * we need to patch this in here.\n   */\n  operators['?'] = function ternary (a, b, context, globals, node) {\n    return Node$1.value_of(a ? b.yes : b.no, context, globals, node)\n  };\n  operators['?'].precedence = 4;\n\n  class Expression {\n    constructor (nodes) {\n      this.nodes = nodes;\n      this.root = Node$1.create_root(nodes);\n    }\n\n    /**\n     * Return the value of `this` Expression instance.\n     */\n    get_value (parent, context, globals, node) {\n      if (!this.root) {\n        this.root = Node$1.create_root(this.nodes);\n      }\n      return this.root.get_value(parent, context, globals, node)\n    }\n  }\n\n  Expression.prototype[Node$1.isExpressionOrIdentifierSymbol] = true;\n\n  class Arguments {\n    constructor (parser, args) {\n      this.parser = parser;\n      this.args = args;\n    }\n\n    get_value (parent, context, globals, node) {\n      var deReffedArgs = [];\n      for (var i = 0, j = this.args.length; i < j; ++i) {\n        deReffedArgs.push(Node$1.value_of(this.args[i], context, globals, node));\n      }\n      return deReffedArgs\n    };\n\n    get [Node$1.isExpressionOrIdentifierSymbol] () { return true }\n  }\n\n  /**\n   * The following regular expressions were generated by\n   *  https://mathiasbynens.be/demo/javascript-identifier-regex\n   */\n  var IDStart = /[\\$A-Z_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/;\n\n  var IDContinue = /[\\$0-9A-Z_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/;\n\n  class Identifier {\n    constructor (parser, token, dereferences) {\n      this.token = token;\n      this.dereferences = dereferences;\n      this.parser = parser;\n    }\n\n    /**\n     * Apply all () and [] functions on the identifier to the lhs value e.g.\n     * a()[3] has deref functions that are essentially this:\n     *     [_deref_call, _deref_this where this=3]\n     *\n     * @param  {mixed} value  Should be an object.\n     * @return {mixed}        The dereferenced value.\n     *\n     * [1] We want to bind any function that is a method of an object, but not\n     *     corrupt any values (e.g. computed()s).   e.g. Running x.bind(obj) where\n     *     we're given `data-bind='binding: obj.x'` and x is a computed will\n     *     break the computed's `this` and it will stop working as expected.\n     *\n     *     The test `!last_value.hasOwnProperty(member)`\n     *     distinguishes between functions on the prototype chain (prototypal\n     *     members) and value-members added directly to the object.  This may\n     *     not be the canonical test for this relationship, but it succeeds\n     *     in the known test cases.\n     *\n     *     See: `this` tests of our dereference function.\n     */\n    dereference (value, $context, globals, node) {\n      let member;\n      let refs = this.dereferences || [];\n      const $data = $context.$data || {};\n      let lastValue;  // becomes `this` in function calls to object properties.\n      let i, n;\n\n      for (i = 0, n = refs.length; i < n; ++i) {\n        member = Node$1.value_of(refs[i], $context, globals, node);\n\n        if (typeof value === 'function' && refs[i] instanceof Arguments) {\n          // fn(args)\n          value = value.apply(lastValue || $data, member);\n          lastValue = value;\n        } else {\n          // obj[x] or obj.x dereference.  Note that obj may be a function.\n          lastValue = value;\n          value = Node$1.value_of(value[member], $context, globals, node);\n        }\n      }\n\n      // [1] See note above.\n      if (typeof value === 'function' && n > 0 && lastValue !== value &&\n          !hasOwnProperty(lastValue, member)) {\n        return value.bind(lastValue)\n      }\n\n      return value\n    };\n\n    /**\n     * Return the value as one would get it from the top-level i.e.\n     * $data.token/$context.token/globals.token; this does not return intermediate\n     * values on a chain of members i.e. $data.hello.there -- requesting the\n     * Identifier('there').value will return $data/$context/globals.there.\n     *\n     * This will dereference using () or [arg] member.\n     * @param  {object | Identifier | Expression} parent\n     * @return {mixed}  Return the primitive or an accessor.\n     */\n    get_value (parent, context, globals, node) {\n      const intermediate = parent && !(parent instanceof Identifier)\n        ? Node$1.value_of(parent, context, globals, node)[this.token]\n        : context.lookup(this.token, globals, node);\n      return this.dereference(intermediate, context, globals, node)\n    }\n\n    assign (object, property, value) {\n      if (isWriteableObservable(object[property])) {\n        object[property](value);\n      } else if (!isObservable(object[property])) {\n        object[property] = value;\n      }\n    };\n\n    /**\n     * Set the value of the Identifier.\n     *\n     * @param {Mixed} new_value The value that Identifier is to be set to.\n     */\n    set_value (new_value, $context, globals) {\n      const $data = $context.$data || {};\n      const refs = this.dereferences || [];\n      let leaf = this.token;\n      let i, n, root;\n\n      if (hasOwnProperty($data, leaf)) {\n        root = $data;\n      } else if (hasOwnProperty($context, leaf)) {\n        root = $context;\n      } else if (hasOwnProperty(globals, leaf)) {\n        root = globals;\n      } else {\n        throw new Error('Identifier::set_value -- ' +\n          \"The property '\" + leaf + \"' does not exist \" +\n          'on the $data, $context, or globals.')\n      }\n\n      // Degenerate case. {$data|$context|global}[leaf] = something;\n      n = refs.length;\n      if (n === 0) {\n        this.assign(root, leaf, new_value);\n        return\n      }\n\n      // First dereference is {$data|$context|global}[token].\n      root = root[leaf];\n\n      // We cannot use this.dereference because that gives the leaf; to evoke\n      // the ES5 setter we have to call `obj[leaf] = new_value`\n      for (i = 0; i < n - 1; ++i) {\n        leaf = refs[i];\n        if (leaf instanceof Arguments) {\n          root = root();\n        } else {\n          root = root[Node$1.value_of(leaf)];\n        }\n      }\n\n      // We indicate that a dereference is a function when it is `true`.\n      if (refs[i] === true) {\n        throw new Error('Cannot assign a value to a function.')\n      }\n\n      // Call the setter for the leaf.\n      if (refs[i]) {\n        this.assign(root, Node$1.value_of(refs[i]), new_value);\n      }\n    };\n\n    /**\n     * Determine if a character is a valid item in an identifier.\n     * Note that we do not check whether the first item is a number, nor do we\n     * support unicode identifiers here.\n     *\n     * From:  http://stackoverflow.com/a/9337047\n     * @param  {String}  ch  The character\n     * @return {Boolean}     True if this is a valid identifier\n     */\n    // function is_identifier_char(ch) {\n    //   return (ch >= 'A' && ch <= 'Z') ||\n    //          (ch >= 'a' && ch <= 'z') ||\n    //          (ch >= '0' && ch <= 9) ||\n    //           ch === '_' || ch === '$';\n    // }\n    static is_valid_start_char (ch) {\n      return IDStart.test(ch)\n    }\n\n    static is_valid_continue_char (ch) {\n      return IDContinue.test(ch)\n    }\n\n    get [Node$1.isExpressionOrIdentifierSymbol] () { return true }\n  }\n\n  class Ternary {\n    constructor (yes, no) {\n      Object.assign(this, {yes, no});\n    }\n\n    get_value () { return this }\n\n    get [Node$1.isExpressionOrIdentifierSymbol] () { return true }\n  }\n\n  /**\n   * Originally based on (public domain):\n   * https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n   */\n\n  const escapee = {\n    \"'\": \"'\",\n    '\"': '\"',\n    '`': '`',\n    '\\\\': '\\\\',\n    '/': '/',\n    '$': '$',\n    b: '\\b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t'\n  };\n\n  /**\n   * Construct a new Parser instance with new Parser(node, context)\n   * @param {Node} node    The DOM element from which we parsed the\n   *                         content.\n   * @param {object} context The Knockout context.\n   * @param {object} globals An object containing any desired globals.\n   */\n  class Parser {\n    white () {\n      var ch = this.ch;\n      while (ch && ch <= ' ') {\n        ch = this.next();\n      }\n      return this.comment(ch)\n    }\n\n  /**\n   * Slurp any C or C++ style comments\n   */\n    comment (ch) {\n      if (ch !== '/') { return ch }\n      var p = this.at;\n      var second = this.lookahead();\n      if (second === '/') {\n        while (ch) {\n          ch = this.next();\n          if (ch === '\\n' || ch === '\\r') { break }\n        }\n        ch = this.next();\n      } else if (second === '*') {\n        while (ch) {\n          ch = this.next();\n          if (ch === '*' && this.lookahead() === '/') {\n            this.next();\n            break\n          }\n        }\n        if (!ch) {\n          this.error('Unclosed comment, starting at character ' + p);\n        }\n        this.next();\n        return this.white()\n      }\n      return ch\n    };\n\n    next (c) {\n      if (c && c !== this.ch) {\n        this.error(\"Expected '\" + c + \"' but got '\" + this.ch + \"'\");\n      }\n      this.ch = this.text.charAt(this.at);\n      this.at += 1;\n      return this.ch\n    }\n\n    lookahead () {\n      return this.text[this.at]\n    }\n\n    error (m) {\n      if (m instanceof Error) { throw m }\n      let [name, msg] = m.name ? [m.name, m.message] : [m, ''];\n      const message = `\\n${name} ${msg} of\n    ${this.text}\\n` + Array(this.at).join(' ') + '_/ ðŸ”¥ \\\\_\\n';\n      throw new Error(message)\n    }\n\n    name () {\n    // A name of a binding\n      var name = '';\n      var enclosedBy;\n      this.white();\n\n      var ch = this.ch;\n\n      if (ch === \"'\" || ch === '\"') {\n        enclosedBy = ch;\n        ch = this.next();\n      }\n\n      while (ch) {\n        if (enclosedBy && ch === enclosedBy) {\n          this.white();\n          ch = this.next();\n          if (ch !== ':' && ch !== ',') {\n            this.error(\n            'Object name: ' + name + ' missing closing ' + enclosedBy\n          );\n          }\n          return name\n        } else if (ch === ':' || ch <= ' ' || ch === ',' || ch === '|') {\n          return name\n        }\n        name += ch;\n        ch = this.next();\n      }\n\n      return name\n    }\n\n    number () {\n      let number;\n      let string = '';\n      let ch = this.ch;\n\n      if (ch === '-') {\n        string = '-';\n        ch = this.next('-');\n      }\n      while (ch >= '0' && ch <= '9') {\n        string += ch;\n        ch = this.next();\n      }\n      if (ch === '.') {\n        string += '.';\n        ch = this.next();\n        while (ch && ch >= '0' && ch <= '9') {\n          string += ch;\n          ch = this.next();\n        }\n      }\n      if (ch === 'e' || ch === 'E') {\n        string += ch;\n        ch = this.next();\n        if (ch === '-' || ch === '+') {\n          string += ch;\n          ch = this.next();\n        }\n        while (ch >= '0' && ch <= '9') {\n          string += ch;\n          ch = this.next();\n        }\n      }\n      number = +string;\n      if (!isFinite(number)) {\n        options.onError(new Error('Bad number: ' + number + ' in ' + string));\n      } else {\n        return number\n      }\n    }\n\n  /**\n   * Add a property to 'object' that equals the given value.\n   * @param  {Object} object The object to add the value to.\n   * @param  {String} key    object[key] is set to the given value.\n   * @param  {mixed}  value  The value, may be a primitive or a function. If a\n   *                         function it is unwrapped as a property.\n   */\n    objectAddValue (object, key, value) {\n      if (value && value[Node$1.isExpressionOrIdentifierSymbol]) {\n        Object.defineProperty(object, key, {\n          get: () => Node$1.value_of(value, ...this.currentContextGlobals),\n          enumerable: true\n        });\n      } else if (Array.isArray(value)) {\n        Object.defineProperty(object, key, {\n          get: () => value.map(v => Node$1.value_of(v, ...this.currentContextGlobals)),\n          enumerable: true\n        });\n      } else {\n      // primitives\n        object[key] = value;\n      }\n    }\n\n    object () {\n      let key;\n      let object = {};\n      let ch = this.ch;\n\n      if (ch === '{') {\n        this.next('{');\n        ch = this.white();\n        if (ch === '}') {\n          ch = this.next('}');\n          return object\n        }\n        while (ch) {\n          if (ch === '\"' || ch === \"'\" || ch === '`') {\n            key = this.string();\n          } else {\n            key = this.name();\n          }\n          if (hasOwnProperty(object, key)) {\n            this.error('Duplicate key \"' + key + '\"');\n          }\n          if (this.white() === ':') {\n            ch = this.next(':');\n            this.objectAddValue(object, key, this.expression());\n          } else {\n            const objectKeyIsValue = new Identifier(this, key, []);\n            this.objectAddValue(object, key, objectKeyIsValue);\n          }\n\n          ch = this.white();\n          if (ch === '}') {\n            ch = this.next('}');\n            return object\n          }\n\n          this.next(',');\n          ch = this.white();\n          if (ch === '}') {\n            ch = this.next('}');\n            return object\n          }\n        }\n      }\n      this.error('Bad object');\n    }\n\n  /**\n   * Read up to delim and return the string\n   * @param  {string} delim The delimiter, either ' or \"\n   * @return {string}       The string read.\n   */\n    readString (delim) {\n      let string = '';\n      let nodes = [''];\n      let plusOp = operators['+'];\n      let hex;\n      let i;\n      let uffff;\n      let interpolate = delim === '`';\n      let ch = this.next();\n\n      while (ch) {\n        if (ch === delim) {\n          ch = this.next();\n          if (interpolate) { nodes.push(plusOp); }\n          nodes.push(string);\n          return nodes\n        }\n        if (ch === '\\\\') {\n          ch = this.next();\n          if (ch === 'u') {\n            uffff = 0;\n            for (i = 0; i < 4; i += 1) {\n              hex = parseInt(ch = this.next(), 16);\n              if (!isFinite(hex)) {\n                break\n              }\n              uffff = uffff * 16 + hex;\n            }\n            string += String.fromCharCode(uffff);\n          } else if (typeof escapee[ch] === 'string') {\n            string += escapee[ch];\n          } else {\n            break\n          }\n        } else if (interpolate && ch === '$') {\n          ch = this.next();\n          if (ch === '{') {\n            this.next('{');\n            nodes.push(plusOp);\n            nodes.push(string);\n            nodes.push(plusOp);\n            nodes.push(this.expression());\n            string = '';\n          // this.next('}');\n          } else {\n            string += '$' + ch;\n          }\n        } else {\n          string += ch;\n        }\n        ch = this.next();\n      }\n\n      this.error('Bad string');\n    }\n\n    string () {\n      var ch = this.ch;\n      if (ch === '\"') {\n        return this.readString('\"').join('')\n      } else if (ch === \"'\") {\n        return this.readString(\"'\").join('')\n      } else if (ch === '`') {\n        return Node$1.create_root(this.readString('`'))\n      }\n\n      this.error('Bad string');\n    }\n\n    array () {\n      let array = [];\n      let ch = this.ch;\n\n      if (ch === '[') {\n        ch = this.next('[');\n        this.white();\n        if (ch === ']') {\n          ch = this.next(']');\n          return array\n        }\n        while (ch) {\n          array.push(this.expression());\n          ch = this.white();\n          if (ch === ']') {\n            ch = this.next(']');\n            return array\n          }\n          this.next(',');\n          ch = this.white();\n        }\n      }\n      this.error('Bad array');\n    }\n\n    value () {\n      var ch;\n      this.white();\n      ch = this.ch;\n      switch (ch) {\n        case '{': return this.object()\n        case '[': return this.array()\n        case '\"': case \"'\": case '`': return this.string()\n        case '-': return this.number()\n        default:\n          return ch >= '0' && ch <= '9' ? this.number() : this.identifier()\n      }\n    }\n\n  /**\n   * Get the function for the given operator.\n   * A `.precedence` value is added to the function, with increasing\n   * precedence having a higher number.\n   * @return {function} The function that performs the infix operation\n   */\n    operator (opts) {\n      let op = '';\n      let opFn;\n      let ch = this.white();\n      let isIdentifierChar = Identifier.is_valid_start_char;\n\n      while (ch) {\n        if (isIdentifierChar(ch) || ch <= ' ' || ch === '' ||\n          ch === '\"' || ch === \"'\" || ch === '{' || ch === '(' ||\n          ch === '`' || ch === ')' || (ch <= '9' && ch >= '0')) {\n          break\n        }\n\n        if (!opts.not_an_array && ch === '[') {\n          break\n        }\n\n        op += ch;\n        ch = this.next();\n\n      // An infix followed by the prefix e.g. a + @b\n      // TODO: other prefix unary operators\n        if (ch === '@') {\n          break\n        }\n\n        isIdentifierChar = Identifier.is_valid_continue_char;\n      }\n\n      if (op !== '') {\n        if (opts.prefix && op === '-') { op = '&-'; }\n        opFn = operators[op];\n\n        if (!opFn) {\n          this.error(\"Bad operator: '\" + op + \"'.\");\n        }\n      }\n\n      return opFn\n    }\n\n  /**\n   * Filters\n   * Returns what the Node interprets as an \"operator\".\n   * e.g.\n   *   <span data-bind=\"text: name | fit:20 | uppercase\"></span>\n   */\n    filter () {\n      let ch = this.next();\n      let args = [];\n      let nextFilter = function (v) { return v };\n      let name = this.name();\n\n      if (!options.filters[name]) {\n        options.onError('Cannot find filter by the name of: ' + name);\n      }\n\n      ch = this.white();\n\n      while (ch) {\n        if (ch === ':') {\n          ch = this.next();\n          args.push(this.expression('|'));\n        }\n\n        if (ch === '|') {\n          nextFilter = this.filter();\n          break\n        }\n\n        if (ch === ',') { break }\n\n        ch = this.white();\n      }\n\n      var filter = function filter (value, ignored, context, globals, node) {\n        var argValues = [value];\n\n        for (var i = 0, j = args.length; i < j; ++i) {\n          argValues.push(Node$1.value_of(args[i], context, globals, node));\n        }\n\n        return nextFilter(options.filters[name].apply(null, argValues))\n      };\n\n    // Lowest precedence.\n      filter.precedence = 1;\n      return filter\n    }\n\n  /**\n   * Parse an expression â€“ builds an operator tree, in something like\n   * Shunting-Yard.\n   *   See: http://en.wikipedia.org/wiki/Shunting-yard_algorithm\n   *\n   * @return {function}   A function that computes the value of the expression\n   *                      when called or a primitive.\n   */\n    expression (filterable) {\n      let op;\n      let nodes = [];\n      let ch = this.white();\n\n      while (ch) {\n      // unary prefix operators\n        op = this.operator({ prefix: true });\n        if (op) {\n          nodes.push(undefined);  // LHS Tree node.\n          nodes.push(op);\n          ch = this.white();\n        }\n\n        if (ch === '(') {\n          this.next();\n          nodes.push(this.expression());\n          this.next(')');\n        } else {\n          nodes.push(this.value());\n        }\n        ch = this.white();\n\n        if (ch === ':' || ch === '}' || ch === ',' || ch === ']' ||\n          ch === ')' || ch === '' || ch === '`' || (ch === '|' && filterable === '|')) {\n          break\n        }\n\n      // filters\n        if (ch === '|' && this.lookahead() !== '|' && filterable) {\n          nodes.push(this.filter());\n          nodes.push(undefined);\n          break\n        }\n\n      // infix or postfix operators\n        op = this.operator({ not_an_array: true });\n\n        if (op === operators['?']) {\n          this.ternary(nodes);\n          break\n        } else if (op === operators['.']) {\n          nodes.push(op);\n          nodes.push(this.member());\n          op = null;\n        } else if (op === operators['[']) {\n          nodes.push(op);\n          nodes.push(this.expression());\n          ch = this.next(']');\n          op = null;\n        } else if (op) {\n          nodes.push(op);\n        }\n\n        ch = this.white();\n\n        if (ch === ']' || (!op && ch === '(')) { break }\n      }\n\n      if (nodes.length === 0) {\n        return undefined\n      }\n\n      var dereferences = this.dereferences();\n\n      if (nodes.length === 1 && !dereferences.length) {\n        return nodes[0]\n      }\n\n      for (var i = 0, j = dereferences.length; i < j; ++i) {\n        var deref = dereferences[i];\n        if (deref.constructor === Arguments) {\n          nodes.push(operators.call);\n        } else {\n          nodes.push(operators['.']);\n        }\n        nodes.push(deref);\n      }\n\n      return new Expression(nodes)\n    }\n\n    ternary (nodes) {\n      var ternary = new Ternary();\n      ternary.yes = this.expression();\n      this.next(':');\n      ternary.no = this.expression();\n      nodes.push(operators['?']);\n      nodes.push(ternary);\n    }\n\n  /**\n   * Parse the arguments to a function, returning an Array.\n   *\n   */\n    funcArguments () {\n      let args = [];\n      let ch = this.next('(');\n\n      while (ch) {\n        ch = this.white();\n        if (ch === ')') {\n          this.next(')');\n          return new Arguments(this, args)\n        } else {\n          args.push(this.expression());\n          ch = this.white();\n        }\n        if (ch !== ')') { this.next(','); }\n      }\n\n      this.error('Bad arguments to function');\n    }\n\n  /**\n   * The literal string reference `abc` in an `x.abc` expression.\n   */\n    member () {\n      let member = '';\n      let ch = this.white();\n      let isIdentifierChar = Identifier.is_valid_start_char;\n\n      while (ch) {\n        if (!isIdentifierChar(ch)) {\n          break\n        }\n        member += ch;\n        ch = this.next();\n        isIdentifierChar = Identifier.is_valid_continue_char;\n      }\n      return member\n    }\n\n  /**\n   * A dereference applies to an identifer, being either a function\n   * call \"()\" or a membership lookup with square brackets \"[member]\".\n   * @return {fn or undefined}  Dereference function to be applied to the\n   *                            Identifier\n   */\n    dereference () {\n      let member;\n      let ch = this.white();\n\n      while (ch) {\n        if (ch === '(') {\n        // a(...) function call\n          return this.funcArguments()\n        } else if (ch === '[') {\n        // a[x] membership\n          this.next('[');\n          member = this.expression();\n          this.white();\n          this.next(']');\n\n          return member\n        } else if (ch === '.') {\n        // a.x membership\n          this.next('.');\n          return this.member()\n        } else {\n          break\n        }\n      }\n    }\n\n    dereferences () {\n      let ch = this.white();\n      let dereferences = [];\n      let deref;\n\n      while (ch) {\n        deref = this.dereference();\n        if (deref !== undefined) {\n          dereferences.push(deref);\n        } else {\n          break\n        }\n      }\n      return dereferences\n    }\n\n    identifier () {\n      let token = '';\n      let isIdentifierChar = Identifier.is_valid_start_char;\n      let ch = this.white();\n\n      while (ch) {\n        if (!isIdentifierChar(ch)) {\n          break\n        }\n        token += ch;\n        ch = this.next();\n        isIdentifierChar = Identifier.is_valid_continue_char;\n      }\n      switch (token) {\n        case 'true': return true\n        case 'false': return false\n        case 'null': return null\n        case 'undefined': return void 0\n        case 'function':\n          throw new Error('Knockout: Anonymous functions are no longer supported, but `=>` lambdas are.')\n      // return this.anonymous_fn();\n      }\n      return new Identifier(this, token, this.dereferences())\n    }\n\n    readBindings () {\n      let key;\n      let bindings = {};\n      let sep;\n      let expr;\n      let ch = this.ch;\n\n      while (ch) {\n        key = this.name();\n        sep = this.white();\n\n        if (!sep || sep === ',') {\n          if (sep) {\n            ch = this.next(',');\n          } else {\n            ch = '';\n          }\n        // A \"bare\" binding e.g. \"text\"; substitute value of 'null'\n        // so it becomes \"text: null\".\n          bindings[key] = null;\n        } else {\n          if (key.indexOf('.') !== -1) {\n          // Namespaced â€“ i.e.\n          //    `attr.css: x` becomes `attr: { css: x }`\n          //     ^^^ - key\n            key = key.split('.');\n            bindings[key[0]] = bindings[key[0]] || {};\n\n            if (key.length !== 2) {\n              options.onError('Binding ' + key + ' should have two parts (a.b).');\n            } else if (bindings[key[0]].constructor !== Object) {\n              options.onError('Binding ' + key[0] + '.' + key[1] + ' paired with a non-object.');\n            }\n\n            ch = this.next(':');\n            this.objectAddValue(bindings[key[0]], key[1], this.expression(true));\n          } else {\n            ch = this.next(':');\n            if (bindings[key] && typeof bindings[key] === 'object' && bindings[key].constructor === Object) {\n            // Extend a namespaced bindings e.g. we've previously seen\n            // on.x, now we're seeing on: { 'abc' }.\n              expr = this.expression(true);\n              if (typeof expr !== 'object' || expr.constructor !== Object) {\n                options.onError('Expected plain object for ' + key + ' value.');\n              } else {\n                extend(bindings[key], expr);\n              }\n            } else {\n              bindings[key] = this.expression(true);\n            }\n          }\n\n          this.white();\n          if (this.ch) {\n            ch = this.next(',');\n          } else {\n            ch = '';\n          }\n        }\n      }\n      return bindings\n    }\n\n    valueAsAccessor (value, context, globals, node) {\n      if (!value) { return () => value }\n      if (typeof value === 'function') { return value }\n\n      if (value[Node$1.isExpressionOrIdentifierSymbol]) {\n        return () => Node$1.value_of(value, context, globals, node)\n      }\n\n      if (Array.isArray(value)) {\n        return () => value.map(v => Node$1.value_of(v, context, globals, node))\n      }\n\n      if (typeof (value) !== 'function') {\n        return () => clonePlainObjectDeep(value)\n      }\n\n      throw new Error('Value has cannot be converted to accessor: ' + value)\n    }\n\n    /**\n    * Convert result[name] from a value to a function (i.e. `valueAccessor()`)\n    * @param  {object} result [Map of top-level names to values]\n    * @return {object}        [Map of top-level names to functions]\n    *\n    * Accessors may be one of (below) constAccessor, identifierAccessor,\n    * expressionAccessor, or nodeAccessor.\n    */\n    convertToAccessors (result, context, globals, node) {\n      objectForEach(result, (name, value) => {\n        if (value instanceof Identifier) {\n          // Return a function that, with no arguments returns\n          // the value of the identifier, otherwise sets the\n          // value of the identifier to the first given argument.\n          Object.defineProperty(result, name, {\n            value: function (optionalValue, options$$1) {\n              const currentValue = value.get_value(undefined, context, globals, node);\n              if (arguments.length === 0) { return currentValue }\n              const unchanged = optionalValue === currentValue;\n              if (options$$1 && options$$1.onlyIfChanged && unchanged) { return }\n              return value.set_value(optionalValue, context, globals)\n            }\n          });\n        } else {\n          result[name] = this.valueAsAccessor(value, context, globals, node);\n        }\n      });\n      return result\n    }\n\n    preparse (source = '') {\n      const preparsers = options.bindingStringPreparsers || [];\n      return preparsers.reduce((acc, fn) => fn(acc), source.trim())\n    }\n\n    runParse (source, fn) {\n      this.text = this.preparse(source);\n      this.at = 0;\n      this.ch = ' ';\n\n      try {\n        var result = fn();\n        this.white();\n        if (this.ch) {\n          this.error('Syntax Error');\n        }\n        return result\n      } catch (e) {\n        options.onError(e);\n      }\n    }\n\n    /**\n     * Get the bindings as name: accessor()\n     * @param  {string} source The binding string to parse.\n     * @return {object}        Map of name to accessor function.\n     */\n    parse (source, context = {}, globals = {}, node) {\n      if (!source) { return () => null }\n      this.currentContextGlobals = [context, globals, node];\n      const parseFn = () => this.readBindings();\n      const bindingAccessors = this.runParse(source, parseFn);\n      return this.convertToAccessors(bindingAccessors, context, globals, node)\n    }\n\n    /**\n     * Return a function that evaluates and returns the result of the expression.\n     */\n    parseExpression (source, context = {}, globals = {}, node) {\n      if (!source) { return () => '' }\n      this.currentContextGlobals = [context, globals, node];\n      const parseFn = () => this.expression(true);\n      const bindingAccessors = this.runParse(source, parseFn);\n      return this.valueAsAccessor(bindingAccessors, context, globals, node)\n    }\n  }\n\n  /* eslint no-cond-assign: 0 */\n\n  // The following regular expressions will be used to split an object-literal string into tokens\n\n  // These characters have special meaning to the parser and must not appear in the middle of a\n  // token, except as part of a string.\n  const specials = ',\"\\'`{}()/:[\\\\]';\n  const bindingToken = RegExp([\n      // These match strings, either with double quotes, single quotes, or backticks\n    '\"(?:\\\\\\\\.|[^\"])*\"',\n    \"'(?:\\\\\\\\.|[^'])*'\",\n    '`(?:\\\\\\\\.|[^`])*`',\n      // Match C style comments\n    '/\\\\*(?:[^*]|\\\\*+[^*/])*\\\\*+/',\n      // Match C++ style comments\n    '//.*\\n',\n      // Match a regular expression (text enclosed by slashes), but will also match sets of divisions\n      // as a regular expression (this is handled by the parsing loop below).\n    '/(?:\\\\\\\\.|[^/])+/\\\\w*',\n      // Match text (at least two characters) that does not contain any of the above special characters,\n      // although some of the special characters are allowed to start it (all but the colon and comma).\n      // The text can contain spaces, but leading or trailing spaces are skipped.\n    '[^\\\\s:,/][^' + specials + ']*[^\\\\s' + specials + ']',\n      // Match any non-space character not matched already. This will match colons and commas, since they're\n      // not matched by \"everyThingElse\", but will also match any other single character that wasn't already\n      // matched (for example: in \"a: 1, b: 2\", each of the non-space characters will be matched by oneNotSpace).\n    '[^\\\\s]'\n  ].join('|'), 'g');\n\n    // Match end of previous token to determine whether a slash is a division or regex.\n  const divisionLookBehind = /[\\])\"'A-Za-z0-9_$]+$/;\n  const keywordRegexLookBehind = { 'in': 1, 'return': 1, 'typeof': 1 };\n\n  /**\n   * Break a binding string (data-bind='x: val, y: ..') into a stable array\n   * of {key: value}.\n   */\n  function parseObjectLiteral (objectLiteralString) {\n    // Trim leading and trailing spaces from the string\n    var str = stringTrim(objectLiteralString);\n\n    // Trim braces '{' surrounding the whole object literal\n    if (str.charCodeAt(0) === 123) str = str.slice(1, -1);\n\n    // Add a newline to correctly match a C++ style comment at the end of the string and\n    // add a comma so that we don't need a separate code block to deal with the last item\n    str += '\\n,';\n\n    // Split into tokens\n    var result = [];\n    var toks = str.match(bindingToken);\n    var key;\n    var values = [];\n    var depth = 0;\n\n    if (toks.length <= 1) { return [] }\n\n    for (var i = 0, tok; tok = toks[i]; ++i) {\n      var c = tok.charCodeAt(0);\n      // A comma signals the end of a key/value pair if depth is zero\n      if (c === 44) { // \",\"\n        if (depth <= 0) {\n          result.push((key && values.length) ? {\n            key: key,\n            value: values.join('')\n          } : {\n            'unknown': key || values.join('')\n          });\n          key = depth = 0;\n          values = [];\n          continue\n        }\n        // Simply skip the colon that separates the name and value\n      } else if (c === 58) { // \":\"\n        if (!depth && !key && values.length === 1) {\n          key = values.pop();\n          continue\n        }\n        // A set of slashes is initially matched as a regular expression, but could be division\n      } else if (c === 47 && tok.length > 1 && (tok.charCodeAt(1) === 47 || tok.charCodeAt(1) === 42)) { // \"//\" or \"/*\"\n        // skip comments\n        continue\n      } else if (c === 47 && i && tok.length > 1) { // \"/\"\n        // Look at the end of the previous token to determine if the slash is actually division\n        var match = toks[i - 1].match(divisionLookBehind);\n        if (match && !keywordRegexLookBehind[match[0]]) {\n          // The slash is actually a division punctuator; re-parse the remainder of the string (not including the slash)\n          str = str.substr(str.indexOf(tok) + 1);\n          toks = str.match(bindingToken);\n          i = -1;\n          // Continue with just the slash\n          tok = '/';\n        }\n        // Increment depth for parentheses, braces, and brackets so that interior commas are ignored\n      } else if (c === 40 || c === 123 || c === 91) { // '(', '{', '['\n        ++depth;\n      } else if (c === 41 || c === 125 || c === 93) { // ')', '}', ']'\n        --depth;\n        // The key will be the first token; if it's a string, trim the quotes\n      } else if (!key && !values.length && (c === 34 || c === 39)) { // '\"', \"'\"\n        tok = tok.slice(1, -1);\n      }\n      values.push(tok);\n    }\n\n    return result\n  }\n\n  //\n\n  const computedState = createSymbolOrString('_state');\n  const DISPOSED_STATE = {\n    dependencyTracking: null,\n    dependenciesCount: 0,\n    isDisposed: true,\n    isStale: false,\n    isDirty: false,\n    isSleeping: false,\n    disposeWhenNodeIsRemoved: null,\n    readFunction: null,\n    _options: null\n  };\n\n  function computed (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options$$1) {\n    if (typeof evaluatorFunctionOrOptions === 'object') {\n          // Single-parameter syntax - everything is on this \"options\" param\n      options$$1 = evaluatorFunctionOrOptions;\n    } else {\n          // Multi-parameter syntax - construct the options according to the params passed\n      options$$1 = options$$1 || {};\n      if (evaluatorFunctionOrOptions) {\n        options$$1.read = evaluatorFunctionOrOptions;\n      }\n    }\n    if (typeof options$$1.read !== 'function') {\n      throw Error('Pass a function that returns the value of the computed')\n    }\n\n    var writeFunction = options$$1.write;\n    var state = {\n      latestValue: undefined,\n      isStale: true,\n      isDirty: true,\n      isBeingEvaluated: false,\n      suppressDisposalUntilDisposeWhenReturnsFalse: false,\n      isDisposed: false,\n      pure: false,\n      isSleeping: false,\n      readFunction: options$$1.read,\n      evaluatorFunctionTarget: evaluatorFunctionTarget || options$$1.owner,\n      disposeWhenNodeIsRemoved: options$$1.disposeWhenNodeIsRemoved || options$$1.disposeWhenNodeIsRemoved || null,\n      disposeWhen: options$$1.disposeWhen || options$$1.disposeWhen,\n      domNodeDisposalCallback: null,\n      dependencyTracking: {},\n      dependenciesCount: 0,\n      evaluationTimeoutInstance: null\n    };\n\n    function computedObservable () {\n      if (arguments.length > 0) {\n        if (typeof writeFunction === 'function') {\n                  // Writing a value\n          writeFunction.apply(state.evaluatorFunctionTarget, arguments);\n        } else {\n          throw new Error(\"Cannot write a value to a computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.\")\n        }\n        return this // Permits chained assignments\n      } else {\n        // Reading the value\n        if (!state.isDisposed) {\n          registerDependency(computedObservable);\n        }\n        if (state.isDirty || (state.isSleeping && computedObservable.haveDependenciesChanged())) {\n          computedObservable.evaluateImmediate();\n        }\n        return state.latestValue\n      }\n    }\n\n    computedObservable[computedState] = state;\n    computedObservable.isWriteable = typeof writeFunction === 'function';\n\n    subscribable.fn.init(computedObservable);\n\n    // Inherit from 'computed'\n    Object.setPrototypeOf(computedObservable, computed.fn);\n\n    if (options$$1.pure) {\n      state.pure = true;\n      state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription\n      extend(computedObservable, pureComputedOverrides);\n    } else if (options$$1.deferEvaluation) {\n      extend(computedObservable, deferEvaluationOverrides);\n    }\n\n    if (options.deferUpdates) {\n      extenders.deferred(computedObservable, true);\n    }\n\n    if (options.debug) {\n          // #1731 - Aid debugging by exposing the computed's options\n      computedObservable._options = options$$1;\n    }\n\n    if (state.disposeWhenNodeIsRemoved) {\n          // Since this computed is associated with a DOM node, and we don't want to dispose the computed\n          // until the DOM node is *removed* from the document (as opposed to never having been in the document),\n          // we'll prevent disposal until \"disposeWhen\" first returns false.\n      state.suppressDisposalUntilDisposeWhenReturnsFalse = true;\n\n          // disposeWhenNodeIsRemoved: true can be used to opt into the \"only dispose after first false result\"\n          // behavior even if there's no specific node to watch. In that case, clear the option so we don't try\n          // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't\n          // be documented or used by application code, as it's likely to change in a future version of KO.\n      if (!state.disposeWhenNodeIsRemoved.nodeType) {\n        state.disposeWhenNodeIsRemoved = null;\n      }\n    }\n\n      // Evaluate, unless sleeping or deferEvaluation is true\n    if (!state.isSleeping && !options$$1.deferEvaluation) {\n      computedObservable.evaluateImmediate();\n    }\n\n      // Attach a DOM node disposal callback so that the computed will be proactively disposed as soon as the node is\n      // removed using ko.removeNode. But skip if isActive is false (there will never be any dependencies to dispose).\n    if (state.disposeWhenNodeIsRemoved && computedObservable.isActive()) {\n      addDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback = function () {\n        computedObservable.dispose();\n      });\n    }\n\n    return computedObservable\n  }\n\n  // Utility function that disposes a given dependencyTracking entry\n  function computedDisposeDependencyCallback (id, entryToDispose) {\n    if (entryToDispose !== null && entryToDispose.dispose) {\n      entryToDispose.dispose();\n    }\n  }\n\n  // This function gets called each time a dependency is detected while evaluating a computed.\n  // It's factored out as a shared function to avoid creating unnecessary function instances during evaluation.\n  function computedBeginDependencyDetectionCallback (subscribable$$1, id) {\n    var computedObservable = this.computedObservable,\n      state = computedObservable[computedState];\n    if (!state.isDisposed) {\n      if (this.disposalCount && this.disposalCandidates[id]) {\n        // Don't want to dispose this subscription, as it's still being used\n        computedObservable.addDependencyTracking(id, subscribable$$1, this.disposalCandidates[id]);\n        this.disposalCandidates[id] = null; // No need to actually delete the property - disposalCandidates is a transient object anyway\n        --this.disposalCount;\n      } else if (!state.dependencyTracking[id]) {\n        // Brand new subscription - add it\n        computedObservable.addDependencyTracking(id, subscribable$$1, state.isSleeping ? { _target: subscribable$$1 } : computedObservable.subscribeToDependency(subscribable$$1));\n      }\n      // If the observable we've accessed has a pending notification, ensure\n      // we get notified of the actual final value (bypass equality checks)\n      if (subscribable$$1._notificationIsPending) {\n        subscribable$$1._notifyNextChangeIfValueIsDifferent();\n      }\n    }\n  }\n\n  computed.fn = {\n    equalityComparer: valuesArePrimitiveAndEqual,\n    getDependenciesCount () {\n      return this[computedState].dependenciesCount\n    },\n\n    getDependencies () {\n      const dependencyTracking = this[computedState].dependencyTracking;\n      const dependentObservables = [];\n\n      objectForEach(dependencyTracking, function (id, dependency) {\n        dependentObservables[dependency._order] = dependency._target;\n      });\n\n      return dependentObservables\n    },\n\n    addDependencyTracking (id, target, trackingObj) {\n      if (this[computedState].pure && target === this) {\n        throw Error(\"A 'pure' computed must not be called recursively\")\n      }\n\n      this[computedState].dependencyTracking[id] = trackingObj;\n      trackingObj._order = this[computedState].dependenciesCount++;\n      trackingObj._version = target.getVersion();\n    },\n    haveDependenciesChanged () {\n      var id, dependency, dependencyTracking = this[computedState].dependencyTracking;\n      for (id in dependencyTracking) {\n        if (hasOwnProperty(dependencyTracking, id)) {\n          dependency = dependencyTracking[id];\n          if ((this._evalDelayed && dependency._target._notificationIsPending) || dependency._target.hasChanged(dependency._version)) {\n            return true\n          }\n        }\n      }\n    },\n    markDirty () {\n          // Process \"dirty\" events if we can handle delayed notifications\n      if (this._evalDelayed && !this[computedState].isBeingEvaluated) {\n        this._evalDelayed(false /* notifyChange */);\n      }\n    },\n    isActive () {\n      const state = this[computedState];\n      return state.isDirty || state.dependenciesCount > 0\n    },\n    respondToChange () {\n          // Ignore \"change\" events if we've already scheduled a delayed notification\n      if (!this._notificationIsPending) {\n        this.evaluatePossiblyAsync();\n      } else if (this[computedState].isDirty) {\n        this[computedState].isStale = true;\n      }\n    },\n    subscribeToDependency (target) {\n      if (target._deferUpdates) {\n        var dirtySub = target.subscribe(this.markDirty, this, 'dirty'),\n          changeSub = target.subscribe(this.respondToChange, this);\n        return {\n          _target: target,\n          dispose () {\n            dirtySub.dispose();\n            changeSub.dispose();\n          }\n        }\n      } else {\n        return target.subscribe(this.evaluatePossiblyAsync, this)\n      }\n    },\n    evaluatePossiblyAsync () {\n      var computedObservable = this,\n        throttleEvaluationTimeout = computedObservable.throttleEvaluation;\n      if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {\n        clearTimeout(this[computedState].evaluationTimeoutInstance);\n        this[computedState].evaluationTimeoutInstance = safeSetTimeout(function () {\n          computedObservable.evaluateImmediate(true /* notifyChange */);\n        }, throttleEvaluationTimeout);\n      } else if (computedObservable._evalDelayed) {\n        computedObservable._evalDelayed(true /* notifyChange */);\n      } else {\n        computedObservable.evaluateImmediate(true /* notifyChange */);\n      }\n    },\n    evaluateImmediate (notifyChange) {\n      var computedObservable = this,\n        state = computedObservable[computedState],\n        disposeWhen = state.disposeWhen,\n        changed = false;\n\n      if (state.isBeingEvaluated) {\n        // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.\n        // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost\n        // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing\n        // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387\n        return\n      }\n\n          // Do not evaluate (and possibly capture new dependencies) if disposed\n      if (state.isDisposed) {\n        return\n      }\n\n      if (state.disposeWhenNodeIsRemoved && !domNodeIsAttachedToDocument(state.disposeWhenNodeIsRemoved) || disposeWhen && disposeWhen()) {\n              // See comment above about suppressDisposalUntilDisposeWhenReturnsFalse\n        if (!state.suppressDisposalUntilDisposeWhenReturnsFalse) {\n          computedObservable.dispose();\n          return\n        }\n      } else {\n              // It just did return false, so we can stop suppressing now\n        state.suppressDisposalUntilDisposeWhenReturnsFalse = false;\n      }\n\n      state.isBeingEvaluated = true;\n      try {\n        changed = this.evaluateImmediate_CallReadWithDependencyDetection(notifyChange);\n      } finally {\n        state.isBeingEvaluated = false;\n      }\n\n      return changed\n    },\n    evaluateImmediate_CallReadWithDependencyDetection (notifyChange) {\n          // This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.\n          // Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,\n          // which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).\n\n      var computedObservable = this,\n        state = computedObservable[computedState],\n        changed = false;\n\n          // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).\n          // Then, during evaluation, we cross off any that are in fact still being used.\n      var isInitial$$1 = state.pure ? undefined : !state.dependenciesCount,   // If we're evaluating when there are no previous dependencies, it must be the first time\n        dependencyDetectionContext = {\n          computedObservable: computedObservable,\n          disposalCandidates: state.dependencyTracking,\n          disposalCount: state.dependenciesCount\n        };\n\n      begin({\n        callbackTarget: dependencyDetectionContext,\n        callback: computedBeginDependencyDetectionCallback,\n        computed: computedObservable,\n        isInitial: isInitial$$1\n      });\n\n      state.dependencyTracking = {};\n      state.dependenciesCount = 0;\n\n      var newValue = this.evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext);\n\n      if (!state.dependenciesCount) {\n        computedObservable.dispose();\n        changed = true; // When evaluation causes a disposal, make sure all dependent computeds get notified so they'll see the new state\n      } else {\n        changed = computedObservable.isDifferent(state.latestValue, newValue);\n      }\n\n      if (changed) {\n        if (!state.isSleeping) {\n          computedObservable.notifySubscribers(state.latestValue, 'beforeChange');\n        } else {\n          computedObservable.updateVersion();\n        }\n\n        state.latestValue = newValue;\n        if (options.debug) { computedObservable._latestValue = newValue; }\n\n        computedObservable.notifySubscribers(state.latestValue, 'spectate');\n\n        if (!state.isSleeping && notifyChange) {\n          computedObservable.notifySubscribers(state.latestValue);\n        }\n\n        if (computedObservable._recordUpdate) {\n          computedObservable._recordUpdate();\n        }\n      }\n\n      if (isInitial$$1) {\n        computedObservable.notifySubscribers(state.latestValue, 'awake');\n      }\n\n      return changed\n    },\n    evaluateImmediate_CallReadThenEndDependencyDetection (state, dependencyDetectionContext) {\n      // This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.\n      // You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection\n      // can be independent of try/finally blocks, which contributes to saving about 40% off the CPU\n      // overhead of computed evaluation (on V8 at least).\n\n      try {\n        var readFunction = state.readFunction;\n        return state.evaluatorFunctionTarget ? readFunction.call(state.evaluatorFunctionTarget) : readFunction()\n      } finally {\n        end();\n\n        // For each subscription no longer being used, remove it from the active subscriptions list and dispose it\n        if (dependencyDetectionContext.disposalCount && !state.isSleeping) {\n          objectForEach(dependencyDetectionContext.disposalCandidates, computedDisposeDependencyCallback);\n        }\n\n        state.isStale = state.isDirty = false;\n      }\n    },\n    peek (forceEvaluate) {\n      // Peek won't ordinarily re-evaluate, except while the computed is sleeping\n      //  or to get the initial value when \"deferEvaluation\" is set.\n      const state = this[computedState];\n      if ((state.isDirty && (forceEvaluate || !state.dependenciesCount)) || (state.isSleeping && this.haveDependenciesChanged())) {\n        this.evaluateImmediate();\n      }\n      return state.latestValue\n    },\n\n    get [LATEST_VALUE] () {\n      return this.peek()\n    },\n\n    limit (limitFunction) {\n      const state = this[computedState];\n      // Override the limit function with one that delays evaluation as well\n      subscribable.fn.limit.call(this, limitFunction);\n      Object.assign(this, {\n        _evalIfChanged () {\n          if (!this[computedState].isSleeping) {\n            if (this[computedState].isStale) {\n              this.evaluateImmediate();\n            } else {\n              this[computedState].isDirty = false;\n            }\n          }\n          return state.latestValue\n        },\n        _evalDelayed (isChange) {\n          this._limitBeforeChange(state.latestValue);\n\n          // Mark as dirty\n          state.isDirty = true;\n          if (isChange) {\n            state.isStale = true;\n          }\n\n          // Pass the observable to the \"limit\" code, which will evaluate it when\n          // it's time to do the notification.\n          this._limitChange(this, !isChange /* isDirty */);\n        }\n      });\n    },\n    dispose () {\n      var state = this[computedState];\n      if (!state.isSleeping && state.dependencyTracking) {\n        objectForEach(state.dependencyTracking, function (id, dependency) {\n          if (dependency.dispose) {\n            dependency.dispose();\n          }\n        });\n      }\n      if (state.disposeWhenNodeIsRemoved && state.domNodeDisposalCallback) {\n        removeDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback);\n      }\n      Object.assign(state, DISPOSED_STATE);\n    }\n  };\n\n  var pureComputedOverrides = {\n    beforeSubscriptionAdd (event) {\n          // If asleep, wake up the computed by subscribing to any dependencies.\n      var computedObservable = this,\n        state = computedObservable[computedState];\n      if (!state.isDisposed && state.isSleeping && event === 'change') {\n        state.isSleeping = false;\n        if (state.isStale || computedObservable.haveDependenciesChanged()) {\n          state.dependencyTracking = null;\n          state.dependenciesCount = 0;\n          if (computedObservable.evaluateImmediate()) {\n            computedObservable.updateVersion();\n          }\n        } else {\n          // First put the dependencies in order\n          var dependenciesOrder = [];\n          objectForEach(state.dependencyTracking, function (id, dependency) {\n            dependenciesOrder[dependency._order] = id;\n          });\n                  // Next, subscribe to each one\n          arrayForEach(dependenciesOrder, function (id, order) {\n            var dependency = state.dependencyTracking[id],\n              subscription = computedObservable.subscribeToDependency(dependency._target);\n            subscription._order = order;\n            subscription._version = dependency._version;\n            state.dependencyTracking[id] = subscription;\n          });\n\n          // Waking dependencies may have triggered effects\n          if (computedObservable.haveDependenciesChanged()) {\n            if (computedObservable.evaluateImmediate()) {\n              computedObservable.updateVersion();\n            }\n          }\n        }\n\n        if (!state.isDisposed) {     // test since evaluating could trigger disposal\n          computedObservable.notifySubscribers(state.latestValue, 'awake');\n        }\n      }\n    },\n    afterSubscriptionRemove (event) {\n      var state = this[computedState];\n      if (!state.isDisposed && event === 'change' && !this.hasSubscriptionsForEvent('change')) {\n        objectForEach(state.dependencyTracking, function (id, dependency) {\n          if (dependency.dispose) {\n            state.dependencyTracking[id] = {\n              _target: dependency._target,\n              _order: dependency._order,\n              _version: dependency._version\n            };\n            dependency.dispose();\n          }\n        });\n        state.isSleeping = true;\n        this.notifySubscribers(undefined, 'asleep');\n      }\n    },\n    getVersion () {\n          // Because a pure computed is not automatically updated while it is sleeping, we can't\n          // simply return the version number. Instead, we check if any of the dependencies have\n          // changed and conditionally re-evaluate the computed observable.\n      var state = this[computedState];\n      if (state.isSleeping && (state.isStale || this.haveDependenciesChanged())) {\n        this.evaluateImmediate();\n      }\n      return subscribable.fn.getVersion.call(this)\n    }\n  };\n\n  var deferEvaluationOverrides = {\n    beforeSubscriptionAdd (event) {\n          // This will force a computed with deferEvaluation to evaluate when the first subscription is registered.\n      if (event === 'change' || event === 'beforeChange') {\n        this.peek();\n      }\n    }\n  };\n\n  Object.setPrototypeOf(computed.fn, subscribable.fn);\n\n  // Set the proto values for ko.computed\n  var protoProp = observable.protoProperty; // == \"__ko_proto__\"\n  computed.fn[protoProp] = computed;\n\n  /* This is used by ko.isObservable */\n  observable.observablePrototypes.add(computed);\n\n  function isComputed (instance) {\n    return (typeof instance === 'function' && instance[protoProp] === computed)\n  }\n\n  function isPureComputed (instance) {\n    return isComputed(instance) && instance[computedState] && instance[computedState].pure\n  }\n\n  function pureComputed (evaluatorFunctionOrOptions, evaluatorFunctionTarget) {\n    if (typeof evaluatorFunctionOrOptions === 'function') {\n      return computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, {'pure': true})\n    } else {\n      evaluatorFunctionOrOptions = extend({}, evaluatorFunctionOrOptions);   // make a copy of the parameter object\n      evaluatorFunctionOrOptions.pure = true;\n      return computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget)\n    }\n  }\n\n  function throttleExtender (target, timeout) {\n      // Throttling means two things:\n\n      // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies\n      //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate\n    target.throttleEvaluation = timeout;\n\n      // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*\n      //     so the target cannot change value synchronously or faster than a certain rate\n    var writeTimeoutInstance = null;\n    return computed({\n      read: target,\n      write: function (value) {\n        clearTimeout(writeTimeoutInstance);\n        writeTimeoutInstance = setTimeout(function () {\n          target(value);\n        }, timeout);\n      }\n    })\n  }\n\n  extenders.throttle = throttleExtender;\n\n  /**\n   * Create an ES\n   */\n\n  const PROXY_SYM = Symbol('Knockout Proxied Object');\n  const MIRROR_SYM = Symbol('Knockout Proxied Observables');\n\n  function makeComputed (proxy, fn) {\n    return computed({\n      owner: proxy,\n      read: fn,\n      write: fn,\n      pure: 'pure' in fn ? fn.pure : true,\n      deferEvaluation: 'deferEvaluation' in fn ? fn.deferEvaluation : true\n    }).extend({ deferred: true })\n  }\n\n  function setOrCreate (mirror, prop, value, proxy) {\n    if (!mirror[prop]) {\n      const ctr = Array.isArray(value) ? observableArray\n        : typeof value === 'function' ? makeComputed.bind(null, proxy)\n        : observable;\n      mirror[prop] = ctr(value);\n    } else {\n      mirror[prop](value);\n    }\n  }\n\n  function assignOrUpdate(mirror, object, proxy) {\n    for (const key of Object.keys(object)) {\n      setOrCreate(mirror, key, object[key], proxy);\n    }\n    return object\n  }\n\n  function proxy (object) {\n    const mirror = { [PROXY_SYM]: object };\n    mirror[MIRROR_SYM] = mirror;\n    const proxy = new Proxy(function () {}, {\n      has (target, prop) { return prop in mirror },\n      get (target, prop) { return unwrap(mirror[prop]) },\n      set (target, prop, value, receiver) {\n        setOrCreate(mirror, prop, value, proxy);\n        object[prop] = value;\n        return true\n      },\n      deleteProperty (property) {\n        delete mirror[property];\n        return delete object[property]\n      },\n      apply (target, thisArg, [props]) {\n        if (props) {\n          assignOrUpdate(mirror, props, proxy);\n          return Object.assign(object, props)\n        }\n        return object\n      },\n      getPrototypeOf () { return Object.getPrototypeOf(object) },\n      setPrototypeOf (target, proto) { return Object.setPrototypeOf(object, proto) },\n      defineProperty (target, prop, desc) { return Object.defineProperty(object, prop, desc) },\n      preventExtensions () { return Object.preventExtensions(object) },\n      isExtensible () { return Object.isExtensible(object) },\n      ownKeys () {\n        return [...Object.getOwnPropertyNames(object),\n                ...Object.getOwnPropertySymbols(object)]\n      }\n    });\n    assignOrUpdate(mirror, object, proxy);\n    return proxy\n  }\n\n  function getObservable (proxied, prop) { return proxied[MIRROR_SYM][prop] }\n  function peek$1 (proxied, prop) { return getObservable(proxied, prop).peek() }\n  function isProxied (proxied) { return PROXY_SYM in proxied }\n\n  Object.assign(proxy, { getObservable, peek: peek$1, isProxied });\n\n  function kowhen (predicate, context, resolve) {\n    const observable = pureComputed(predicate, context).extend({notify: 'always'});\n    const subscription = observable.subscribe(value => {\n      if (value) {\n        subscription.dispose();\n        resolve(value);\n      }\n    });\n    // In case the initial value is true, process it right away\n    observable.notifySubscribers(observable.peek());\n    return subscription\n  }\n\n  function when (predicate, callback, context) {\n    const whenFn = kowhen.bind(null, predicate, context);\n    return callback ? whenFn(callback.bind(context)) : new Promise(whenFn)\n  }\n\n  //\n\n  const SUBSCRIPTIONS = createSymbolOrString('LifeCycle Subscriptions List');\n  const ANCHOR_NODE = createSymbolOrString('LifeCycle Anchor Node');\n\n  class LifeCycle {\n    // NOTE: For more advanced integration as an ES6 mixin, see e.g.:\n    // http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\n\n    /**\n     * Copy the properties of the LifeCycle class to the target (or its prototype)\n     *\n     * NOTE: getOwnPropertyNames is needed to copy the non-enumerable properties.\n     */\n    static mixInto (Constructor) {\n      const target = Constructor.prototype || Constructor;\n      const mixin = LifeCycle.prototype;\n      for (let prop of Object.getOwnPropertyNames(mixin)) {\n        target[prop] = mixin[prop];\n      }\n    }\n\n    subscribe (observable, action, subscriptionType) {\n      if (typeof action === 'string') { action = this[action]; }\n      this.addDisposable(observable.subscribe(action, this, subscriptionType));\n    }\n\n    computed (params) {\n      if (typeof params === 'string') {\n        params = { read: this[params], write: this[params] };\n      }\n\n      if (typeof params === 'object') {\n        params = Object.assign({ owner: this }, params);\n      } else if (typeof params === 'function') {\n        const proto = Object.getPrototypeOf(this);\n        if (proto && proto[params.name] === params) { params = params.bind(this); }\n        params = { read: params, write: params };\n      } else {\n        throw new Error('LifeCycle::computed not given a valid type.')\n      }\n\n      params.disposeWhenNodeIsRemoved = this[ANCHOR_NODE];\n      return this.addDisposable(computed(params))\n    }\n\n    /**\n     * Add an event listener for the given or anchored node.\n     * @param {node} [node] (optional) The target node (otherwise the anchored node)\n     * @param {string} [type] Event type\n     * @param {function|string} [action] Either call the given function or `this[action]`\n     * @param {object} [options] (optional) Passed as `options` to `node.addEventListener`\n     */\n    addEventListener (...args) {\n      const node = args[0].nodeType ? args.shift() : this[ANCHOR_NODE];\n      const [type, act, options$$1] = args;\n      const handler = typeof act === 'string' ? this[act].bind(this) : act;\n      this.__addEventListener(node, type, handler, options$$1);\n    }\n\n    __addEventListener (node, eventType, handler, options$$1) {\n      node.addEventListener(eventType, handler, options$$1);\n      function dispose () { node.removeEventListener(eventType, handler); }\n      addDisposeCallback(node, dispose);\n      this.addDisposable({ dispose });\n    }\n\n    anchorTo (nodeOrLifeCycle) {\n      if ('addDisposable' in nodeOrLifeCycle) {\n        nodeOrLifeCycle.addDisposable(this);\n        this[ANCHOR_NODE] = null; // re-anchor on `anchorTo` calls\n      } else {\n        this[ANCHOR_NODE] = nodeOrLifeCycle;\n        addDisposeCallback(nodeOrLifeCycle, () => this[ANCHOR_NODE] === nodeOrLifeCycle && this.dispose());\n      }\n    }\n\n    dispose () {\n      const subscriptions = this[SUBSCRIPTIONS] || [];\n      subscriptions.forEach(s => s.dispose());\n      this[SUBSCRIPTIONS] = [];\n      this[ANCHOR_NODE] = null;\n    }\n\n    addDisposable (subscription) {\n      const subscriptions = this[SUBSCRIPTIONS] || [];\n      if (!this[SUBSCRIPTIONS]) { this[SUBSCRIPTIONS] = subscriptions; }\n      if (typeof subscription.dispose !== 'function') {\n        throw new Error('Lifecycle::addDisposable argument missing `dispose`.')\n      }\n      subscriptions.push(subscription);\n      return subscription\n    }\n  }\n\n  const contextAncestorBindingInfo = Symbol('_ancestorBindingInfo');\n  const boundElementDomDataKey = nextKey();\n\n  const bindingEvent = {\n    childrenComplete: 'childrenComplete',\n    descendantsComplete: 'descendantsComplete',\n\n    subscribe (node, event, callback, context) {\n      const bindingInfo = getOrSet(node, boundElementDomDataKey, {});\n      if (!bindingInfo.eventSubscribable) {\n        bindingInfo.eventSubscribable = new subscribable();\n      }\n      return bindingInfo.eventSubscribable.subscribe(callback, context, event)\n    },\n\n    notify (node, event) {\n      const bindingInfo = get(node, boundElementDomDataKey);\n      if (bindingInfo) {\n        if (bindingInfo.eventSubscribable) {\n          bindingInfo.eventSubscribable.notifySubscribers(node, event);\n        }\n      }\n    }\n  };\n\n  const boundElementDomDataKey$1 = nextKey();\n\n  const contextSubscribeSymbol = Symbol('Knockout Context Subscription');\n\n  // Unique stub to indicate inheritance.\n  const inheritParentIndicator = Symbol('Knockout Parent Indicator');\n\n  // The bindingContext constructor is only called directly to create the root context. For child\n  // contexts, use bindingContext.createChildContext or bindingContext.extend.\n  function bindingContext (dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, settings) {\n    const self = this;\n    const shouldInheritData = dataItemOrAccessor === inheritParentIndicator;\n    const realDataItemOrAccessor = shouldInheritData ? undefined : dataItemOrAccessor;\n    const isFunc = typeof realDataItemOrAccessor === 'function' && !isObservable(realDataItemOrAccessor);\n\n    // Export 'ko' in the binding context so it will be available in bindings and templates\n    // even if 'ko' isn't exported as a global, such as when using an AMD loader.\n    // See https://github.com/SteveSanderson/knockout/issues/490\n    self.ko = options.knockoutInstance;\n    let subscribable$$1;\n\n      // The binding context object includes static properties for the current, parent, and root view models.\n      // If a view model is actually stored in an observable, the corresponding binding context object, and\n      // any child contexts, must be updated when the view model is changed.\n    function updateContext () {\n          // Most of the time, the context will directly get a view model object, but if a function is given,\n          // we call the function to retrieve the view model. If the function accesses any observables or returns\n          // an observable, the dependency is tracked, and those observables can later cause the binding\n          // context to be updated.\n      const dataItemOrObservable = isFunc ? realDataItemOrAccessor() : realDataItemOrAccessor;\n      let dataItem = unwrap(dataItemOrObservable);\n\n      if (parentContext) {\n              // When a \"parent\" context is given, register a dependency on the parent context. Thus whenever the\n              // parent context is updated, this context will also be updated.\n        if (parentContext[contextSubscribeSymbol]) {\n          parentContext[contextSubscribeSymbol]();\n        }\n\n              // Copy $root and any custom properties from the parent context\n        extend(self, parentContext);\n\n         // Copy Symbol properties\n        if (contextAncestorBindingInfo in parentContext) {\n          self[contextAncestorBindingInfo] = parentContext[contextAncestorBindingInfo];\n        }\n      } else {\n        self.$parents = [];\n        self.$root = dataItem;\n      }\n\n      self[contextSubscribeSymbol] = subscribable$$1;\n\n      if (shouldInheritData) {\n        dataItem = self.$data;\n      } else {\n        self.$rawData = dataItemOrObservable;\n        self.$data = dataItem;\n      }\n\n      if (dataItemAlias) { self[dataItemAlias] = dataItem; }\n\n          // The extendCallback function is provided when creating a child context or extending a context.\n          // It handles the specific actions needed to finish setting up the binding context. Actions in this\n          // function could also add dependencies to this binding context.\n      if (extendCallback) { extendCallback(self, parentContext, dataItem); }\n\n      return self.$data\n    }\n\n    if (settings && settings.exportDependencies) {\n          // The \"exportDependencies\" option means that the calling code will track any dependencies and re-create\n          // the binding context when they change.\n      updateContext();\n    } else {\n      subscribable$$1 = pureComputed(updateContext);\n      subscribable$$1.peek();\n\n      // At this point, the binding context has been initialized, and the \"subscribable\" computed observable is\n      // subscribed to any observables that were accessed in the process. If there is nothing to track, the\n      // computed will be inactive, and we can safely throw it away. If it's active, the computed is stored in\n      // the context object.\n      if (subscribable$$1.isActive()) {\n        self[contextSubscribeSymbol] = subscribable$$1;\n\n        // Always notify because even if the model ($data) hasn't changed, other context properties might have changed\n        subscribable$$1['equalityComparer'] = null;\n      } else {\n        self[contextSubscribeSymbol] = undefined;\n      }\n    }\n  }\n\n  Object.assign(bindingContext.prototype, {\n\n    lookup (token, globals, node) {\n      // short circuits\n      switch (token) {\n        case '$element': return node\n        case '$context': return this\n        case 'this': case '$data': return this.$data\n      }\n      const $data = this.$data;\n      // instanceof Object covers 1. {}, 2. [], 3. function() {}, 4. new *;  it excludes undefined, null, primitives.\n      if ($data instanceof Object && token in $data) { return $data[token] }\n      if (token in this) { return this[token] }\n      if (token in globals) { return globals[token] }\n\n      throw new Error(`The variable \"${token}\" was not found on $data, $context, or globals.`)\n    },\n\n    // Extend the binding context hierarchy with a new view model object. If the parent context is watching\n    // any observables, the new child context will automatically get a dependency on the parent context.\n    // But this does not mean that the $data value of the child context will also get updated. If the child\n    // view model also depends on the parent view model, you must provide a function that returns the correct\n    // view model on each update.\n    createChildContext (dataItemOrAccessor, dataItemAlias, extendCallback, settings) {\n      return new bindingContext(dataItemOrAccessor, this, dataItemAlias, function (self, parentContext) {\n            // Extend the context hierarchy by setting the appropriate pointers\n        self.$parentContext = parentContext;\n        self.$parent = parentContext.$data;\n        self.$parents = (parentContext.$parents || []).slice(0);\n        self.$parents.unshift(self.$parent);\n        if (extendCallback) { extendCallback(self); }\n      }, settings)\n    },\n\n    // Extend the binding context with new custom properties. This doesn't change the context hierarchy.\n    // Similarly to \"child\" contexts, provide a function here to make sure that the correct values are set\n    // when an observable view model is updated.\n    extend (properties) {\n      // If the parent context references an observable view model, \"_subscribable\" will always be the\n      // latest view model object. If not, \"_subscribable\" isn't set, and we can use the static \"$data\" value.\n      return new bindingContext(inheritParentIndicator, this, null, function (self, parentContext) {\n        extend(self, typeof properties === 'function' ? properties.call(self) : properties);\n      })\n    },\n\n    createStaticChildContext (dataItemOrAccessor, dataItemAlias) {\n      return this.createChildContext(dataItemOrAccessor, dataItemAlias, null, { 'exportDependencies': true })\n    }\n  });\n\n  function storedBindingContextForNode (node) {\n    const bindingInfo = get(node, boundElementDomDataKey$1);\n    return bindingInfo && bindingInfo.context\n  }\n\n  // Retrieving binding context from arbitrary nodes\n  function contextFor (node) {\n    // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)\n    if (node && (node.nodeType === 1 || node.nodeType === 8)) {\n      return storedBindingContextForNode(node)\n    }\n  }\n\n  function dataFor (node) {\n    var context = contextFor(node);\n    return context ? context.$data : undefined\n  }\n\n  class BindingResult {\n    constructor ({asyncBindingsApplied, rootNode, bindingContext}) {\n      Object.assign(this, {\n        rootNode,\n        bindingContext,\n        isSync: asyncBindingsApplied.size === 0,\n        isComplete: this.isSync\n      });\n\n      if (!this.isSync) {\n        this.completionPromise = this.completeWhenBindingsFinish(asyncBindingsApplied);\n      }\n    }\n\n    async completeWhenBindingsFinish (asyncBindingsApplied) {\n      await Promise.all(asyncBindingsApplied);\n      this.isComplete = true;\n      return this\n    }\n  }\n\n  class BindingHandler extends LifeCycle {\n    constructor (params) {\n      super();\n      const {$element, valueAccessor, allBindings, $context} = params;\n      Object.assign(this, {\n        valueAccessor,\n        allBindings,\n        $element,\n        $context,\n        $data: $context.$data\n      });\n\n      this.anchorTo($element);\n    }\n\n    get value () { return this.valueAccessor() }\n    set value (v) {\n      const va = this.valueAccessor();\n      if (isWriteableObservable(va)) {\n        va(v);\n      } else {\n        this.valueAccessor(v);\n      }\n    }\n\n    get controlsDescendants () { return false }\n\n    static get allowVirtualElements () { return false }\n    static get isBindingHandlerClass () { return true }\n\n    /* Overload this for asynchronous bindings or bindings that recursively\n       apply bindings (e.g. components, foreach, template).\n\n       A binding should be complete when it has run through once, notably\n       in server-side bindings for pre-rendering.\n    */\n    get bindingCompleted () { return true }\n\n    static registerAs (name, provider = options.bindingProviderInstance) {\n      provider.bindingHandlers.set(name, this);\n    }\n  }\n\n  /**\n   * An AsyncBindingHandler shall call `completeBinding` when the binding\n   * is to be considered complete.\n   */\n  const ResolveSymbol = Symbol('Async Binding Resolved');\n\n  class AsyncBindingHandler extends BindingHandler {\n    constructor (params) {\n      super(params);\n      this.bindingCompletion = new Promise((resolve) => {\n        this[ResolveSymbol] = resolve;\n      });\n      this.completeBinding = bindingResult => this[ResolveSymbol](bindingResult);\n    }\n\n    get bindingCompleted () { return this.bindingCompletion }\n  }\n\n  /**\n   * We have no guarantees, for users employing legacy bindings,\n   * that it has not been changed with a modification like\n   *\n   *    ko.bindingHandlers[name] = { init: ...}\n   *\n   * ... so we have to keep track by way of a map.\n   */\n  const PossibleWeakMap = options.global.WeakMap || Map;\n  const legacyBindingMap = new PossibleWeakMap();\n\n  class LegacyBindingHandler extends BindingHandler {\n    constructor (params) {\n      super(params);\n      const handler = this.handler;\n      this.onError = params.onError;\n\n      if (typeof handler.dispose === 'function') {\n        this.addDisposable(handler);\n      }\n\n      try {\n        this.initReturn = handler.init && handler.init(...this.legacyArgs);\n      } catch (e) {\n        params.onError('init', e);\n      }\n    }\n\n    onValueChange () {\n      const handler = this.handler;\n      if (typeof handler.update !== 'function') { return }\n      try {\n        handler.update(...this.legacyArgs);\n      } catch (e) {\n        this.onError('update', e);\n      }\n    }\n\n    get legacyArgs () {\n      return [\n        this.$element, this.valueAccessor, this.allBindings,\n        this.$data, this.$context\n      ]\n    }\n\n    get controlsDescendants () {\n      const objectToTest = this.initReturn || this.handler || {};\n      return objectToTest.controlsDescendantBindings\n    }\n\n    /**\n     * Create a handler instance from the `origin`, which may be:\n     *\n     * 1. an object (becomes LegacyBindingHandler)\n     * 2. a function (becomes LegacyBindingHandler with `init: function`)\n     *\n     * If given an object (the only kind supported in knockout 3.x and before), it\n     * shall draw the `init`, `update`, and `allowVirtualElements` properties\n     */\n    static getOrCreateFor (key, handler) {\n      if (legacyBindingMap.has(handler)) {\n        return legacyBindingMap.get(handler)\n      }\n      const newLegacyHandler = this.createFor(key, handler);\n      legacyBindingMap.set(handler, newLegacyHandler);\n      return newLegacyHandler\n    }\n\n    static createFor (key, handler) {\n      if (typeof handler === 'function') {\n        const [initFn, disposeFn] = [handler, handler.dispose];\n        return class extends LegacyBindingHandler {\n          get handler () {\n            const init = initFn.bind(this);\n            const dispose = disposeFn ? disposeFn.bind(this) : null;\n            return { init, dispose }\n          }\n          static get after () { return handler.after }\n          static get allowVirtualElements () {\n            return handler.allowVirtualElements || allowedBindings[key]\n          }\n        }\n      }\n\n      if (typeof handler === 'object') {\n        return class extends LegacyBindingHandler {\n          get handler () { return handler }\n          static get after () { return handler.after }\n          static get allowVirtualElements () {\n            return handler.allowVirtualElements || allowedBindings[key]\n          }\n        }\n      }\n\n      throw new Error('The given handler is not an appropriate type.')\n    }\n  }\n\n  // The following element types will not be recursed into during binding.\n  const bindingDoesNotRecurseIntoElementTypes = {\n      // Don't want bindings that operate on text nodes to mutate <script> and <textarea> contents,\n      // because it's unexpected and a potential XSS issue.\n      // Also bindings should not operate on <template> elements since this breaks in Internet Explorer\n      // and because such elements' contents are always intended to be bound in a different context\n      // from where they appear in the document.\n    'script': true,\n    'textarea': true,\n    'template': true\n  };\n\n  function getBindingProvider () {\n    return options.bindingProviderInstance.instance || options.bindingProviderInstance\n  }\n\n  function isProviderForNode (provider, node) {\n    const nodeTypes = provider.FOR_NODE_TYPES || [1, 3, 8];\n    return nodeTypes.includes(node.nodeType)\n  }\n\n  function asProperHandlerClass (handler, bindingKey) {\n    if (!handler) { return }\n    return handler.isBindingHandlerClass ? handler\n      : LegacyBindingHandler.getOrCreateFor(bindingKey, handler)\n  }\n\n  function getBindingHandlerFromComponent (bindingKey, $component) {\n    if (!$component || typeof $component.getBindingHandler !== 'function') { return }\n    return asProperHandlerClass($component.getBindingHandler(bindingKey))\n  }\n\n  function getBindingHandler (bindingKey) {\n    const bindingDefinition = options.getBindingHandler(bindingKey) || getBindingProvider().bindingHandlers.get(bindingKey);\n    return asProperHandlerClass(bindingDefinition, bindingKey)\n  }\n\n  // Returns the value of a valueAccessor function\n  function evaluateValueAccessor (valueAccessor) {\n    return valueAccessor()\n  }\n\n  function applyBindingsToDescendantsInternal (bindingContext$$1, elementOrVirtualElement, asyncBindingsApplied) {\n    let nextInQueue = firstChild(elementOrVirtualElement);\n\n    if (!nextInQueue) { return }\n\n    let currentChild;\n    const provider = getBindingProvider();\n    const preprocessNode = provider.preprocessNode;\n\n    // Preprocessing allows a binding provider to mutate a node before bindings are applied to it. For example it's\n    // possible to insert new siblings after it, and/or replace the node with a different one. This can be used to\n    // implement custom binding syntaxes, such as {{ value }} for string interpolation, or custom element types that\n    // trigger insertion of <template> contents at that point in the document.\n    if (preprocessNode) {\n      while (currentChild = nextInQueue) {\n        nextInQueue = nextSibling(currentChild);\n        preprocessNode.call(provider, currentChild);\n      }\n\n      // Reset nextInQueue for the next loop\n      nextInQueue = firstChild(elementOrVirtualElement);\n    }\n\n    while (currentChild = nextInQueue) {\n      // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position\n      nextInQueue = nextSibling(currentChild);\n      applyBindingsToNodeAndDescendantsInternal(bindingContext$$1, currentChild, asyncBindingsApplied);\n    }\n\n    bindingEvent.notify(elementOrVirtualElement, bindingEvent.childrenComplete);\n  }\n\n  function hasBindings (node) {\n    const provider = getBindingProvider();\n    return isProviderForNode(provider, node) && provider.nodeHasBindings(node)\n  }\n\n  function nodeOrChildHasBindings (node) {\n    return hasBindings(node) || [...node.childNodes].some(c => nodeOrChildHasBindings(c))\n  }\n\n  function applyBindingsToNodeAndDescendantsInternal (bindingContext$$1, nodeVerified, asyncBindingsApplied) {\n    var isElement = nodeVerified.nodeType === 1;\n    if (isElement) { // Workaround IE <= 8 HTML parsing weirdness\n      normaliseVirtualElementDomStructure(nodeVerified);\n    }\n\n    // Perf optimisation: Apply bindings only if...\n    // (1) We need to store the binding info for the node (all element nodes)\n    // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)\n\n    let shouldApplyBindings = isElement || // Case (1)\n        hasBindings(nodeVerified);          // Case (2)\n\n    const { shouldBindDescendants } = shouldApplyBindings\n      ? applyBindingsToNodeInternal(nodeVerified, null, bindingContext$$1, asyncBindingsApplied)\n      : { shouldBindDescendants: true };\n\n    if (shouldBindDescendants && !bindingDoesNotRecurseIntoElementTypes[tagNameLower(nodeVerified)]) {\n      // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,\n      //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,\n      //    hence bindingContextsMayDifferFromDomParentElement is false\n      //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may\n      //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,\n      //    hence bindingContextsMayDifferFromDomParentElement is true\n      applyBindingsToDescendantsInternal(bindingContext$$1, nodeVerified, asyncBindingsApplied);\n    }\n  }\n\n\n  function * topologicalSortBindings (bindings, $component) {\n    const results = [];\n    // Depth-first sort\n    const bindingsConsidered = {};    // A temporary record of which bindings are already in 'result'\n    const cyclicDependencyStack = []; // Keeps track of a depth-search so that, if there's a cycle, we know which bindings caused it\n\n    objectForEach(bindings, function pushBinding (bindingKey) {\n      if (!bindingsConsidered[bindingKey]) {\n        const binding = getBindingHandlerFromComponent(bindingKey, $component) || getBindingHandler(bindingKey);\n        if (!binding) { return }\n          // First add dependencies (if any) of the current binding\n        if (binding.after) {\n          cyclicDependencyStack.push(bindingKey);\n          arrayForEach(binding.after, function (bindingDependencyKey) {\n            if (!bindings[bindingDependencyKey]) { return }\n            if (arrayIndexOf(cyclicDependencyStack, bindingDependencyKey) !== -1) {\n              throw Error('Cannot combine the following bindings, because they have a cyclic dependency: ' + cyclicDependencyStack.join(', '))\n            } else {\n              pushBinding(bindingDependencyKey);\n            }\n          });\n          cyclicDependencyStack.length--;\n        }\n          // Next add the current binding\n        results.push([ bindingKey, binding ]);\n      }\n      bindingsConsidered[bindingKey] = true;\n    });\n\n    for (const result of results) { yield result; }\n  }\n\n  function applyBindingsToNodeInternal (node, sourceBindings, bindingContext$$1, asyncBindingsApplied) {\n    const bindingInfo = getOrSet(node, boundElementDomDataKey$1, {});\n    // Prevent multiple applyBindings calls for the same node, except when a binding value is specified\n    const alreadyBound = bindingInfo.alreadyBound;\n    if (!sourceBindings) {\n      if (alreadyBound) {\n        if (!nodeOrChildHasBindings(node)) { return false }\n        onBindingError({\n          during: 'apply',\n          errorCaptured: new Error('You cannot apply bindings multiple times to the same element.'),\n          element: node,\n          bindingContext: bindingContext$$1\n        });\n        return false\n      }\n      bindingInfo.alreadyBound = true;\n    }\n\n    if (!alreadyBound) {\n      bindingInfo.context = bindingContext$$1;\n    }\n\n    // Use bindings if given, otherwise fall back on asking the bindings provider to give us some bindings\n    var bindings;\n    if (sourceBindings && typeof sourceBindings !== 'function') {\n      bindings = sourceBindings;\n    } else {\n      const provider = getBindingProvider();\n      const getBindings = provider.getBindingAccessors;\n\n      if (isProviderForNode(provider, node)) {\n            // Get the binding from the provider within a computed observable so that we can update the bindings whenever\n            // the binding context is updated or if the binding provider accesses observables.\n        var bindingsUpdater = computed(\n                function () {\n                  bindings = sourceBindings ? sourceBindings(bindingContext$$1, node) : getBindings.call(provider, node, bindingContext$$1);\n                    // Register a dependency on the binding context to support observable view models.\n                  if (bindings && bindingContext$$1[contextSubscribeSymbol]) { bindingContext$$1[contextSubscribeSymbol](); }\n                  return bindings\n                },\n                null, { disposeWhenNodeIsRemoved: node }\n            );\n\n        if (!bindings || !bindingsUpdater.isActive()) { bindingsUpdater = null; }\n      }\n    }\n\n    var bindingHandlerThatControlsDescendantBindings;\n    if (bindings) {\n      const $component = bindingContext$$1.$component || {};\n\n      const allBindingHandlers = {};\n      set(node, 'bindingHandlers', allBindingHandlers);\n\n          // Return the value accessor for a given binding. When bindings are static (won't be updated because of a binding\n          // context update), just return the value accessor from the binding. Otherwise, return a function that always gets\n          // the latest binding value and registers a dependency on the binding updater.\n      const getValueAccessor = bindingsUpdater\n              ? (bindingKey) => function (optionalValue) {\n                const valueAccessor = bindingsUpdater()[bindingKey];\n                if (arguments.length === 0) {\n                  return evaluateValueAccessor(valueAccessor)\n                } else {\n                  return valueAccessor(optionalValue)\n                }\n              } : (bindingKey) => bindings[bindingKey];\n\n          // Use of allBindings as a function is maintained for backwards compatibility, but its use is deprecated\n      function allBindings () {\n        return objectMap(bindingsUpdater ? bindingsUpdater() : bindings, evaluateValueAccessor)\n      }\n\n          // The following is the 3.x allBindings API\n      allBindings.has = (key) => key in bindings;\n      allBindings.get = (key) => bindings[key] && evaluateValueAccessor(getValueAccessor(key));\n\n      if (bindingEvent.childrenComplete in bindings) {\n        bindingEvent.subscribe(node, bindingEvent.childrenComplete, () => {\n          const callback = evaluateValueAccessor(bindings[bindingEvent.childrenComplete]);\n          if (!callback) { return }\n          const nodes = childNodes(node);\n          if (nodes.length) { callback(nodes, dataFor(nodes[0])); }\n        });\n      }\n\n      const bindingsGenerated = topologicalSortBindings(bindings, $component);\n      const nodeAsyncBindingPromises = new Set();\n      for (const [key, BindingHandlerClass] of bindingsGenerated) {\n          // Go through the sorted bindings, calling init and update for each\n        function reportBindingError (during, errorCaptured) {\n          onBindingError({\n            during,\n            errorCaptured,\n            bindings,\n            allBindings,\n            bindingKey: key,\n            bindingContext: bindingContext$$1,\n            element: node,\n            valueAccessor: getValueAccessor(key)\n          });\n        }\n\n        if (node.nodeType === 8 && !BindingHandlerClass.allowVirtualElements) {\n          throw new Error(`The binding '${key}' cannot be used with virtual elements`)\n        }\n\n        try {\n          const bindingHandler = ignore(() =>\n            new BindingHandlerClass({\n              allBindings,\n              $element: node,\n              $context: bindingContext$$1,\n              onError: reportBindingError,\n              valueAccessor (...v) { return getValueAccessor(key)(...v) }\n            })\n          );\n\n          if (bindingHandler.onValueChange) {\n            ignore(() =>\n              bindingHandler.computed('onValueChange')\n            );\n          }\n\n          // Expose the bindings via domData.\n          allBindingHandlers[key] = bindingHandler;\n\n          if (bindingHandler.controlsDescendants) {\n            if (bindingHandlerThatControlsDescendantBindings !== undefined) { throw new Error('Multiple bindings (' + bindingHandlerThatControlsDescendantBindings + ' and ' + key + ') are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.') }\n            bindingHandlerThatControlsDescendantBindings = key;\n          }\n\n          if (bindingHandler.bindingCompleted instanceof Promise) {\n            asyncBindingsApplied.add(bindingHandler.bindingCompleted);\n            nodeAsyncBindingPromises.add(bindingHandler.bindingCompleted);\n          }\n        } catch (err) {\n          reportBindingError('creation', err);\n        }\n      }\n\n      triggerDescendantsComplete(node, bindings, nodeAsyncBindingPromises);\n    }\n\n    const shouldBindDescendants = bindingHandlerThatControlsDescendantBindings === undefined;\n    return { shouldBindDescendants }\n  }\n\n  /**\n   *\n   * @param {HTMLElement} node\n   * @param {Object} bindings\n   * @param {[Promise]} nodeAsyncBindingPromises\n   */\n  function triggerDescendantsComplete (node, bindings, nodeAsyncBindingPromises) {\n    /** descendantsComplete ought to be an instance of the descendantsComplete\n      *  binding handler. */\n    const hasBindingHandler = bindingEvent.descendantsComplete in bindings;\n    const hasFirstChild = firstChild(node);\n    const accessor = hasBindingHandler && evaluateValueAccessor(bindings[bindingEvent.descendantsComplete]);\n    const callback = () => {\n      bindingEvent.notify(node, bindingEvent.descendantsComplete);\n      if (accessor && hasFirstChild) { accessor(node); }\n    };\n    if (nodeAsyncBindingPromises.size) {\n      Promise.all(nodeAsyncBindingPromises).then(callback);\n    } else {\n      callback();\n    }\n  }\n\n\n  function getBindingContext (viewModelOrBindingContext, extendContextCallback) {\n    return viewModelOrBindingContext && (viewModelOrBindingContext instanceof bindingContext)\n      ? viewModelOrBindingContext\n      : new bindingContext(viewModelOrBindingContext, undefined, undefined, extendContextCallback)\n  }\n\n  function applyBindingAccessorsToNode (node, bindings, viewModelOrBindingContext, asyncBindingsApplied) {\n    if (node.nodeType === 1) { // If it's an element, workaround IE <= 8 HTML parsing weirdness\n      normaliseVirtualElementDomStructure(node);\n    }\n    return applyBindingsToNodeInternal(node, bindings, getBindingContext(viewModelOrBindingContext), asyncBindingsApplied)\n  }\n\n  function applyBindingsToNode (node, bindings, viewModelOrBindingContext) {\n    const asyncBindingsApplied = new Set();\n    const bindingContext$$1 = getBindingContext(viewModelOrBindingContext);\n    const bindingAccessors = getBindingProvider().makeBindingAccessors(bindings, bindingContext$$1, node);\n    applyBindingAccessorsToNode(node, bindingAccessors, bindingContext$$1, asyncBindingsApplied);\n    return new BindingResult({asyncBindingsApplied, rootNode: node, bindingContext: bindingContext$$1})\n  }\n\n  function applyBindingsToDescendants (viewModelOrBindingContext, rootNode) {\n    const asyncBindingsApplied = new Set();\n    if (rootNode.nodeType === 1 || rootNode.nodeType === 8) {\n      const bindingContext$$1 = getBindingContext(viewModelOrBindingContext);\n      applyBindingsToDescendantsInternal(bindingContext$$1, rootNode, asyncBindingsApplied);\n      return new BindingResult({asyncBindingsApplied, rootNode, bindingContext: bindingContext$$1})\n    }\n    return new BindingResult({asyncBindingsApplied, rootNode})\n  }\n\n  function applyBindings (viewModelOrBindingContext, rootNode, extendContextCallback) {\n    const asyncBindingsApplied = new Set();\n    // If jQuery is loaded after Knockout, we won't initially have access to it. So save it here.\n    if (!options.jQuery === undefined && options.jQuery) {\n      options.jQuery = options.jQuery;\n    }\n\n    // rootNode is optional\n    if (!rootNode) {\n      rootNode = window.document.body;\n      if (!rootNode) {\n        throw Error('ko.applyBindings: could not find window.document.body; has the document been loaded?')\n      }\n    } else if (rootNode.nodeType !== 1 && rootNode.nodeType !== 8) {\n      throw Error('ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node')\n    }\n    const rootContext = getBindingContext(viewModelOrBindingContext, extendContextCallback);\n    applyBindingsToNodeAndDescendantsInternal(rootContext, rootNode, asyncBindingsApplied);\n    return Promise.all(asyncBindingsApplied)\n  }\n\n  function onBindingError (spec) {\n    var error;\n    if (spec.bindingKey) {\n          // During: 'init' or initial 'update'\n      error = spec.errorCaptured;\n      spec.message = 'Unable to process binding \"' + spec.bindingKey +\n              '\" in binding \"' + spec.bindingKey +\n              '\"\\nMessage: ' + (error.message ? error.message : error);\n    } else {\n          // During: 'apply'\n      error = spec.errorCaptured;\n    }\n    try {\n      extend(error, spec);\n    } catch (e) {\n          // Read-only error e.g. a DOMEXception.\n      spec.stack = error.stack;\n      error = new Error(error.message ? error.message : error);\n      extend(error, spec);\n    }\n    options.onError(error);\n  }\n\n  /* eslint no-cond-assign: 0 */\n\n  // Objective:\n  // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,\n  //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node\n  // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node\n  //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we\n  //   previously mapped - retain those nodes, and just insert/delete other ones\n\n  // \"callbackAfterAddingNodes\" will be invoked after any \"mapping\"-generated nodes are inserted into the container node\n  // You can use this, for example, to activate bindings on those nodes.\n\n  function mapNodeAndRefreshWhenChanged (containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {\n    // Map this array value inside a dependentObservable so we re-map when any dependency changes\n    var mappedNodes = [];\n    var dependentObservable = computed(function () {\n      var newMappedNodes = mapping(valueToMap, index, fixUpContinuousNodeArray(mappedNodes, containerNode)) || [];\n\n      // On subsequent evaluations, just replace the previously-inserted DOM nodes\n      if (mappedNodes.length > 0) {\n        replaceDomNodes(mappedNodes, newMappedNodes);\n        if (callbackAfterAddingNodes) { ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]); }\n      }\n\n      // Replace the contents of the mappedNodes array, thereby updating the record\n      // of which nodes would be deleted if valueToMap was itself later removed\n      mappedNodes.length = 0;\n      arrayPushAll(mappedNodes, newMappedNodes);\n    }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function () { return !anyDomNodeIsAttachedToDocument(mappedNodes) } });\n    return { mappedNodes: mappedNodes, dependentObservable: (dependentObservable.isActive() ? dependentObservable : undefined) }\n  }\n\n  var lastMappingResultDomDataKey = nextKey();\n  let deletedItemDummyValue = nextKey();\n\n  function setDomNodeChildrenFromArrayMapping (domNode, array, mapping, options$$1, callbackAfterAddingNodes, editScript) {\n    // Compare the provided array against the previous one\n    array = array || [];\n    if (typeof array.length === 'undefined') {\n      array = [array];\n    }\n    options$$1 = options$$1 || {};\n    let lastMappingResult = get(domNode, lastMappingResultDomDataKey);\n    let isFirstExecution = !lastMappingResult;\n\n    // Build the new mapping result\n    var newMappingResult = [];\n    var lastMappingResultIndex = 0;\n    var newMappingResultIndex = 0;\n\n    var nodesToDelete = [];\n    var itemsToProcess = [];\n    var itemsForBeforeRemoveCallbacks = [];\n    var itemsForMoveCallbacks = [];\n    var itemsForAfterAddCallbacks = [];\n    var mapData;\n    let countWaitingForRemove = 0;\n\n    function itemAdded (value) {\n      mapData = { arrayEntry: value, indexObservable: observable(newMappingResultIndex++) };\n      newMappingResult.push(mapData);\n      itemsToProcess.push(mapData);\n      if (!isFirstExecution) {\n        itemsForAfterAddCallbacks.push(mapData);\n      }\n    }\n\n    function itemMovedOrRetained (oldPosition) {\n      mapData = lastMappingResult[oldPosition];\n      if (newMappingResultIndex !== oldPosition) {\n        itemsForMoveCallbacks.push(mapData);\n      }\n      // Since updating the index might change the nodes, do so before calling fixUpContinuousNodeArray\n      mapData.indexObservable(newMappingResultIndex++);\n      fixUpContinuousNodeArray(mapData.mappedNodes, domNode);\n      newMappingResult.push(mapData);\n      itemsToProcess.push(mapData);\n    }\n\n    function callCallback (callback, items) {\n      if (callback) {\n        for (var i = 0, n = items.length; i < n; i++) {\n          arrayForEach(items[i].mappedNodes, function (node) {\n            callback(node, i, items[i].arrayEntry);\n          });\n        }\n      }\n    }\n\n    if (isFirstExecution) {\n      arrayForEach(array, itemAdded);\n    } else {\n      if (!editScript || (lastMappingResult && lastMappingResult['_countWaitingForRemove'])) {\n        // Compare the provided array against the previous one\n        var lastArray = isFirstExecution ? [] : arrayMap(lastMappingResult, function (x) { return x.arrayEntry });\n        var compareOptions = {\n          'dontLimitMoves': options$$1['dontLimitMoves'],\n          'sparse': true\n        };\n        editScript = compareArrays(lastArray, array, compareOptions);\n      }\n\n      for (var i = 0, editScriptItem, movedIndex, itemIndex; editScriptItem = editScript[i]; i++) {\n        movedIndex = editScriptItem['moved'];\n        itemIndex = editScriptItem['index'];\n        switch (editScriptItem['status']) {\n          case 'deleted':\n            while (lastMappingResultIndex < itemIndex) {\n              itemMovedOrRetained(lastMappingResultIndex++);\n            }\n            if (movedIndex === undefined) {\n              mapData = lastMappingResult[lastMappingResultIndex];\n\n              // Stop tracking changes to the mapping for these nodes\n              if (mapData.dependentObservable) {\n                mapData.dependentObservable.dispose();\n                mapData.dependentObservable = undefined;\n              }\n\n              // Queue these nodes for later removal\n              if (fixUpContinuousNodeArray(mapData.mappedNodes, domNode).length) {\n                if (options$$1['beforeRemove']) {\n                  newMappingResult.push(mapData);\n                  itemsToProcess.push(mapData);\n                  countWaitingForRemove++;\n                  if (mapData.arrayEntry === deletedItemDummyValue) {\n                    mapData = null;\n                  } else {\n                    itemsForBeforeRemoveCallbacks.push(mapData);\n                  }\n                }\n                if (mapData) {\n                  nodesToDelete.push.apply(nodesToDelete, mapData.mappedNodes);\n                }\n              }\n            }\n            lastMappingResultIndex++;\n            break\n\n          case 'added':\n            while (newMappingResultIndex < itemIndex) {\n              itemMovedOrRetained(lastMappingResultIndex++);\n            }\n            if (movedIndex !== undefined) {\n              itemMovedOrRetained(movedIndex);\n            } else {\n              itemAdded(editScriptItem['value']);\n            }\n            break\n        }\n      }\n\n      while (newMappingResultIndex < array.length) {\n        itemMovedOrRetained(lastMappingResultIndex++);\n      }\n\n      // Record that the current view may still contain deleted items\n      // because it means we won't be able to use a provided editScript.\n      newMappingResult['_countWaitingForRemove'] = countWaitingForRemove;\n    }\n\n    // Store a copy of the array items we just considered so we can difference it next time\n    set(domNode, lastMappingResultDomDataKey, newMappingResult);\n\n    // Call beforeMove first before any changes have been made to the DOM\n    callCallback(options$$1['beforeMove'], itemsForMoveCallbacks);\n\n    // Next remove nodes for deleted items (or just clean if there's a beforeRemove callback)\n    arrayForEach(nodesToDelete, options$$1['beforeRemove'] ? cleanNode : removeNode);\n\n    // Next add/reorder the remaining items (will include deleted items if there's a beforeRemove callback)\n    i = 0;\n    for (var nextNode = firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {\n      // Get nodes for newly added items\n      if (!mapData.mappedNodes) { extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable)); }\n\n      // Put nodes in the right place if they aren't there already\n      for (var j = 0; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {\n        if (node !== nextNode) { insertAfter(domNode, node, lastNode); }\n      }\n\n      // Run the callbacks for newly added nodes (for example, to apply bindings, etc.)\n      if (!mapData.initialized && callbackAfterAddingNodes) {\n        callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);\n        mapData.initialized = true;\n      }\n    }\n\n    // If there's a beforeRemove callback, call it after reordering.\n    // Note that we assume that the beforeRemove callback will usually be used to remove the nodes using\n    // some sort of animation, which is why we first reorder the nodes that will be removed. If the\n    // callback instead removes the nodes right away, it would be more efficient to skip reordering them.\n    // Perhaps we'll make that change in the future if this scenario becomes more common.\n    callCallback(options$$1['beforeRemove'], itemsForBeforeRemoveCallbacks);\n\n    // Replace the stored values of deleted items with a dummy value. This provides two benefits: it marks this item\n    // as already \"removed\" so we won't call beforeRemove for it again, and it ensures that the item won't match up\n    // with an actual item in the array and appear as \"retained\" or \"moved\".\n    for (i = 0; i < itemsForBeforeRemoveCallbacks.length; ++i) {\n      itemsForBeforeRemoveCallbacks[i].arrayEntry = deletedItemDummyValue;\n    }\n\n    // Finally call afterMove and afterAdd callbacks\n    callCallback(options$$1['afterMove'], itemsForMoveCallbacks);\n    callCallback(options$$1['afterAdd'], itemsForAfterAddCallbacks);\n  }\n\n  /**\n   * This DescendantBindingHandler is a base class for bindings that control\n   * descendants, such as the `if`, `with`, `component`, `foreach` and `template`\n   * bindings.\n   */\n  class DescendantBindingHandler extends AsyncBindingHandler {\n    get controlsDescendants () { return true }\n\n    async applyBindingsToDescendants (childContext, callback) {\n      const bindingResult = applyBindingsToDescendants(childContext, this.$element);\n      if (bindingResult.isSync) {\n        this.bindingCompletion = bindingResult;\n      } else {\n        await bindingResult.completionPromise;\n      }\n      if (callback) { callback(bindingResult); }\n      this.completeBinding(bindingResult);\n    }\n  }\n\n  // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving\n\n  // ---- ko.templateSources.domElement -----\n\n  // template types\n  var templateScript = 1,\n    templateTextArea = 2,\n    templateTemplate = 3,\n    templateElement = 4;\n\n  function domElement (element) {\n    this.domElement = element;\n\n    if (!element) { return }\n    var tagNameLower$$1 = tagNameLower(element);\n    this.templateType =\n          tagNameLower$$1 === 'script' ? templateScript\n          : tagNameLower$$1 === 'textarea' ? templateTextArea\n              // For browsers with proper <template> element support, where the .content property gives a document fragment\n          : tagNameLower$$1 == 'template' && element.content && element.content.nodeType === 11 ? templateTemplate\n          : templateElement;\n  }\n\n  domElement.prototype.text = function (/* valueToWrite */) {\n    var elemContentsProperty = this.templateType === templateScript ? 'text'\n                               : this.templateType === templateTextArea ? 'value'\n                               : 'innerHTML';\n\n    if (arguments.length == 0) {\n      return this.domElement[elemContentsProperty]\n    } else {\n      var valueToWrite = arguments[0];\n      if (elemContentsProperty === 'innerHTML') { setHtml(this.domElement, valueToWrite); } else { this.domElement[elemContentsProperty] = valueToWrite; }\n    }\n  };\n\n  var dataDomDataPrefix = nextKey() + '_';\n  domElement.prototype.data = function (key /*, valueToWrite */) {\n    if (arguments.length === 1) {\n      return get(this.domElement, dataDomDataPrefix + key)\n    } else {\n      set(this.domElement, dataDomDataPrefix + key, arguments[1]);\n    }\n  };\n\n  var templatesDomDataKey = nextKey();\n  function getTemplateDomData (element) {\n    return get(element, templatesDomDataKey) || {}\n  }\n  function setTemplateDomData (element, data) {\n    set(element, templatesDomDataKey, data);\n  }\n\n  domElement.prototype.nodes = function (/* valueToWrite */) {\n    var element = this.domElement;\n    if (arguments.length == 0) {\n      const templateData = getTemplateDomData(element);\n      let nodes = templateData.containerData || (\n        this.templateType === templateTemplate ? element.content :\n        this.templateType === templateElement ? element :\n        undefined\n      );\n      if (!nodes || templateData.alwaysCheckText) {\n      // If the template is associated with an element that stores the template as text,\n      // parse and cache the nodes whenever there's new text content available. This allows\n      // the user to update the template content by updating the text of template node.\n        const text = this['text']();\n        if (text) {\n          nodes = parseHtmlForTemplateNodes(text, element.ownerDocument);\n          this['text']('');   // clear the text from the node\n          setTemplateDomData(element, {containerData: nodes, alwaysCheckText: true});\n        }\n      }\n\n      return nodes\n    } else {\n      var valueToWrite = arguments[0];\n      setTemplateDomData(element, {containerData: valueToWrite});\n    }\n  };\n\n  // ---- ko.templateSources.anonymousTemplate -----\n  // Anonymous templates are normally saved/retrieved as DOM nodes through \"nodes\".\n  // For compatibility, you can also read \"text\"; it will be serialized from the nodes on demand.\n  // Writing to \"text\" is still supported, but then the template data will not be available as DOM nodes.\n\n  function anonymousTemplate (element) {\n    this.domElement = element;\n  }\n\n  anonymousTemplate.prototype = new domElement();\n  anonymousTemplate.prototype.constructor = anonymousTemplate;\n  anonymousTemplate.prototype.text = function (/* valueToWrite */) {\n    if (arguments.length == 0) {\n      var templateData = getTemplateDomData(this.domElement);\n      if (templateData.textData === undefined && templateData.containerData) { templateData.textData = templateData.containerData.innerHTML; }\n      return templateData.textData\n    } else {\n      var valueToWrite = arguments[0];\n      setTemplateDomData(this.domElement, {textData: valueToWrite});\n    }\n  };\n\n  // If you want to make a custom template engine,\n\n  function templateEngine () { }\n  extend(templateEngine.prototype, {\n    renderTemplateSource: function (templateSource, bindingContext, options$$1, templateDocument) {\n      options$$1.onError('Override renderTemplateSource');\n    },\n\n    createJavaScriptEvaluatorBlock: function (script) {\n      options.onError('Override createJavaScriptEvaluatorBlock');\n    },\n\n    makeTemplateSource: function (template, templateDocument) {\n        // Named template\n      if (typeof template === 'string') {\n        templateDocument = templateDocument || document;\n        var elem = templateDocument.getElementById(template);\n        if (!elem) { options.onError('Cannot find template with ID ' + template); }\n        return new domElement(elem)\n      } else if ((template.nodeType == 1) || (template.nodeType == 8)) {\n            // Anonymous template\n        return new anonymousTemplate(template)\n      } else { options.onError('Unknown template type: ' + template); }\n    },\n\n    renderTemplate: function (template, bindingContext, options$$1, templateDocument) {\n      var templateSource = this['makeTemplateSource'](template, templateDocument);\n      return this.renderTemplateSource(templateSource, bindingContext, options$$1, templateDocument)\n    }\n  });\n\n  var _templateEngine;\n  const cleanContainerDomDataKey = nextKey();\n\n  function setTemplateEngine (tEngine) {\n    if ((tEngine !== undefined) && !(tEngine instanceof templateEngine)) {\n          // TODO: ko.templateEngine to appropriate name\n      throw new Error('templateEngine must inherit from ko.templateEngine')\n    }\n    _templateEngine = tEngine;\n  }\n\n  function invokeForEachNodeInContinuousRange (firstNode, lastNode, action) {\n    let node;\n    let nextInQueue = firstNode;\n    let firstOutOfRangeNode = nextSibling(lastNode);\n    while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {\n      nextInQueue = nextSibling(node);\n      action(node, nextInQueue);\n    }\n  }\n\n  function activateBindingsOnContinuousNodeArray (continuousNodeArray, bindingContext$$1, afterBindingCallback) {\n    // To be used on any nodes that have been rendered by a template and have been inserted into some parent element\n    // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because\n    // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,\n    // (1) Does a regular \"applyBindings\" to associate bindingContext with this node and to activate any non-memoized bindings\n    // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)\n\n    if (continuousNodeArray.length) {\n      var firstNode = continuousNodeArray[0];\n      var lastNode = continuousNodeArray[continuousNodeArray.length - 1];\n      var parentNode = firstNode.parentNode;\n      var provider = options.bindingProviderInstance;\n      var preprocessNode = provider.preprocessNode;\n\n      if (preprocessNode) {\n        invokeForEachNodeInContinuousRange(firstNode, lastNode, function (node, nextNodeInRange) {\n          var nodePreviousSibling = node.previousSibling;\n          var newNodes = preprocessNode.call(provider, node);\n          if (newNodes) {\n            if (node === firstNode) { firstNode = newNodes[0] || nextNodeInRange; }\n            if (node === lastNode) { lastNode = newNodes[newNodes.length - 1] || nodePreviousSibling; }\n          }\n        });\n\n        // Because preprocessNode can change the nodes, including the first and last nodes, update continuousNodeArray to match.\n        // We need the full set, including inner nodes, because the unmemoize step might remove the first node (and so the real\n        // first node needs to be in the array).\n        continuousNodeArray.length = 0;\n        if (!firstNode) { // preprocessNode might have removed all the nodes, in which case there's nothing left to do\n          return\n        }\n        if (firstNode === lastNode) {\n          continuousNodeArray.push(firstNode);\n        } else {\n          continuousNodeArray.push(firstNode, lastNode);\n          fixUpContinuousNodeArray(continuousNodeArray, parentNode);\n        }\n      }\n\n      // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)\n      // whereas a regular applyBindings won't introduce new memoized nodes\n      invokeForEachNodeInContinuousRange(firstNode, lastNode, function (node) {\n        if (node.nodeType === 1 || node.nodeType === 8) { applyBindings(bindingContext$$1, node).then(afterBindingCallback); }\n      });\n      invokeForEachNodeInContinuousRange(firstNode, lastNode, function (node) {\n        if (node.nodeType === 1 || node.nodeType === 8) { unmemoizeDomNodeAndDescendants(node, [bindingContext$$1]); }\n      });\n\n      // Make sure any changes done by applyBindings or unmemoize are reflected in the array\n      fixUpContinuousNodeArray(continuousNodeArray, parentNode);\n    }\n  }\n\n  function getFirstNodeFromPossibleArray (nodeOrNodeArray) {\n    return nodeOrNodeArray.nodeType ? nodeOrNodeArray\n                                      : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]\n                                      : null\n  }\n\n  function executeTemplate (targetNodeOrNodeArray, renderMode, template, bindingContext$$1, options$$1, afterBindingCallback) {\n    options$$1 = options$$1 || {};\n    var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n    var templateDocument = (firstTargetNode || template || {}).ownerDocument;\n    var templateEngineToUse = (options$$1.templateEngine || _templateEngine);\n    var renderedNodesArray = templateEngineToUse.renderTemplate(template, bindingContext$$1, options$$1, templateDocument);\n\n      // Loosely check result is an array of DOM nodes\n    if ((typeof renderedNodesArray.length !== 'number') || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType !== 'number')) { throw new Error('Template engine must return an array of DOM nodes') }\n\n    var haveAddedNodesToParent = false;\n    switch (renderMode) {\n      case 'replaceChildren':\n        setDomNodeChildren$1(targetNodeOrNodeArray, renderedNodesArray);\n        haveAddedNodesToParent = true;\n        break\n      case 'replaceNode':\n        replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);\n        haveAddedNodesToParent = true;\n        break\n      case 'ignoreTargetNode': break\n      default:\n        throw new Error('Unknown renderMode: ' + renderMode)\n    }\n\n    if (haveAddedNodesToParent) {\n      activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext$$1, afterBindingCallback);\n      if (options$$1.afterRender) { ignore(options$$1.afterRender, null, [renderedNodesArray, bindingContext$$1['$data']]); }\n      if (renderMode === 'replaceChildren') {\n        bindingEvent.notify(targetNodeOrNodeArray, bindingEvent.childrenComplete);\n      }\n    }\n\n    return renderedNodesArray\n  }\n\n  function resolveTemplateName (template, data, context) {\n      // The template can be specified as:\n    if (isObservable(template)) {\n      // 1. An observable, with string value\n      return template()\n    } else if (typeof template === 'function') {\n      // 2. A function of (data, context) returning a string\n      return template(data, context)\n    } else {\n      // 3. A string\n      return template\n    }\n  }\n\n  function renderTemplate (template, dataOrBindingContext, options$$1, targetNodeOrNodeArray, renderMode, afterBindingCallback) {\n    options$$1 = options$$1 || {};\n    if ((options$$1.templateEngine || _templateEngine) === undefined) { throw new Error('Set a template engine before calling renderTemplate') }\n    renderMode = renderMode || 'replaceChildren';\n\n    if (targetNodeOrNodeArray) {\n      var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n\n      var whenToDispose = function () { return (!firstTargetNode) || !domNodeIsAttachedToDocument(firstTargetNode) }; // Passive disposal (on next evaluation)\n      var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode === 'replaceNode') ? firstTargetNode.parentNode : firstTargetNode;\n\n      return computed( // So the DOM is automatically updated when any dependency changes\n        function () {\n          // Ensure we've got a proper binding context to work with\n          var bindingContext$$1 = (dataOrBindingContext && (dataOrBindingContext instanceof bindingContext))\n                ? dataOrBindingContext\n                : new bindingContext(dataOrBindingContext, null, null, null, { 'exportDependencies': true });\n\n          var templateName = resolveTemplateName(template, bindingContext$$1.$data, bindingContext$$1);\n          const renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext$$1, options$$1, afterBindingCallback);\n\n          if (renderMode === 'replaceNode') {\n            targetNodeOrNodeArray = renderedNodesArray;\n            firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n          }\n        },\n        null,\n        { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }\n      )\n    } else {\n          // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node\n      return memoize(function (domNode) {\n        renderTemplate(template, dataOrBindingContext, options$$1, domNode, 'replaceNode');\n      })\n    }\n  }\n\n  function renderTemplateForEach (template, arrayOrObservableArray, options$$1, targetNode, parentBindingContext, afterBindingCallback) {\n      // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then\n      // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.\n    var arrayItemContext;\n\n      // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode\n    function executeTemplateForArrayItem (arrayValue, index) {\n      // Support selecting template as a function of the data being rendered\n      if (options$$1.as) {\n        if (options.createChildContextWithAs) {\n          arrayItemContext = parentBindingContext.createChildContext(\n            arrayValue, options$$1.as, context => { context.$index = index; }\n          );\n        } else {\n          arrayItemContext = parentBindingContext.extend({\n            [options$$1.as]: arrayValue,\n            $index: index\n          });\n        }\n      } else {\n        arrayItemContext = parentBindingContext.createChildContext(arrayValue, options$$1.as, context => { context.$index = index; });\n      }\n\n      var templateName = resolveTemplateName(template, arrayValue, arrayItemContext);\n      return executeTemplate(targetNode, 'ignoreTargetNode', templateName, arrayItemContext, options$$1, afterBindingCallback)\n    }\n\n      // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode\n    var activateBindingsCallback = function (arrayValue, addedNodesArray /*, index */) {\n      activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext, afterBindingCallback);\n      if (options$$1.afterRender) { options$$1.afterRender(addedNodesArray, arrayValue); }\n\n          // release the \"cache\" variable, so that it can be collected by\n          // the GC when its value isn't used from within the bindings anymore.\n      arrayItemContext = null;\n    };\n\n    // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).\n    // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.\n    function localSetDomNodeChildrenFromArrayMapping (newArray, changeList) {\n      ignore(setDomNodeChildrenFromArrayMapping, null, [targetNode, newArray, executeTemplateForArrayItem, options$$1, activateBindingsCallback, changeList]);\n      bindingEvent.notify(targetNode, bindingEvent.childrenComplete);\n    }\n\n    const shouldHideDestroyed = (options$$1.includeDestroyed === false) || (options.foreachHidesDestroyed && !options$$1.includeDestroyed);\n    if (!shouldHideDestroyed && !options$$1.beforeRemove && isObservableArray(arrayOrObservableArray)) {\n      localSetDomNodeChildrenFromArrayMapping(arrayOrObservableArray.peek());\n      var subscription = arrayOrObservableArray.subscribe(function (changeList) {\n        localSetDomNodeChildrenFromArrayMapping(arrayOrObservableArray(), changeList);\n      }, null, 'arrayChange');\n      subscription.disposeWhenNodeIsRemoved(targetNode);\n      return subscription\n    } else {\n      return computed(function () {\n        var unwrappedArray = unwrap(arrayOrObservableArray) || [];\n        const unwrappedIsIterable = Symbol.iterator in unwrappedArray;\n        if (!unwrappedIsIterable) { unwrappedArray = [unwrappedArray]; }\n        if (shouldHideDestroyed) {\n          // Filter out any entries marked as destroyed\n          unwrappedArray = arrayFilter(unwrappedArray, function (item) {\n            return item === undefined || item === null || !unwrap(item._destroy);\n          });\n        }\n        localSetDomNodeChildrenFromArrayMapping(unwrappedArray);\n      }, null, { disposeWhenNodeIsRemoved: targetNode })\n    }\n  }\n\n  let templateComputedDomDataKey = nextKey();\n\n  class TemplateBindingHandler extends AsyncBindingHandler {\n    constructor (params) {\n      super(params);\n      const element = this.$element;\n      const bindingValue = unwrap(this.value);\n\n      // Expose 'conditional' for `else` chaining.\n      set(element, 'conditional', {\n        elseChainSatisfied: observable(true)\n      });\n\n      // Support anonymous templates\n      if (typeof bindingValue === 'string' || bindingValue.name) {\n        this.bindNamedTemplate();\n      } else if ('nodes' in bindingValue) {\n        this.bindNodeTemplate(bindingValue.nodes || []);\n      } else {\n        this.bindAnonymousTemplate();\n      }\n    }\n\n    bindNamedTemplate () {\n      // It's a named template - clear the element\n      emptyNode(this.$element);\n    }\n\n    // We've been given an array of DOM nodes. Save them as the template source.\n    // There is no known use case for the node array being an observable array (if the output\n    // varies, put that behavior *into* your template - that's what templates are for), and\n    // the implementation would be a mess, so assert that it's not observable.\n    bindNodeTemplate (nodes) {\n      if (isObservable(nodes)) {\n        throw new Error('The \"nodes\" option must be a plain, non-observable array.')\n      }\n\n      // If the nodes are already attached to a KO-generated container, we reuse that container without moving the\n      // elements to a new one (we check only the first node, as the nodes are always moved together)\n      let container = nodes[0] && nodes[0].parentNode;\n      if (!container || !get(container, cleanContainerDomDataKey)) {\n        container = moveCleanedNodesToContainerElement(nodes);\n        set(container, cleanContainerDomDataKey, true);\n      }\n\n      new anonymousTemplate(this.$element).nodes(container);\n    }\n\n    bindAnonymousTemplate () {\n      // It's an anonymous template - store the element contents, then clear the element\n      const templateNodes = childNodes(this.$element);\n      if (templateNodes.length === 0) {\n        throw new Error('Anonymous template defined, but no template content was provided.')\n      }\n      const container = moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent\n      new anonymousTemplate(this.$element).nodes(container);\n    }\n\n    onValueChange () {\n      const element = this.$element;\n      const bindingContext$$1 = this.$context;\n      var value = this.value;\n      var options$$1 = unwrap(value);\n      var shouldDisplay = true;\n      var templateComputed = null;\n      var elseChainSatisfied = get(element, 'conditional').elseChainSatisfied;\n      var templateName;\n\n      if (typeof options$$1 === 'string') {\n        templateName = value;\n        options$$1 = {};\n      } else {\n        templateName = options$$1.name;\n\n        // Support \"if\"/\"ifnot\" conditions\n        if ('if' in options$$1) {\n          shouldDisplay = unwrap(options$$1.if);\n        }\n\n        if (shouldDisplay && 'ifnot' in options$$1) {\n          shouldDisplay = !unwrap(options$$1.ifnot);\n        }\n      }\n\n      if ('foreach' in options$$1) {\n        // Render once for each data point (treating data set as empty if shouldDisplay==false)\n        var dataArray = (shouldDisplay && options$$1.foreach) || [];\n        templateComputed = renderTemplateForEach(templateName || element, dataArray, options$$1, element, bindingContext$$1, this.completeBinding);\n\n        elseChainSatisfied((unwrap(dataArray) || []).length !== 0);\n      } else if (shouldDisplay) {\n        // Render once for this single data point (or use the viewModel if no data was provided)\n        var innerBindingContext = ('data' in options$$1)\n          ? bindingContext$$1.createStaticChildContext(options$$1.data, options$$1.as)  // Given an explicit 'data' value, we create a child binding context for it\n          : bindingContext$$1;                                                        // Given no explicit 'data' value, we retain the same binding context\n        templateComputed = renderTemplate(templateName || element, innerBindingContext, options$$1, element, undefined, this.completeBinding);\n        elseChainSatisfied(true);\n      } else {\n        emptyNode(element);\n        elseChainSatisfied(false);\n      }\n\n      // It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)\n      this.disposeOldComputedAndStoreNewOne(element, templateComputed);\n    }\n\n    disposeOldComputedAndStoreNewOne (element, newComputed) {\n      let oldComputed = get(element, templateComputedDomDataKey);\n      if (oldComputed && (typeof oldComputed.dispose === 'function')) { oldComputed.dispose(); }\n      set(element, templateComputedDomDataKey, (newComputed && (!newComputed.isActive || newComputed.isActive())) ? newComputed : undefined);\n    }\n\n    get controlsDescendants () { return true }\n    static get allowVirtualElements () { return true }\n  }\n\n  function nativeTemplateEngine () {\n  }\n\n  nativeTemplateEngine.prototype = new templateEngine();\n  nativeTemplateEngine.prototype.constructor = nativeTemplateEngine;\n  nativeTemplateEngine.prototype.renderTemplateSource = function (templateSource, bindingContext, options$$1, templateDocument) {\n    var useNodesIfAvailable = !(ieVersion < 9), // IE<9 cloneNode doesn't work properly\n      templateNodesFunc = useNodesIfAvailable ? templateSource.nodes : null,\n      templateNodes = templateNodesFunc ? templateSource.nodes() : null;\n\n    if (templateNodes) {\n      return makeArray(templateNodes.cloneNode(true).childNodes)\n    } else {\n      var templateText = templateSource.text();\n      return parseHtmlFragment(templateText, templateDocument)\n    }\n  };\n\n  nativeTemplateEngine.instance = new nativeTemplateEngine();\n  setTemplateEngine(nativeTemplateEngine.instance);\n\n  // \"foreach: someExpression\" is equivalent to \"template: { foreach: someExpression }\"\n  // \"foreach: { data: someExpression, afterAdd: myfn }\" is equivalent to \"template: { foreach: someExpression, afterAdd: myfn }\"\n  class TemplateForEachBindingHandler extends TemplateBindingHandler {\n    get value () {\n      const modelValue = this.valueAccessor();\n      const unwrappedValue = peek(modelValue);    // Unwrap without setting a dependency here\n\n          // If unwrappedValue is the array, pass in the wrapped value on its own\n          // The value will be unwrapped and tracked within the template binding\n          // (See https://github.com/SteveSanderson/knockout/issues/523)\n      if (!unwrappedValue || typeof unwrappedValue.length === 'number') {\n        return { foreach: modelValue, templateEngine: nativeTemplateEngine.instance }\n      }\n\n      // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates\n      unwrap(modelValue);\n      return {\n        foreach: unwrappedValue.data,\n        as: unwrappedValue.as,\n        includeDestroyed: unwrappedValue.includeDestroyed,\n        afterAdd: unwrappedValue.afterAdd,\n        beforeRemove: unwrappedValue.beforeRemove,\n        afterRender: unwrappedValue.afterRender,\n        beforeMove: unwrappedValue.beforeMove,\n        afterMove: unwrappedValue.afterMove,\n        templateEngine: nativeTemplateEngine.instance\n      }\n    }\n  }\n\n  //    'let': letBinding,\n  //    template: template,\n\n  const bindings = {\n    foreach: TemplateForEachBindingHandler,\n    template: TemplateBindingHandler\n  };\n\n  /**\n   * A class to create the global knockout instance (ko).\n   */\n\n  const domNodeDisposal = {\n    addDisposeCallback,\n    removeDisposeCallback,\n    removeNode,\n    addCleaner,\n    removeCleaner,\n    get cleanExternalData () {\n      return options.cleanExternalData\n    },\n    set cleanExternalData (cleanerFn) {\n      options.set('cleanExternalData', cleanerFn);\n    }\n  };\n\n  const utils = Object.assign({\n    addOrRemoveItem,\n    arrayFilter,\n    arrayFirst,\n    arrayForEach,\n    arrayGetDistinctValues,\n    arrayIndexOf,\n    arrayMap,\n    arrayPushAll,\n    arrayRemoveItem,\n    cloneNodes,\n    compareArrays,\n    createSymbolOrString,\n    domData,\n    domNodeDisposal,\n    extend,\n    filters: options.filters,\n    objectForEach,\n    objectMap,\n    parseHtmlFragment,\n    parseJson,\n    parseObjectLiteral,\n    peekObservable: peek,\n    range,\n    registerEventHandler,\n    setDomNodeChildrenFromArrayMapping,\n    setHtml,\n    setTextContent,\n    toggleDomNodeCssClass,\n    triggerEvent,\n    unwrapObservable: unwrap\n  });\n\n  const knockout = {\n    // --- Utilities ---\n    cleanNode,\n    dependencyDetection,\n    computedContext: dependencyDetection,\n    filters: options.filters,\n    ignoreDependencies: ignore,\n    memoization,\n    options,\n    removeNode,\n    selectExtensions,\n    tasks,\n    utils,\n    LifeCycle,\n\n      // -- Observable ---\n    isObservable,\n    isSubscribable,\n    isWriteableObservable,\n    isWritableObservable: isWriteableObservable,\n    observable,\n    observableArray,\n    isObservableArray,\n    peek,\n    subscribable,\n    unwrap,\n    toJS,\n    toJSON,\n    proxy,\n\n      // ... Computed ...\n    computed,\n    dependentObservable: computed,\n    isComputed,\n    isPureComputed,\n    pureComputed,\n    when: when,\n\n      // --- Templates ---\n    nativeTemplateEngine,\n    renderTemplate,\n    setTemplateEngine,\n    templateEngine,\n    templateSources: { domElement, anonymousTemplate },\n\n      // --- Binding ---\n    applyBindingAccessorsToNode,\n    applyBindings,\n    applyBindingsToDescendants,\n    applyBindingsToNode,\n    contextFor,\n    dataFor,\n    BindingHandler,\n    AsyncBindingHandler,\n    virtualElements,\n    domNodeDisposal,\n    bindingEvent,\n  };\n\n  class Builder {\n    constructor ({ provider, bindings: bindings$$1, extenders: extenders$$1, filters, options: options$$1 }) {\n      Object.assign(knockout.options, options$$1, {\n        filters,\n        bindingProviderInstance: provider\n      });\n\n      provider.setGlobals(knockout.options.bindingGlobals);\n\n      if (Array.isArray(bindings$$1)) {\n        for (const bindingsObject of bindings$$1) {\n          provider.bindingHandlers.set(bindingsObject);\n        }\n      } else {\n        provider.bindingHandlers.set(bindings$$1);\n      }\n\n      this.providedProperties = {\n        extenders: Object.assign(extenders, extenders$$1),\n        bindingHandlers: provider.bindingHandlers,\n        bindingProvider: provider\n      };\n    }\n\n    /**\n     * @return {Object} An instance of Knockout.\n     */\n    create (...additionalProperties) {\n      const instance = Object.assign({\n        get getBindingHandler () { return options.getBindingHandler },\n        set getBindingHandler (fn) { options.set('getBindingHandler', fn); }\n      },\n      knockout,\n      this.providedProperties,\n      ...additionalProperties);\n      instance.options.knockoutInstance = instance;\n      return instance\n    }\n  }\n\n  class BindingHandlerObject {\n    set (nameOrObject, value) {\n      if (typeof nameOrObject === 'string') {\n        this[nameOrObject] = value;\n      } else if (typeof nameOrObject === 'object') {\n        if (value !== undefined) {\n          options.onError(\n            new Error('Given extraneous `value` parameter (first param should be a string, but it was an object).' + nameOrObject));\n        }\n        Object.assign(this, nameOrObject);\n      } else {\n        options.onError(\n          new Error('Given a bad binding handler type: ' + nameOrObject));\n      }\n    }\n\n    /**\n     * The handler may have a `.` in it, e.g. `attr.title`, in which case the\n     * handler is `attr`.  Otherwise it's the name given\n     */\n    get (nameOrDotted) {\n      const [name] = nameOrDotted.split('.');\n      return this[name]\n    }\n  }\n\n  class Provider {\n    constructor (params = {}) {\n      if (this.constructor === Provider) {\n        throw new Error('Provider is an abstract base class.')\n      }\n      if (!('FOR_NODE_TYPES' in this)) {\n        // FOR_NODE_TYPES must return a list of integers corresponding to the\n        // node.nodeType's that the provider handles.\n        throw new Error('Providers must have FOR_NODE_TYPES property')\n      }\n      this.bindingHandlers = params.bindingHandlers || new BindingHandlerObject();\n      this.globals = params.globals || {};\n    }\n\n    setGlobals (globals) {\n      this.globals = globals;\n    }\n    get preemptive () { return false }\n    nodeHasBindings (/* node */) {}\n    getBindingAccessors (/* node, context */) {}\n\n    /**\n     * Preprocess a given node.\n     * @param {HTMLElement} node\n     * @returns {[HTMLElement]|undefined}\n     */\n    preprocessNode (node) {}\n    postProcess (/* node */) {}\n\n    /** For legacy binding provider assignments to\n     *  ko.bindingProvider.instance = ... */\n    get instance () { return this._overloadInstance || this }\n    set instance (provider) {\n      if (!provider || provider === this) {\n        this._overloadInstance = undefined;\n      } else {\n        this._overloadInstance = new LegacyProvider(provider, this);\n      }\n    }\n\n    // Given a function that returns bindings, create and return a new object that contains\n    // binding value-accessors functions. Each accessor function calls the original function\n    // so that it always gets the latest value and all dependencies are captured. This is used\n    // by ko.applyBindingsToNode and getBindingsAndMakeAccessors.\n    makeAccessorsFromFunction (callback) {\n      return objectMap(ignore(callback),\n        (value, key) => () => callback()[key]\n      )\n    }\n\n    // Returns the valueAccessor function for a binding value\n    makeValueAccessor (value) {\n      return () => value\n    }\n\n    // Given a bindings function or object, create and return a new object that contains\n    // binding value-accessors functions. This is used by ko.applyBindingsToNode.\n    makeBindingAccessors (bindings, context, node) {\n      if (typeof bindings === 'function') {\n        return this.makeAccessorsFromFunction(bindings.bind(null, context, node))\n      } else {\n        return objectMap(bindings, this.makeValueAccessor)\n      }\n    }\n  }\n\n  /**\n   * LegacyProvider class is created when ko.bindingProvider.instance assigned to\n   * an object that were once used for binding pre-4.0 binding providers e.g.\n   * {  getBindings: function () { ... },\n   *    nodeHasBindings: function () { ... }\n   *    preprocessNode: function () { ... }\n   * }\n   */\n  class LegacyProvider extends Provider {\n    get FOR_NODE_TYPES () { return [1, 3, 8] }\n\n    constructor (providerObject, parentProvider) {\n      super();\n      Object.assign(this, {providerObject});\n      this.bindingHandlers = providerObject.bindingHandlers || parentProvider.bindingHandlers;\n    }\n\n    // This function is used if the binding provider doesn't include a getBindingAccessors function.\n    // It must be called with 'this' set to the provider instance.\n    getBindingsAndMakeAccessors (node, context) {\n      const bindingsFn = this.providerObject.getBindings.bind(this.providerObject, node, context);\n      return this.makeAccessorsFromFunction(bindingsFn)\n    }\n\n    getBindingAccessors (node, context) {\n      return this.providerObject.getBindingAccessors\n        ? this.providerObject.getBindingAccessors(node, context)\n        : this.getBindingsAndMakeAccessors(node, context)\n    }\n\n    nodeHasBindings (node) {\n      return this.providerObject.nodeHasBindings(node)\n    }\n\n    preprocessNode (node) {\n      if (this.providerObject.preprocessNode) {\n        return this.providerObject.preprocessNode(node)\n      }\n    }\n  }\n\n  /**\n   * BindingStringProvider is an abstract base class parses a binding string.\n   *\n   * Children must implement `nodeHasBindings` and `getBindingString`.\n   */\n  class BindingStringProvider extends Provider {\n    /** Call bindingHandler.preprocess on each respective binding string.\n     *\n     * The `preprocess` property of bindingHandler must be a static\n     * function (i.e. on the object or constructor).\n     */\n    * processBinding (key, value) {\n      // Get the \"on\" binding from \"on.click\"\n      const [handlerName, property] = key.split('.');\n      const handler = this.bindingHandlers.get(handlerName);\n\n      if (handler && handler.preprocess) {\n        const bindingsAddedByHandler = [];\n        const chainFn = (...args) => bindingsAddedByHandler.push(args);\n        value = handler.preprocess(value, key, chainFn);\n        for (const [key, value] of bindingsAddedByHandler) {\n          yield * this.processBinding(key, value);\n        }\n      } else if (property) {\n        value = `{${property}:${value}}`;\n      }\n\n      yield `'${handlerName}':${value}`;\n    }\n\n    * generateBindingString (bindingStringOrObjects) {\n      const bindingObjectsArray = typeof bindingStringOrObjects === 'string'\n        ? parseObjectLiteral(bindingStringOrObjects) : bindingStringOrObjects;\n      for (const {key, unknown, value} of bindingObjectsArray) {\n        yield * this.processBinding(key || unknown, value);\n      }\n    }\n\n    preProcessBindings (bindingStringOrObjects) {\n      return Array.from(this.generateBindingString(bindingStringOrObjects))\n        .join(',')\n    }\n\n    getBindingAccessors (node, context) {\n      const bindingString = node && this.getBindingString(node);\n      if (!bindingString) { return }\n      const processed = this.preProcessBindings(bindingString);\n      return new Parser().parse(processed, context, this.globals, node)\n    }\n\n    getBindingString () { throw new Error('Overload getBindingString.') }\n  }\n\n  class VirtualProvider extends BindingStringProvider {\n    get FOR_NODE_TYPES () { return [ 1, 8 ] }\n\n    /**\n     * Convert <ko binding='...'> into <!-- ko binding: ... -->\n     * @param {HTMLElement} node\n     */\n    preprocessNode (node) {\n      if (node.tagName === 'KO') {\n        const parent = node.parentNode;\n        const childNodes$$1 = [...node.childNodes];\n        const virtualBindingString = [...this.genElementBindingStrings(node)].join(',');\n        const openNode = document.createComment('ko ' + virtualBindingString);\n        const closeNode = document.createComment('/ko');\n        parent.insertBefore(openNode, node);\n        for (const child of childNodes$$1) {\n          parent.insertBefore(child, node);\n        }\n        parent.insertBefore(closeNode, node);\n        node.remove();\n        return [openNode, ...childNodes$$1, closeNode]\n      }\n    }\n\n    * genElementBindingStrings (node) {\n      for (const {name, value} of node.attributes) {\n        yield `${name.replace(/^ko-/, '')}: ${value}`;\n      }\n    }\n\n    getBindingString (node) {\n      if (node.nodeType === document.COMMENT_NODE) {\n        return virtualNodeBindingValue(node)\n      }\n    }\n\n    nodeHasBindings (node) {\n      if (node.nodeType === document.COMMENT_NODE) {\n        return isStartComment(node)\n      }\n    }\n  }\n\n  class DataBindProvider extends BindingStringProvider {\n    get FOR_NODE_TYPES () { return [ 1 ] } // document.ELEMENT_NODE\n\n    get BIND_ATTRIBUTE () {\n      return 'data-bind'\n    }\n\n    getBindingString (node) {\n      if (node.nodeType === document.ELEMENT_NODE) {\n        return node.getAttribute(this.BIND_ATTRIBUTE)\n      }\n    }\n\n    nodeHasBindings (node) {\n      if (node.nodeType === document.ELEMENT_NODE) {\n        return node.hasAttribute(this.BIND_ATTRIBUTE)\n      }\n    }\n  }\n\n  var loadingSubscribablesCache = {}, // Tracks component loads that are currently in flight\n    loadedDefinitionsCache = {};    // Tracks component loads that have already completed\n\n  function loadComponentAndNotify (componentName, callback) {\n    var _subscribable = getObjectOwnProperty(loadingSubscribablesCache, componentName),\n      completedAsync;\n    if (!_subscribable) {\n          // It's not started loading yet. Start loading, and when it's done, move it to loadedDefinitionsCache.\n      _subscribable = loadingSubscribablesCache[componentName] = new subscribable();\n      _subscribable.subscribe(callback);\n\n      beginLoadingComponent(componentName, function (definition, config) {\n        var isSynchronousComponent = !!(config && config.synchronous);\n        loadedDefinitionsCache[componentName] = { definition: definition, isSynchronousComponent: isSynchronousComponent };\n        delete loadingSubscribablesCache[componentName];\n\n              // For API consistency, all loads complete asynchronously. However we want to avoid\n              // adding an extra task schedule if it's unnecessary (i.e., the completion is already\n              // async).\n              //\n              // You can bypass the 'always asynchronous' feature by putting the synchronous:true\n              // flag on your component configuration when you register it.\n        if (completedAsync || isSynchronousComponent) {\n                  // Note that notifySubscribers ignores any dependencies read within the callback.\n                  // See comment in loaderRegistryBehaviors.js for reasoning\n          _subscribable.notifySubscribers(definition);\n        } else {\n          schedule(function () {\n            _subscribable.notifySubscribers(definition);\n          });\n        }\n      });\n      completedAsync = true;\n    } else {\n      _subscribable.subscribe(callback);\n    }\n  }\n\n  function beginLoadingComponent (componentName, callback) {\n    getFirstResultFromLoaders('getConfig', [componentName], function (config) {\n      if (config) {\n              // We have a config, so now load its definition\n        getFirstResultFromLoaders('loadComponent', [componentName, config], function (definition) {\n          callback(definition, config);\n        });\n      } else {\n              // The component has no config - it's unknown to all the loaders.\n              // Note that this is not an error (e.g., a module loading error) - that would abort the\n              // process and this callback would not run. For this callback to run, all loaders must\n              // have confirmed they don't know about this component.\n        callback(null, null);\n      }\n    });\n  }\n\n  function getFirstResultFromLoaders (methodName, argsExceptCallback, callback, candidateLoaders) {\n      // On the first call in the stack, start with the full set of loaders\n    if (!candidateLoaders) {\n      candidateLoaders = registry.loaders.slice(0); // Use a copy, because we'll be mutating this array\n    }\n\n      // Try the next candidate\n    var currentCandidateLoader = candidateLoaders.shift();\n    if (currentCandidateLoader) {\n      var methodInstance = currentCandidateLoader[methodName];\n      if (methodInstance) {\n        var wasAborted = false,\n          synchronousReturnValue = methodInstance.apply(currentCandidateLoader, argsExceptCallback.concat(function (result) {\n            if (wasAborted) {\n              callback(null);\n            } else if (result !== null) {\n                          // This candidate returned a value. Use it.\n              callback(result);\n            } else {\n                          // Try the next candidate\n              getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);\n            }\n          }));\n\n              // Currently, loaders may not return anything synchronously. This leaves open the possibility\n              // that we'll extend the API to support synchronous return values in the future. It won't be\n              // a breaking change, because currently no loader is allowed to return anything except undefined.\n        if (synchronousReturnValue !== undefined) {\n          wasAborted = true;\n\n                  // Method to suppress exceptions will remain undocumented. This is only to keep\n                  // KO's specs running tidily, since we can observe the loading got aborted without\n                  // having exceptions cluttering up the console too.\n          if (!currentCandidateLoader.suppressLoaderExceptions) {\n            throw new Error('Component loaders must supply values by invoking the callback, not by returning values synchronously.')\n          }\n        }\n      } else {\n              // This candidate doesn't have the relevant handler. Synchronously move on to the next one.\n        getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);\n      }\n    } else {\n          // No candidates returned a value\n      callback(null);\n    }\n  }\n\n  var registry = {\n    get (componentName, callback) {\n      var cachedDefinition = getObjectOwnProperty(loadedDefinitionsCache, componentName);\n      if (cachedDefinition) {\n        // It's already loaded and cached. Reuse the same definition object.\n        // Note that for API consistency, even cache hits complete asynchronously by default.\n        // You can bypass this by putting synchronous:true on your component config.\n        if (cachedDefinition.isSynchronousComponent) {\n          ignore(function () { // See comment in loaderRegistryBehaviors.js for reasoning\n            callback(cachedDefinition.definition);\n          });\n        } else {\n          schedule(function () { callback(cachedDefinition.definition); });\n        }\n      } else {\n        // Join the loading process that is already underway, or start a new one.\n        loadComponentAndNotify(componentName, callback);\n      }\n    },\n\n    clearCachedDefinition (componentName) {\n      delete loadedDefinitionsCache[componentName];\n    },\n\n    _getFirstResultFromLoaders: getFirstResultFromLoaders,\n\n    loaders: []\n  };\n\n  // The default loader is responsible for two things:\n  // 1. Maintaining the default in-memory registry of component configuration objects\n  //    (i.e., the thing you're writing to when you call ko.components.register(someName, ...))\n  // 2. Answering requests for components by fetching configuration objects\n  //    from that default in-memory registry and resolving them into standard\n  //    component definition objects (of the form { createViewModel: ..., template: ... })\n  // Custom loaders may override either of these facilities, i.e.,\n  // 1. To supply configuration objects from some other source (e.g., conventions)\n  // 2. Or, to resolve configuration objects by loading viewmodels/templates via arbitrary logic.\n\n  var defaultConfigRegistry = {};\n  const VIEW_MODEL_FACTORY = Symbol('Knockout View Model ViewModel factory');\n\n  function register (componentName, config) {\n    if (!config) {\n      throw new Error('Invalid configuration for ' + componentName)\n    }\n\n    if (isRegistered(componentName)) {\n      throw new Error('Component ' + componentName + ' is already registered')\n    }\n\n    const ceok = componentName.includes('-') && componentName.toLowerCase() === componentName;\n\n    if (!config.ignoreCustomElementWarning && !ceok) {\n      console.log(`\nðŸ¥Š  Knockout warning: components for custom elements must be lowercase and contain a dash.  To ignore this warning, add to the 'config' of .register(componentName, config):\n\n          ignoreCustomElementWarning: true\n    `);\n    }\n\n    defaultConfigRegistry[componentName] = config;\n  }\n\n  function isRegistered (componentName) {\n    return hasOwnProperty(defaultConfigRegistry, componentName)\n  }\n\n  function unregister (componentName) {\n    delete defaultConfigRegistry[componentName];\n    registry.clearCachedDefinition(componentName);\n  }\n\n  var defaultLoader = {\n    getConfig: function (componentName, callback) {\n      var result = hasOwnProperty(defaultConfigRegistry, componentName)\n              ? defaultConfigRegistry[componentName]\n              : null;\n      callback(result);\n    },\n\n    loadComponent: function (componentName, config, callback) {\n      var errorCallback = makeErrorCallback(componentName);\n      possiblyGetConfigFromAmd(errorCallback, config, function (loadedConfig) {\n        resolveConfig(componentName, errorCallback, loadedConfig, callback);\n      });\n    },\n\n    loadTemplate: function (componentName, templateConfig, callback) {\n      resolveTemplate(makeErrorCallback(componentName), templateConfig, callback);\n    },\n\n    loadViewModel: function (componentName, viewModelConfig, callback) {\n      resolveViewModel(makeErrorCallback(componentName), viewModelConfig, callback);\n    }\n  };\n\n  var createViewModelKey = 'createViewModel';\n\n  // Takes a config object of the form { template: ..., viewModel: ... }, and asynchronously convert it\n  // into the standard component definition format:\n  //    { template: <ArrayOfDomNodes>, createViewModel: function(params, componentInfo) { ... } }.\n  // Since both template and viewModel may need to be resolved asynchronously, both tasks are performed\n  // in parallel, and the results joined when both are ready. We don't depend on any promises infrastructure,\n  // so this is implemented manually below.\n  function resolveConfig (componentName, errorCallback, config, callback) {\n    var result = {},\n      makeCallBackWhenZero = 2,\n      tryIssueCallback = function () {\n        if (--makeCallBackWhenZero === 0) {\n          callback(result);\n        }\n      },\n      templateConfig = config['template'],\n      viewModelConfig = config['viewModel'];\n\n    if (templateConfig) {\n      possiblyGetConfigFromAmd(errorCallback, templateConfig, function (loadedConfig) {\n        registry._getFirstResultFromLoaders('loadTemplate', [componentName, loadedConfig], function (resolvedTemplate) {\n          result['template'] = resolvedTemplate;\n          tryIssueCallback();\n        });\n      });\n    } else {\n      tryIssueCallback();\n    }\n\n    if (viewModelConfig) {\n      possiblyGetConfigFromAmd(errorCallback, viewModelConfig, function (loadedConfig) {\n        registry._getFirstResultFromLoaders('loadViewModel', [componentName, loadedConfig], function (resolvedViewModel) {\n          result[createViewModelKey] = resolvedViewModel;\n          tryIssueCallback();\n        });\n      });\n    } else {\n      tryIssueCallback();\n    }\n  }\n\n  function resolveTemplate (errorCallback, templateConfig, callback) {\n    if (typeof templateConfig === 'string') {\n          // Markup - parse it\n      callback(parseHtmlFragment(templateConfig));\n    } else if (templateConfig instanceof Array) {\n          // Assume already an array of DOM nodes - pass through unchanged\n      callback(templateConfig);\n    } else if (isDocumentFragment(templateConfig)) {\n          // Document fragment - use its child nodes\n      callback(makeArray(templateConfig.childNodes));\n    } else if (templateConfig.element) {\n      var element = templateConfig.element;\n      if (isDomElement(element)) {\n              // Element instance - copy its child nodes\n        callback(cloneNodesFromTemplateSourceElement(element));\n      } else if (typeof element === 'string') {\n              // Element ID - find it, then copy its child nodes\n        var elemInstance = document.getElementById(element);\n        if (elemInstance) {\n          callback(cloneNodesFromTemplateSourceElement(elemInstance));\n        } else {\n          errorCallback('Cannot find element with ID ' + element);\n        }\n      } else {\n        errorCallback('Unknown element type: ' + element);\n      }\n    } else if (templateConfig.elementName) {\n      // JSX in the style of babel-plugin-transform-jsx\n      callback(templateConfig);\n    } else {\n      errorCallback('Unknown template value: ' + templateConfig);\n    }\n  }\n\n  function resolveViewModel (errorCallback, viewModelConfig, callback) {\n    if (viewModelConfig[VIEW_MODEL_FACTORY]) {\n      callback((...args) => viewModelConfig[VIEW_MODEL_FACTORY](...args));\n    } else if (typeof viewModelConfig === 'function') {\n          // Constructor - convert to standard factory function format\n          // By design, this does *not* supply componentInfo to the constructor, as the intent is that\n          // componentInfo contains non-viewmodel data (e.g., the component's element) that should only\n          // be used in factory functions, not viewmodel constructors.\n      callback(function (params /*, componentInfo */) {\n        return new viewModelConfig(params)\n      });\n    } else if (typeof viewModelConfig[createViewModelKey] === 'function') {\n          // Already a factory function - use it as-is\n      callback(viewModelConfig[createViewModelKey]);\n    } else if ('instance' in viewModelConfig) {\n          // Fixed object instance - promote to createViewModel format for API consistency\n      var fixedInstance = viewModelConfig['instance'];\n      callback(function (/* params, componentInfo */) {\n        return fixedInstance\n      });\n    } else if ('viewModel' in viewModelConfig) {\n          // Resolved AMD module whose value is of the form { viewModel: ... }\n      resolveViewModel(errorCallback, viewModelConfig['viewModel'], callback);\n    } else {\n      errorCallback('Unknown viewModel value: ' + viewModelConfig);\n    }\n  }\n\n  function cloneNodesFromTemplateSourceElement (elemInstance) {\n    switch (tagNameLower(elemInstance)) {\n      case 'script':\n        return parseHtmlFragment(elemInstance.text)\n      case 'textarea':\n        return parseHtmlFragment(elemInstance.value)\n      case 'template':\n          // For browsers with proper <template> element support (i.e., where the .content property\n          // gives a document fragment), use that document fragment.\n        if (isDocumentFragment(elemInstance.content)) {\n          return cloneNodes(elemInstance.content.childNodes)\n        }\n    }\n\n      // Regular elements such as <div>, and <template> elements on old browsers that don't really\n      // understand <template> and just treat it as a regular container\n    return cloneNodes(elemInstance.childNodes)\n  }\n\n  function possiblyGetConfigFromAmd (errorCallback, config, callback) {\n    if (typeof config.require === 'string') {\n          // The config is the value of an AMD module\n      if (window.amdRequire || window.require) {\n        (window.amdRequire || window.require)([config.require], callback);\n      } else {\n        errorCallback('Uses require, but no AMD loader is present');\n      }\n    } else {\n      callback(config);\n    }\n  }\n\n  function makeErrorCallback (componentName) {\n    return function (message) {\n      throw new Error('Component \\'' + componentName + '\\': ' + message)\n    }\n  }\n\n  // By default, the default loader is the only registered component loader\n  registry.loaders.push(defaultLoader);\n\n  /**\n   * Component --- Abstract Base Class\n   *\n   * This simplifies and compartmentalizes Components.  Use this:\n   *\n   *    class CompX extends ComponentABC {\n   *    \tstatic get element () { return 'comp-x-id' }\n   *    \tstatic get sync () { return false }\n   *    \tstatic get elementName () { return 'comp-x' }\n   *    }\n   *    CompX.register()\n   *\n   * instead of:\n   *\n   *   class CompX {}\n   *\n   *   ko.components.register('comp-x', {\n   *     viewModel: CompX,\n   *     synchronous: false,\n   *     template: { element: 'comp-x' }\n   *   })\n   *\n   * As well, gain all the benefits of a LifeCycle, namely automated\n   * event and subscription addition/removal.\n   *\n   * NOTE: A Component created this way can add events to the component node\n   * with `this.addEventListener(type, action)`.\n   */\n\n  class ComponentABC extends LifeCycle {\n  \t/**\n     * The tag name of the custom element.  For example 'my-component'.\n     * By default converts the class name from camel case to kebab case.\n  \t * @return {string} The custom node name of this component.\n  \t */\n    static get customElementName () {\n      return this.name.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()\n    }\n\n  \t/**\n  \t * Overload this to return:\n  \t * 1. A string of markup\n  \t * 2. An array of DOM nodes\n  \t * 3. A document fragment\n  \t * 4. An AMD module (with `{require: 'some/template'}`)\n  \t * @return {mixed} One of the accepted template types for the ComponentBinding.\n  \t */\n    static get template () {\n      if ('template' in this.prototype) { return }\n      return { element: this.element }\n    }\n\n  \t/**\n  \t * This is called by the default `template`.  Overload this to return:\n  \t * 1. The element ID\n  \t * 2. A DOM node itself\n  \t * @return {string|HTMLElement} either the element ID or actual element.\n  \t */\n    static get element () {\n      throw new Error('[ComponentABC] `element` must be overloaded.')\n    }\n\n  \t/**\n  \t * @return {bool} True if the component shall load synchronously\n  \t */\n    static get sync () { return true }\n\n    /**\n     * Construct a new instance of the model.  When using ComponentABC as a\n     * base class, we do pass in the $element and $componentTemplateNodes.\n     * @param {Object} params\n     * @param {{element: HTMLElement, templateNodes: [HTMLElement]}} componentInfo\n     */\n    static [VIEW_MODEL_FACTORY] (params, componentInfo) {\n      return new this(params, componentInfo)\n    }\n\n    static register (name = this.customElementName) {\n      const viewModel = this;\n      const {template} = this;\n      const synchronous = this.sync;\n      register(name, { viewModel, template, synchronous });\n    }\n  }\n\n  var registry$1 = {\n    ComponentABC,\n    // -- Registry --\n    get: registry.get,\n    clearCachedDefinition: registry.clearCachedDefinition,\n\n    // -- Loader --\n    register,\n    isRegistered,\n    unregister,\n    defaultLoader,\n    // \"Privately\" expose the underlying config registry for use in old-IE shim\n    _allRegisteredComponents: defaultConfigRegistry,\n\n    get loaders () { return registry.loaders },\n    set loaders (loaders) { registry.loaders = loaders; }\n  }\n\n  class ComponentProvider extends Provider {\n    get FOR_NODE_TYPES () { return [ 1 ] } // document.ELEMENT_NODE\n\n    /**\n     * Convert <slot name='X'> to <!-- ko slot: 'X' --><!-- /ko -->\n     * @param {HTMLElement} node\n     */\n    preprocessNode (node) {\n      if (node.tagName === 'SLOT') {\n        const parent = node.parentNode;\n        const slotName = node.getAttribute('name') || '';\n        const openNode = document.createComment(`ko slot: \"${slotName}\"`);\n        const closeNode = document.createComment('/ko');\n        parent.insertBefore(openNode, node);\n        parent.insertBefore(closeNode, node);\n        parent.removeChild(node);\n        return [openNode, closeNode]\n      }\n    }\n\n    nodeHasBindings (node) {\n      return Boolean(this.getComponentNameForNode(node))\n    }\n\n    getBindingAccessors (node, context) {\n      const componentName = this.getComponentNameForNode(node);\n      if (!componentName) { return }\n      const component = () => ({\n        name: componentName,\n        params: this.getComponentParams(node, context)\n      });\n      return { component }\n    }\n\n    getComponentNameForNode (node) {\n      if (node.nodeType !== node.ELEMENT_NODE) { return }\n      const tagName = tagNameLower(node);\n      if (registry$1.isRegistered(tagName)) {\n        const hasDash = tagName.includes('-');\n        const isUnknownEntity = ('' + node) === '[object HTMLUnknownElement]';\n        if (hasDash || isUnknownEntity) { return tagName }\n      }\n    }\n\n    getComponentParams (node, context) {\n      const parser = new Parser(node, context, this.globals);\n      const paramsString = (node.getAttribute('params') || '').trim();\n      const accessors = parser.parse(paramsString, context, node);\n      if (!accessors || Object.keys(accessors).length === 0) {\n        return { $raw: {} }\n      }\n      const $raw = objectMap(accessors,\n        (value) => computed(value, null, { disposeWhenNodeIsRemoved: node })\n      );\n      const params = objectMap($raw, (v) => this.makeParamValue(node, v));\n      return Object.assign({ $raw }, params)\n    }\n\n    makeParamValue (node, paramValueComputed) {\n      const paramValue = paramValueComputed.peek();\n      // Does the evaluation of the parameter value unwrap any observables?\n      if (!paramValueComputed.isActive()) {\n        // No it doesn't, so there's no need for any computed wrapper. Just pass through the supplied value directly.\n        // Example: \"someVal: firstName, age: 123\" (whether or not firstName is an observable/computed)\n        return paramValue\n      }\n      // Yes it does. Supply a computed property that unwraps both the outer (binding expression)\n      // level of observability, and any inner (resulting model value) level of observability.\n      // This means the component doesn't have to worry about multiple unwrapping. If the value is a\n      // writable observable, the computed will also be writable and pass the value on to the observable.\n      const isWriteable = isWriteableObservable(paramValue);\n\n      return computed({\n        read: () => unwrap(paramValueComputed()),\n        write: isWriteable ? (v) => paramValueComputed()(v) : null,\n        disposeWhenNodeIsRemoved: node\n      })\n    }\n  }\n\n  /**\n   * Convert attributes with ko-* to bindings.\n   *\n   * e.g.\n   * <div ko-visible='value'></div>\n   */\n  class AttrProvider extends Provider {\n    get FOR_NODE_TYPES () { return [ 1 ] } // document.ELEMENT_NODE\n\n    get PREFIX () { return 'ko-' }\n\n    getBindingAttributesList (node) {\n      if (!node.hasAttributes()) { return [] }\n      return Array.from(node.attributes)\n        .filter(attr => attr.name.startsWith(this.PREFIX))\n    }\n\n    nodeHasBindings (node) {\n      return this.getBindingAttributesList(node).length > 0\n    }\n\n    getBindingAccessors (node, context) {\n      return Object.assign({}, ...this.handlersFromAttributes(node, context))\n    }\n\n    * handlersFromAttributes (node, context) {\n      for (const attr of this.getBindingAttributesList(node)) {\n        const name = attr.name.substr(this.PREFIX.length);\n        yield {[name]: () => this.getValue(attr.value, context, node)};\n      }\n    }\n\n    getValue (token, $context, node) {\n      /* FIXME: This duplicates Identifier.prototype.lookup_value; it should\n         be refactored into e.g. a BindingContext method */\n      if (!token) { return }\n      const $data = $context.$data;\n\n      switch (token) {\n        case '$element': return node\n        case '$context': return $context\n        case 'this': case '$data': return $context.$data\n      }\n\n      if ($data instanceof Object && token in $data) { return $data[token] }\n      if (token in $context) { return $context[token] }\n      if (token in this.globals) { return this.globals[token] }\n\n      throw new Error(`The variable '${token} not found.`)\n    }\n  }\n\n  class MultiProvider extends Provider {\n    get FOR_NODE_TYPES () { return this.nodeTypes }\n\n    constructor (params = {}) {\n      super(params);\n      const providers = params.providers || [];\n      this.nodeTypeMap = {};\n      this.nodeTypes = [];\n      this.providers = [];\n      providers.forEach(p => this.addProvider(p));\n    }\n\n    setGlobals (globals) {\n      [this, ...this.providers].forEach(p => (p.globals = globals));\n    }\n\n    addProvider (provider) {\n      this.providers.push(provider);\n      provider.bindingHandlers = this.bindingHandlers;\n      provider.globals = this.globals;\n      const nodeTypeMap = this.nodeTypeMap;\n      for (const nodeType of provider.FOR_NODE_TYPES) {\n        if (!nodeTypeMap[nodeType]) { nodeTypeMap[nodeType] = []; }\n        nodeTypeMap[nodeType].push(provider);\n      }\n      this.nodeTypes = Object.keys(this.nodeTypeMap).map(k => parseInt(k, 10));\n    }\n\n    providersFor (node) {\n      return this.nodeTypeMap[node.nodeType] || []\n    }\n\n    nodeHasBindings (node) {\n      return this.providersFor(node).some(p => p.nodeHasBindings(node))\n    }\n\n    preprocessNode (node) {\n      for (const provider of this.providersFor(node)) {\n        const newNodes = provider.preprocessNode(node);\n        if (newNodes) { return newNodes }\n      }\n    }\n\n    * enumerateProviderBindings (node, ctx) {\n      for (const provider of this.providersFor(node)) {\n        const bindings = provider.getBindingAccessors(node, ctx);\n        if (!bindings) { continue }\n        yield * Object.entries(bindings || {});\n        if (provider.preemptive) { return }\n      }\n    }\n\n    getBindingAccessors (node, ctx) {\n      const bindings = {};\n      for (const [key, accessor] of this.enumerateProviderBindings(node, ctx)) {\n        if (key in bindings) {\n          throw new Error(`The binding \"${key}\" is duplicated by multiple providers`)\n        }\n        bindings[key] = accessor;\n      }\n      return bindings\n    }\n  }\n\n  const INNER_EXPRESSION = /^([\\s\\S]*)}}([\\s\\S]*?)\\{\\{([\\s\\S]*)$/;\n  const OUTER_EXPRESSION = /^([\\s\\S]*?)\\{\\{([\\s\\S]*)}}([\\s\\S]*)$/;\n  const BINDING_EXPRESSION = /^([^,\"'{}()/:[\\]\\s]+)\\s+([^\\s:].*)/;\n\n  class Interpolated {\n    constructor (text) {\n      this.text = text;\n    }\n\n    trim (string) {\n      return string === null ? '' : string.trim()\n    }\n  }\n\n  class Expression$1 extends Interpolated {\n    asAttr (context, globals, node) {\n      return new Parser().parseExpression(this.text, context, globals, node)()\n    }\n\n    * textNodeReplacement (textNode) {\n      const text = this.trim(this.text);\n      const ownerDocument = textNode ? textNode.ownerDocument : document;\n      const firstChar = text[0];\n      const lastChar = text[text.length - 1];\n      var closeComment = true;\n      var binding;\n\n      if (firstChar === '#') {\n        if (lastChar === '/') {\n          binding = text.slice(1, -1);\n        } else {\n          binding = text.slice(1);\n          closeComment = false;\n        }\n        const matches = binding.match(BINDING_EXPRESSION);\n        if (matches) {\n          binding = matches[1] + ':' + matches[2];\n        }\n      } else if (firstChar === '/') ; else if (firstChar === '{' && lastChar === '}') {\n        binding = 'html:' + this.trim(text.slice(1, -1));\n      } else {\n        binding = 'text:' + this.trim(text);\n      }\n\n      if (binding) {\n        yield ownerDocument.createComment('ko ' + binding);\n      }\n      if (closeComment) {\n        yield ownerDocument.createComment('/ko');\n      }\n    }\n  }\n\n  class Text extends Interpolated {\n    asAttr () { return this.text }\n\n    * textNodeReplacement () {\n      yield document.createTextNode(this.text.replace(/\"/g, '\\\\\"'));\n    }\n  }\n\n  /**\n   *          Interpolation Parsing\n   */\n  function * innerParse (text) {\n    const innerMatch = text.match(INNER_EXPRESSION);\n    if (innerMatch) {\n      const [pre, inner, post] = innerMatch.slice(1);\n      yield * innerParse(pre);\n      yield new Text(inner);\n      yield new Expression$1(post);\n    } else {\n      yield new Expression$1(text);\n    }\n  }\n\n  function * parseOuterMatch (outerMatch) {\n    if (!outerMatch) { return }\n    let [pre, inner, post] = outerMatch.slice(1);\n    yield new Text(pre);\n    yield * innerParse(inner);\n    yield new Text(post);\n  }\n\n  function * parseInterpolation (text) {\n    for (const textOrExpr of parseOuterMatch(text.match(OUTER_EXPRESSION))) {\n      if (textOrExpr.text) { yield textOrExpr; }\n    }\n  }\n\n  /**\n   * These are bindings that are mapped specific attributes, such as\n   * two-way communication (value/checked) or which have anti-collision\n   * properties (css).\n   */\n  const DEFAULT_ATTRIBUTE_BINDING_MAP = {\n    value: 'value',\n    checked: 'checked',\n    class: 'css'\n  };\n\n  /**\n   *  Interpret {{ }} inside DOM attributes e.g. <div class='{{ classes }}'>\n   */\n  class AttributeMustacheProvider extends Provider {\n    get FOR_NODE_TYPES () { return [ 1 ] } // document.ELEMENT_NODE\n\n    constructor (params = {}) {\n      super(params);\n      this.ATTRIBUTES_TO_SKIP = new Set(params.attributesToSkip || ['data-bind']);\n      this.ATTRIBUTES_BINDING_MAP = params.attributesBindingMap || DEFAULT_ATTRIBUTE_BINDING_MAP;\n    }\n\n    * attributesToInterpolate (attributes) {\n      for (const attr of Array.from(attributes)) {\n        if (this.ATTRIBUTES_TO_SKIP.has(attr.name)) { continue }\n        if (attr.specified && attr.value.includes('{{')) { yield attr; }\n      }\n    }\n\n    nodeHasBindings (node) {\n      return !this.attributesToInterpolate(node.attributes).next().done\n    }\n\n    partsTogether (parts, context, node, ...valueToWrite) {\n      if (parts.length > 1) {\n        return parts\n          .map(p => unwrap(p.asAttr(context, this.globals, node))).join('')\n      }\n      // It may be a writeable observable e.g. value=\"{{ value }}\".\n      const part = parts[0].asAttr(context, this.globals);\n      if (valueToWrite.length) { part(valueToWrite[0]); }\n      return part\n    }\n\n    attributeBinding (name, parts) {\n      return [name, parts]\n    }\n\n    * bindingParts (node, context) {\n      for (const attr of this.attributesToInterpolate(node.attributes)) {\n        const parts = Array.from(parseInterpolation(attr.value));\n        if (parts.length) { yield this.attributeBinding(attr.name, parts); }\n      }\n    }\n\n    getPossibleDirectBinding (attrName) {\n      const bindingName = this.ATTRIBUTES_BINDING_MAP[attrName];\n      return bindingName && this.bindingHandlers.get(attrName)\n    }\n\n    * bindingObjects (node, context) {\n      for (const [attrName, parts] of this.bindingParts(node, context)) {\n        const bindingForAttribute = this.getPossibleDirectBinding(attrName);\n        const handler = bindingForAttribute ? attrName : `attr.${attrName}`;\n        const accessorFn = bindingForAttribute\n          ? (...v) => this.partsTogether(parts, context, node, ...v)\n          : (...v) => ({[attrName]: this.partsTogether(parts, context, node, ...v)});\n        node.removeAttribute(attrName);\n        yield { [handler]: accessorFn };\n      }\n    }\n\n    getBindingAccessors (node, context) {\n      return Object.assign({}, ...this.bindingObjects(node, context))\n    }\n  }\n\n  /**\n   * Interpret {{ }}, {{{ }}}, {{# /}}, and {{# }} ... {{/ }} inside text nodes.\n   *\n   * This binding must come before the VirtualProvider.\n   */\n  class TextMustacheProvider extends Provider {\n    get FOR_NODE_TYPES () { return [ 3 ] } // document.TEXT_NODE\n\n    * textToNodes (textNode) {\n      const parent = textNode.parentNode;\n      const isTextarea = parent && parent.nodeName === 'TEXTAREA';\n      const hasStash = textNode.nodeValue && textNode.nodeValue.includes('{{');\n\n      if (!hasStash || isTextarea) { return }\n\n      for (const part of parseInterpolation(textNode.nodeValue)) {\n        yield * part.textNodeReplacement(textNode);\n      }\n    }\n\n    textInterpolation (textNode) {\n      const newNodes = Array.from(this.textToNodes(textNode));\n\n      if (newNodes.length === 0) { return }\n\n      if (textNode.parentNode) {\n        const parent = textNode.parentNode;\n        const n = newNodes.length;\n        for (let i = 0; i < n; ++i) {\n          parent.insertBefore(newNodes[i], textNode);\n        }\n        parent.removeChild(textNode);\n      }\n\n      return newNodes\n    }\n\n    /**\n     * We convert as follows:\n     *\n     *   {{# ... }} into <!-- ko ... -->\n     *   {{/ ... }} into <!-- /ko -->\n     *   {{# ... /}} into <!-- ko ... --><!-- /ko -->\n     *   {{ ... }} into <!-- ko text: ... --><!-- /ko -->\n     *   {{{ ... }}} into <!-- ko html: ... --><!-- /ko -->\n     *\n     * VirtualProvider can then pick up and do the actual binding.\n     */\n    preprocessNode (node) {\n      return this.textInterpolation(node)\n    }\n  }\n\n  const NATIVE_BINDINGS = Symbol('Knockout native bindings');\n\n  /**\n   * Retrieve the binding accessors that are already attached to\n   * a node under the `NATIVE_BINDINGS` symbol.\n   *\n   * Used by the jsxToNode function.\n   */\n  class NativeProvider extends Provider {\n    get FOR_NODE_TYPES () { return [ 1, 3 ] }\n    get preemptive () { return true }\n\n    nodeHasBindings (node) {\n      if (!node[NATIVE_BINDINGS]) { return false }\n      return Object.keys(node[NATIVE_BINDINGS] || {})\n        .some(key => key.startsWith('ko-'))\n    }\n\n    /**\n     * There can be only one preprocessor; when there are native bindings,\n     * prevent re-entrance (and likely XSS) from the `{{ }}` provider.\n     */\n    preprocessNode (node) {\n      return node[NATIVE_BINDINGS] ? node : null\n    }\n\n    onlyBindings ([name]) {\n      return name.startsWith('ko-')\n    }\n\n    valueAsAccessor ([name, value]) {\n      const bindingName = name.replace(/^ko-/, '');\n      const valueFn = isObservable(value) ? value : () => value;\n      return {[bindingName]: valueFn}\n    }\n\n    /**\n     * Return as valueAccessor function all the entries matching `ko-*`\n     * @param {HTMLElement} node\n     */\n    getBindingAccessors (node) {\n      const bindings = Object.entries(node[NATIVE_BINDINGS] || {})\n        .filter(this.onlyBindings);\n      if (!bindings.length) { return null }\n      return Object.assign({}, ...bindings.map(this.valueAsAccessor))\n    }\n\n    /**\n     * Add a named-value to the given node.\n     * @param {HTMLElement} node\n     * @param {string} name\n     * @param {any} value\n     */\n    static addValueToNode (node, name, value) {\n      const obj = node[NATIVE_BINDINGS] || (node[NATIVE_BINDINGS] = {});\n      obj[name] = value;\n    }\n\n    /**\n     *\n     * @param {HTMLElement} node\n     * @return {object} the stored values\n     */\n    static getNodeValues (node) {\n      return node[NATIVE_BINDINGS]\n    }\n  }\n\n  var attr = {\n    update: function (element, valueAccessor, allBindings) {\n      var value = unwrap(valueAccessor()) || {};\n      objectForEach(value, function (attrName, attrValue) {\n        attrValue = unwrap(attrValue);\n\n        // Find the namespace of this attribute, if any.\n        var prefixLen = attrName.indexOf(':');\n        var namespace = prefixLen > 0 && element.lookupNamespaceURI(attrName.substr(0, prefixLen));\n\n        // To cover cases like \"attr: { checked:someProp }\", we want to remove the attribute entirely\n        // when someProp is a \"no value\"-like value (strictly null, false, or undefined)\n        // (because the absence of the \"checked\" attr is how to mark an element as not checked, etc.)\n        const toRemove = attrValue === false || attrValue === null || attrValue === undefined;\n\n        if (toRemove) {\n          if (namespace) {\n            element.removeAttributeNS(namespace, attrName);\n          } else {\n            element.removeAttribute(attrName);\n          }\n        } else {\n          attrValue = attrValue.toString();\n          if (namespace) {\n            element.setAttributeNS(namespace, attrName, attrValue);\n          } else {\n            element.setAttribute(attrName, attrValue);\n          }\n        }\n\n        // Treat \"name\" specially - although you can think of it as an attribute, it also needs\n        // special handling on older versions of IE (https://github.com/SteveSanderson/knockout/pull/333)\n        // Deliberately being case-sensitive here because XHTML would regard \"Name\" as a different thing\n        // entirely, and there's no strong reason to allow for such casing in HTML.\n        if (attrName === 'name') {\n          setElementName(element, toRemove ? '' : attrValue);\n        }\n      });\n    }\n  };\n\n  var checked = {\n    after: ['value', 'attr'],\n    init: function (element, valueAccessor, allBindings) {\n      var checkedValue = pureComputed(function () {\n        // Treat \"value\" like \"checkedValue\" when it is included with \"checked\" binding\n        if (allBindings.has('checkedValue')) {\n          return unwrap(allBindings.get('checkedValue'))\n        } else if (useElementValue) {\n          if (allBindings.has('value')) {\n            return unwrap(allBindings.get('value'))\n          } else {\n            return element.value\n          }\n        }\n      });\n\n      function updateModel () {\n        // This updates the model value from the view value.\n        // It runs in response to DOM events (click) and changes in checkedValue.\n        var isChecked = element.checked,\n          elemValue = checkedValue();\n\n        // When we're first setting up this computed, don't change any model state.\n        if (isInitial()) {\n          return\n        }\n\n        // We can ignore unchecked radio buttons, because some other radio\n        // button will be checked, and that one can take care of updating state.\n        // button will be checked, and that one can take care of updating state\n        if (!isChecked && (isRadio || getDependenciesCount())) {\n          return\n        }\n\n        var modelValue = ignore(valueAccessor);\n        if (valueIsArray) {\n          var writableValue = rawValueIsNonArrayObservable ? modelValue.peek() : modelValue,\n            saveOldValue = oldElemValue;\n          oldElemValue = elemValue;\n\n          if (saveOldValue !== elemValue) {\n            // When we're responding to the checkedValue changing, and the element is\n            // currently checked, replace the old elem value with the new elem value\n            // in the model array.\n            if (isChecked) {\n              addOrRemoveItem(writableValue, elemValue, true);\n              addOrRemoveItem(writableValue, saveOldValue, false);\n            }\n\n            oldElemValue = elemValue;\n          } else {\n            // When we're responding to the user having checked/unchecked a checkbox,\n            // add/remove the element value to the model array.\n            addOrRemoveItem(writableValue, elemValue, isChecked);\n          }\n          if (rawValueIsNonArrayObservable && isWriteableObservable(modelValue)) {\n            modelValue(writableValue);\n          }\n        } else {\n          if (isCheckbox) {\n            if (elemValue === undefined) {\n              elemValue = isChecked;\n            } else if (!isChecked) {\n              elemValue = undefined;\n            }\n          }\n          valueAccessor(elemValue, {onlyIfChanged: true});\n        }\n      }\n      function updateView () {\n              // This updates the view value from the model value.\n              // It runs in response to changes in the bound (checked) value.\n        var modelValue = modelValue = unwrap(valueAccessor());\n        var elemValue = checkedValue();\n\n        if (valueIsArray) {\n                  // When a checkbox is bound to an array, being checked represents its value being present in that array\n          element.checked = arrayIndexOf(modelValue, elemValue) >= 0;\n          oldElemValue = elemValue;\n        } else if (isCheckbox && elemValue === undefined) {\n                                   // When a checkbox is bound to any other value (not an array) and \"checkedValue\" is not defined,\n                                   // being checked represents the value being trueish\n          element.checked = !!modelValue;\n        } else {\n          // Otherwise, being checked means that the checkbox or radio button's value corresponds to the model value\n          element.checked = (checkedValue() === modelValue);\n        }\n      }\n      var isCheckbox = element.type == 'checkbox',\n        isRadio = element.type == 'radio';\n\n          // Only bind to check boxes and radio buttons\n      if (!isCheckbox && !isRadio) {\n        return\n      }\n\n      var rawValue = valueAccessor(),\n        valueIsArray = isCheckbox && (unwrap(rawValue) instanceof Array),\n        rawValueIsNonArrayObservable = !(valueIsArray && rawValue.push && rawValue.splice),\n        useElementValue = isRadio || valueIsArray,\n        oldElemValue = valueIsArray ? checkedValue() : undefined;\n\n          // Set up two computeds to update the binding:\n\n          // The first responds to changes in the checkedValue value and to element clicks\n      computed(updateModel, null, { disposeWhenNodeIsRemoved: element });\n      registerEventHandler(element, 'click', updateModel);\n\n          // The second responds to changes in the model value (the one associated with the checked binding)\n      computed(updateView, null, { disposeWhenNodeIsRemoved: element });\n\n      rawValue = undefined;\n    }\n  };\n\n  var checkedValue = {\n    update: function (element, valueAccessor) {\n      element.value = unwrap(valueAccessor());\n    }\n  };\n\n  // For certain common events (currently just 'click'), allow a simplified data-binding syntax\n  // e.g. click:handler instead of the usual full-length event:{click:handler}\n  function makeEventHandlerShortcut (eventName) {\n    return {\n      init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n        var newValueAccessor = function () {\n          var result = {};\n          result[eventName] = valueAccessor();\n          return result\n        };\n        eventHandler.init.call(this, element, newValueAccessor, allBindings, viewModel, bindingContext);\n      }\n    }\n  }\n\n  function makeDescriptor (handlerOrObject) {\n    return typeof handlerOrObject === 'function' ? { handler: handlerOrObject } : handlerOrObject || {}\n  }\n\n  const eventHandler = {\n    init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n      var eventsToHandle = valueAccessor() || {};\n      objectForEach(eventsToHandle, function (eventName, descriptor) {\n        const {passive, capture, once, debounce: debounce$$1, throttle: throttle$$1} = makeDescriptor(descriptor);\n        const eventOptions = (capture || passive || once) && {capture, passive, once};\n\n        let eventHandlerFn = (event, ...more) => {\n          var handlerReturnValue;\n          const {handler, passive, bubble} = makeDescriptor(valueAccessor()[eventName]);\n\n          try {\n            // Take all the event args, and prefix with the viewmodel\n            if (handler) {\n              const possiblyUpdatedViewModel = bindingContext.$data;\n              const argsForHandler = [possiblyUpdatedViewModel, event, ...more];\n              handlerReturnValue = handler.apply(possiblyUpdatedViewModel, argsForHandler);\n            }\n          } finally {\n            if (handlerReturnValue !== true) {\n              // Normally we want to prevent default action. Developer can override this be explicitly returning true.\n              // preventDefault will throw an error if the event is passive.\n              if (event.preventDefault) {\n                if (!passive) { event.preventDefault(); }\n              } else {\n                event.returnValue = false;\n              }\n            }\n          }\n\n          const bubbleMark = allBindings.get(eventName + 'Bubble') !== false;\n          if (bubble === false || !bubbleMark) {\n            event.cancelBubble = true;\n            if (event.stopPropagation) { event.stopPropagation(); }\n          }\n        };\n\n        if (debounce$$1) { eventHandlerFn = debounce(eventHandlerFn, debounce$$1); }\n        if (throttle$$1) { eventHandlerFn = throttle(eventHandlerFn, throttle$$1); }\n\n        registerEventHandler(element, eventName, eventHandlerFn, eventOptions || false);\n      });\n    }\n  };\n\n  const onHandler = {\n    init: eventHandler.init,\n    preprocess: function (value, key, addBinding) {\n      addBinding(key.replace('on.', ''), '=>' + value);\n    }\n  };\n\n  // 'click' is just a shorthand for the usual full-length event:{click:handler}\n  var click = makeEventHandlerShortcut('click');\n\n  var css = {\n    aliases: ['class'],\n    update: function (element, valueAccessor) {\n      var value = unwrap(valueAccessor());\n      if (value !== null && typeof value === 'object') {\n        objectForEach(value, function (className, shouldHaveClass) {\n          shouldHaveClass = unwrap(shouldHaveClass);\n          toggleDomNodeCssClass(element, className, shouldHaveClass);\n        });\n      } else {\n        value = stringTrim(String(value || '')); // Make sure we don't try to store or set a non-string value\n        toggleDomNodeCssClass(element, element[css.classesWrittenByBindingKey], false);\n        element[css.classesWrittenByBindingKey] = value;\n        toggleDomNodeCssClass(element, value, true);\n      }\n    },\n    classesWrittenByBindingKey: createSymbolOrString('__ko__cssValue')\n  };\n\n  /**\n   * A simple callback binding.\n   */\n\n  class DescendantsCompleteHandler extends BindingHandler {\n    onDescendantsComplete () {\n      if (typeof this.value === 'function') {\n        this.value(this.$element);\n      }\n    }\n\n    static get allowVirtualElements () { return true }\n  }\n\n  var enable = {\n    update: function (element, valueAccessor) {\n      var value = unwrap(valueAccessor());\n      if (value && element.disabled) {\n        element.removeAttribute('disabled');\n      } else if ((!value) && (!element.disabled)) {\n        element.disabled = true;\n      }\n    }\n  };\n\n  var disable = {\n    update: function (element, valueAccessor) {\n      enable.update(element, function () { return !unwrap(valueAccessor()) });\n    }\n  };\n\n  var hasfocusUpdatingProperty = createSymbolOrString('__ko_hasfocusUpdating');\n  var hasfocusLastValue = createSymbolOrString('__ko_hasfocusLastValue');\n\n  var hasfocus = {\n    init: function (element, valueAccessor /*, allBindings */) {\n      var handleElementFocusChange = function (isFocused) {\n              // Where possible, ignore which event was raised and determine focus state using activeElement,\n              // as this avoids phantom focus/blur events raised when changing tabs in modern browsers.\n              // However, not all KO-targeted browsers (Firefox 2) support activeElement. For those browsers,\n              // prevent a loss of focus when changing tabs/windows by setting a flag that prevents hasfocus\n              // from calling 'blur()' on the element when it loses focus.\n              // Discussion at https://github.com/SteveSanderson/knockout/pull/352\n        element[hasfocusUpdatingProperty] = true;\n        var ownerDoc = element.ownerDocument;\n        if ('activeElement' in ownerDoc) {\n          var active;\n          try {\n            active = ownerDoc.activeElement;\n          } catch (e) {\n                      // IE9 throws if you access activeElement during page load (see issue #703)\n            active = ownerDoc.body;\n          }\n          isFocused = (active === element);\n        }\n              // var modelValue = valueAccessor();\n        valueAccessor(isFocused, {onlyIfChanged: true});\n\n              // cache the latest value, so we can avoid unnecessarily calling focus/blur in the update function\n        element[hasfocusLastValue] = isFocused;\n        element[hasfocusUpdatingProperty] = false;\n      };\n      var handleElementFocusIn = handleElementFocusChange.bind(null, true);\n      var handleElementFocusOut = handleElementFocusChange.bind(null, false);\n\n      registerEventHandler(element, 'focus', handleElementFocusIn);\n      registerEventHandler(element, 'focusin', handleElementFocusIn); // For IE\n      registerEventHandler(element, 'blur', handleElementFocusOut);\n      registerEventHandler(element, 'focusout', handleElementFocusOut); // For IE\n    },\n    update: function (element, valueAccessor) {\n      var value = !!unwrap(valueAccessor());\n\n      if (!element[hasfocusUpdatingProperty] && element[hasfocusLastValue] !== value) {\n        value ? element.focus() : element.blur();\n\n              // In IE, the blur method doesn't always cause the element to lose focus (for example, if the window is not in focus).\n              // Setting focus to the body element does seem to be reliable in IE, but should only be used if we know that the current\n              // element was focused already.\n        if (!value && element[hasfocusLastValue]) {\n          element.ownerDocument.body.focus();\n        }\n\n              // For IE, which doesn't reliably fire \"focus\" or \"blur\" events synchronously\n        ignore(triggerEvent, null, [element, value ? 'focusin' : 'focusout']);\n      }\n    }\n  };\n\n  var html = {\n    init: function () {\n          // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)\n      return {\n        'controlsDescendantBindings': true\n      }\n    },\n      //\n      // Modify internal, per ko.punches and :\n      //      http://stackoverflow.com/a/15348139\n    update: function (element, valueAccessor) {\n      setHtml(element, valueAccessor());\n    },\n    allowVirtualElements: true\n  };\n\n  var $let = {\n    init: function (element, valueAccessor, allBindings, viewModel, bindingContext$$1) {\n          // Make a modified binding context, with extra properties, and apply it to descendant elements\n      var innerContext = bindingContext$$1['extend'](valueAccessor);\n      applyBindingsToDescendants(innerContext, element);\n\n      return { 'controlsDescendantBindings': true }\n    },\n    allowVirtualElements: true\n  }\n\n  var captionPlaceholder = {};\n\n  var options$1 = {\n    init: function (element) {\n      if (tagNameLower(element) !== 'select') { throw new Error('options binding applies only to SELECT elements') }\n\n          // Remove all existing <option>s.\n      while (element.length > 0) {\n        element.remove(0);\n      }\n\n          // Ensures that the binding processor doesn't try to bind the options\n      return { 'controlsDescendantBindings': true }\n    },\n    update: function (element, valueAccessor, allBindings) {\n      function selectedOptions () {\n        return arrayFilter(element.options, function (node) { return node.selected })\n      }\n\n      var selectWasPreviouslyEmpty = element.length == 0,\n        multiple = element.multiple,\n        previousScrollTop = (!selectWasPreviouslyEmpty && multiple) ? element.scrollTop : null,\n        unwrappedArray = unwrap(valueAccessor()),\n        valueAllowUnset = allBindings.get('valueAllowUnset') && allBindings['has']('value'),\n        includeDestroyed = allBindings.get('optionsIncludeDestroyed'),\n        arrayToDomNodeChildrenOptions = {},\n        captionValue,\n        filteredArray,\n        previousSelectedValues = [];\n\n      if (!valueAllowUnset) {\n        if (multiple) {\n          previousSelectedValues = arrayMap(selectedOptions(), selectExtensions.readValue);\n        } else if (element.selectedIndex >= 0) {\n          previousSelectedValues.push(selectExtensions.readValue(element.options[element.selectedIndex]));\n        }\n      }\n\n      if (unwrappedArray) {\n        if (typeof unwrappedArray.length === 'undefined') // Coerce single value into array\n          { unwrappedArray = [unwrappedArray]; }\n\n              // Filter out any entries marked as destroyed\n        filteredArray = arrayFilter(unwrappedArray, function (item) {\n          return includeDestroyed || item === undefined || item === null || !unwrap(item['_destroy'])\n        });\n\n              // If caption is included, add it to the array\n        if (allBindings['has']('optionsCaption')) {\n          captionValue = unwrap(allBindings.get('optionsCaption'));\n                  // If caption value is null or undefined, don't show a caption\n          if (captionValue !== null && captionValue !== undefined) {\n            filteredArray.unshift(captionPlaceholder);\n          }\n        }\n      }\n\n      function applyToObject (object, predicate, defaultValue) {\n        var predicateType = typeof predicate;\n        if (predicateType == 'function')    // Given a function; run it against the data value\n                { return predicate(object) } else if (predicateType == 'string') // Given a string; treat it as a property name on the data value\n                { return object[predicate] } else                                // Given no optionsText arg; use the data value itself\n                  { return defaultValue }\n      }\n\n          // The following functions can run at two different times:\n          // The first is when the whole array is being updated directly from this binding handler.\n          // The second is when an observable value for a specific array entry is updated.\n          // oldOptions will be empty in the first case, but will be filled with the previously generated option in the second.\n      var itemUpdate = false;\n      function optionForArrayItem (arrayEntry, index, oldOptions) {\n        if (oldOptions.length) {\n          previousSelectedValues = !valueAllowUnset && oldOptions[0].selected ? [ selectExtensions.readValue(oldOptions[0]) ] : [];\n          itemUpdate = true;\n        }\n        var option = element.ownerDocument.createElement('option');\n        if (arrayEntry === captionPlaceholder) {\n          setTextContent(option, allBindings.get('optionsCaption'));\n          selectExtensions.writeValue(option, undefined);\n        } else {\n                  // Apply a value to the option element\n          var optionValue = applyToObject(arrayEntry, allBindings.get('optionsValue'), arrayEntry);\n          selectExtensions.writeValue(option, unwrap(optionValue));\n\n                  // Apply some text to the option element\n          var optionText = applyToObject(arrayEntry, allBindings.get('optionsText'), optionValue);\n          setTextContent(option, optionText);\n        }\n        return [option]\n      }\n\n          // By using a beforeRemove callback, we delay the removal until after new items are added. This fixes a selection\n          // problem in IE<=8 and Firefox. See https://github.com/knockout/knockout/issues/1208\n      arrayToDomNodeChildrenOptions['beforeRemove'] =\n              function (option) {\n                element.removeChild(option);\n              };\n\n      function setSelectionCallback (arrayEntry, newOptions) {\n        if (itemUpdate && valueAllowUnset) {\n                  // The model value is authoritative, so make sure its value is the one selected\n                  // There is no need to use dependencyDetection.ignore since setDomNodeChildrenFromArrayMapping does so already.\n          selectExtensions.writeValue(element, unwrap(allBindings.get('value')), true /* allowUnset */);\n        } else if (previousSelectedValues.length) {\n                  // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.\n                  // That's why we first added them without selection. Now it's time to set the selection.\n          var isSelected = arrayIndexOf(previousSelectedValues, selectExtensions.readValue(newOptions[0])) >= 0;\n          setOptionNodeSelectionState(newOptions[0], isSelected);\n\n                  // If this option was changed from being selected during a single-item update, notify the change\n          if (itemUpdate && !isSelected) {\n            ignore(triggerEvent, null, [element, 'change']);\n          }\n        }\n      }\n\n      var callback = setSelectionCallback;\n      if (allBindings['has']('optionsAfterRender') && typeof allBindings.get('optionsAfterRender') === 'function') {\n        callback = function (arrayEntry, newOptions) {\n          setSelectionCallback(arrayEntry, newOptions);\n          ignore(allBindings.get('optionsAfterRender'), null, [newOptions[0], arrayEntry !== captionPlaceholder ? arrayEntry : undefined]);\n        };\n      }\n\n      setDomNodeChildrenFromArrayMapping(element, filteredArray, optionForArrayItem, arrayToDomNodeChildrenOptions, callback);\n\n      ignore(function () {\n        if (valueAllowUnset) {\n                  // The model value is authoritative, so make sure its value is the one selected\n          selectExtensions.writeValue(element, unwrap(allBindings.get('value')), true /* allowUnset */);\n        } else {\n                  // Determine if the selection has changed as a result of updating the options list\n          var selectionChanged;\n          if (multiple) {\n                      // For a multiple-select box, compare the new selection count to the previous one\n                      // But if nothing was selected before, the selection can't have changed\n            selectionChanged = previousSelectedValues.length && selectedOptions().length < previousSelectedValues.length;\n          } else {\n                      // For a single-select box, compare the current value to the previous value\n                      // But if nothing was selected before or nothing is selected now, just look for a change in selection\n            selectionChanged = (previousSelectedValues.length && element.selectedIndex >= 0)\n                          ? (selectExtensions.readValue(element.options[element.selectedIndex]) !== previousSelectedValues[0])\n                          : (previousSelectedValues.length || element.selectedIndex >= 0);\n          }\n\n                  // Ensure consistency between model value and selected option.\n                  // If the dropdown was changed so that selection is no longer the same,\n                  // notify the value or selectedOptions binding.\n          if (selectionChanged) {\n            triggerEvent(element, 'change');\n          }\n        }\n      });\n\n          // Workaround for IE bug\n      ensureSelectElementIsRenderedCorrectly(element);\n\n      if (previousScrollTop && Math.abs(previousScrollTop - element.scrollTop) > 20) { element.scrollTop = previousScrollTop; }\n    }\n  };\n\n  var selectedOptions = {\n    after: ['options', 'foreach'],\n\n    init: function (element, valueAccessor, allBindings) {\n      registerEventHandler(element, 'change', function () {\n        var value = valueAccessor(), valueToWrite = [];\n        arrayForEach(element.getElementsByTagName('option'), function (node) {\n          if (node.selected) { valueToWrite.push(selectExtensions.readValue(node)); }\n        });\n        valueAccessor(valueToWrite);\n      });\n    },\n\n    update: function (element, valueAccessor) {\n      if (tagNameLower(element) != 'select') { throw new Error('values binding applies only to SELECT elements') }\n\n      var newValue = unwrap(valueAccessor()),\n        previousScrollTop = element.scrollTop;\n\n      if (newValue && typeof newValue.length === 'number') {\n        arrayForEach(element.getElementsByTagName('option'), function (node) {\n          var isSelected = arrayIndexOf(newValue, selectExtensions.readValue(node)) >= 0;\n          if (node.selected != isSelected) {      // This check prevents flashing of the select element in IE\n            setOptionNodeSelectionState(node, isSelected);\n          }\n        });\n      }\n\n      element.scrollTop = previousScrollTop;\n    }\n  };\n\n  const {jQueryInstance: jQueryInstance$1} = options;\n\n  var style = {\n    update: function (element, valueAccessor) {\n      var value = unwrap(valueAccessor() || {});\n      objectForEach(value, function (styleName, styleValue) {\n        styleValue = unwrap(styleValue);\n\n        if (styleValue === null || styleValue === undefined || styleValue === false) {\n          // Empty string removes the value, whereas null/undefined have no effect\n          styleValue = '';\n        }\n\n        if (jQueryInstance$1) {\n          jQueryInstance$1(element).css(styleName, styleValue);\n        } else {\n          styleName = styleName.replace(/-(\\w)/g, (all, letter) => letter.toUpperCase());\n          const previousStyle = element.style[styleName];\n          element.style[styleName] = styleValue;\n          if (styleValue !== previousStyle && element.style[styleName] === previousStyle && !isNaN(styleValue)) {\n            element.style[styleName] = styleValue + 'px';\n          }\n        }\n      });\n    }\n  };\n\n  var submit = {\n    init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n      if (typeof valueAccessor() !== 'function') { throw new Error('The value for a submit binding must be a function') }\n      registerEventHandler(element, 'submit', function (event) {\n        var handlerReturnValue;\n        var value = valueAccessor();\n        try { handlerReturnValue = value.call(bindingContext['$data'], element); } finally {\n          if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.\n            if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; }\n          }\n        }\n      });\n    }\n  };\n\n  var text = {\n    init: function () {\n      // Prevent binding on the dynamically-injected text node (as developers are unlikely to expect that, and it has security implications).\n      // It should also make things faster, as we no longer have to consider whether the text node might be bindable.\n      return { controlsDescendantBindings: true }\n    },\n    update: function (element, valueAccessor) {\n      setTextContent(element, valueAccessor());\n    },\n    allowVirtualElements: true\n  };\n\n  var operaVersion, safariVersion, firefoxVersion;\n\n\n  /**\n   * TextInput binding handler for modern browsers (legacy below).\n   * @extends BindingHandler\n   */\n  class TextInput extends BindingHandler {\n    get aliases () { return 'textinput' }\n\n    constructor (...args) {\n      super(...args);\n      this.previousElementValue = this.$element.value;\n\n      if (options.debug && this.constructor._forceUpdateOn) {\n        // Provide a way for tests to specify exactly which events are bound\n        arrayForEach(this.constructor._forceUpdateOn, (eventName) => {\n          if (eventName.slice(0, 5) === 'after') {\n            this.addEventListener(eventName.slice(5), 'deferUpdateModel');\n          } else {\n            this.addEventListener(eventName, 'updateModel');\n          }\n        });\n      }\n\n      for (const eventName of this.eventsIndicatingSyncValueChange()) {\n        this.addEventListener(eventName, 'updateModel');\n      }\n      for (const eventName of this.eventsIndicatingDeferValueChange()) {\n        this.addEventListener(eventName, 'deferUpdateModel');\n      }\n      this.computed('updateView');\n    }\n\n    eventsIndicatingSyncValueChange () {\n      // input: Default, modern handler\n      // change: Catch programmatic updates of the value that fire this event.\n      // blur: To deal with browsers that don't notify any kind of event for some changes (IE, Safari, etc.)\n      return ['input', 'change', 'blur']\n    }\n\n    eventsIndicatingDeferValueChange () {\n      return []\n    }\n\n    updateModel (event) {\n      const element = this.$element;\n      clearTimeout(this.timeoutHandle);\n      this.elementValueBeforeEvent = this.timeoutHandle = undefined;\n      const elementValue = element.value;\n      if (this.previousElementValue !== elementValue) {\n                // Provide a way for tests to know exactly which event was processed\n        if (options.debug && event) {\n          element._ko_textInputProcessedEvent = event.type;\n        }\n        this.previousElementValue = elementValue;\n        this.value = elementValue;\n      }\n    }\n\n    deferUpdateModel (event) {\n      const element = this.$element;\n      if (!this.timeoutHandle) {\n        // The elementValueBeforeEvent variable is set *only* during the brief gap between an\n        // event firing and the updateModel function running. This allows us to ignore model\n        // updates that are from the previous state of the element, usually due to techniques\n        // such as rateLimit. Such updates, if not ignored, can cause keystrokes to be lost.\n        this.elementValueBeforeEvent = element.value;\n        const handler = options.debug ? this.updateModel.bind(this, { type: event.type }) : this.updateModel;\n        this.timeoutHandle = safeSetTimeout(handler, 4);\n      }\n    }\n\n    updateView () {\n      let modelValue = unwrap(this.value);\n      if (modelValue === null || modelValue === undefined) {\n        modelValue = '';\n      }\n      if (this.elementValueBeforeEvent !== undefined\n                 && modelValue === this.elementValueBeforeEvent) {\n        setTimeout(this.updateView.bind(this), 4);\n      } else if (this.$element.value !== modelValue) {\n        // Update the element only if the element and model are different. On some browsers, updating the value\n        // will move the cursor to the end of the input, which would be bad while the user is typing.\n        this.previousElementValue = modelValue; // Make sure we ignore events (propertychange) that result from updating the value\n        this.$element.value = modelValue;\n        this.previousElementValue = this.$element.value; // In case the browser changes the value (see #2281)\n      }\n    }\n  }\n\n  /**\n   * Legacy Input Classes, below\n   */\n  class TextInputIE extends TextInput {\n    constructor (...args) {\n      super(...args);\n\n      if (ieVersion < 11) {\n        // Internet Explorer <= 8 doesn't support the 'input' event, but does include 'propertychange' that fires whenever\n        // any property of an element changes. Unlike 'input', it also fires if a property is changed from JavaScript code,\n        // but that's an acceptable compromise for this binding. IE 9 and 10 support 'input', but since they don't always\n        // fire it when using autocomplete, we'll use 'propertychange' for them also.\n        this.addEventListener('propertychange', event =>\n          event.propertyName === 'value' && this.updateModel(event)\n        );\n      }\n\n      if (ieVersion >= 8 && ieVersion < 10) {\n        this.watchForSelectionChangeEvent();\n        this.addEventListener('dragend', 'deferUpdateModel');\n      }\n    }\n\n    eventsIndicatingSyncValueChange () {\n      // keypress: All versions (including 11) of Internet Explorer have a bug that they don't generate an input or propertychange event when ESC is pressed\n      return [...super.eventsIndicatingValueChange(), 'keypress']\n    }\n\n    // IE 8 and 9 have bugs that prevent the normal events from firing when the value changes.\n    // But it does fire the 'selectionchange' event on many of those, presumably because the\n    // cursor is moving and that counts as the selection changing. The 'selectionchange' event is\n    // fired at the document level only and doesn't directly indicate which element changed. We\n    // set up just one event handler for the document and use 'activeElement' to determine which\n    // element was changed.\n    selectionChangeHandler (event) {\n        const target = this.activeElement;\n        const handler = target && get(target, selectionChangeHandlerName);\n        if (handler) { handler(event); }\n    }\n\n    watchForSelectionChangeEvent (element, ieUpdateModel) {\n      const ownerDoc = element.ownerDocument;\n      if (!get(ownerDoc, selectionChangeRegisteredName)) {\n          set(ownerDoc, selectionChangeRegisteredName, true);\n          registerEventHandler(ownerDoc, 'selectionchange', this.selectionChangeHandler.bind(ownerDoc));\n      }\n      set(element, selectionChangeHandlerName, handler);\n    }\n  }\n\n\n  // IE 8 and 9 have bugs that prevent the normal events from firing when the value changes.\n  // But it does fire the 'selectionchange' event on many of those, presumably because the\n  // cursor is moving and that counts as the selection changing. The 'selectionchange' event is\n  // fired at the document level only and doesn't directly indicate which element changed. We\n  // set up just one event handler for the document and use 'activeElement' to determine which\n  // element was changed.\n  class TextInputIE9 extends TextInputIE {\n    updateModel (...args) {\n      // IE9 will mess up the DOM if you handle events synchronously which results in DOM changes (such as other bindings);\n      // so we'll make sure all updates are asynchronous\n      this.deferUpdateModel(...args);\n    }\n  }\n\n\n  class TextInputIE8 extends TextInputIE {\n    eventsIndicatingValueChange () {\n      // IE 8 has a bug where it fails to fire 'propertychange' on the first update following a value change from\n      // JavaScript code. It also doesn't fire if you clear the entire value. To fix this, we bind to the following\n      // events too.\n      // keypress: All versions (including 11) of Internet Explorer have a bug that they don't generate an input or propertychange event when ESC is pressed\n      // keyup: A single keystoke\n      // keydown: First character when a key is held down\n      return [...super.eventsIndicatingValueChange(), 'keyup', 'keydown']\n    }\n  }\n\n\n  // Safari <5 doesn't fire the 'input' event for <textarea> elements (it does fire 'textInput'\n  // but only when typing). So we'll just catch as much as we can with keydown, cut, and paste.\n  class TextInputLegacySafari extends TextInput {\n    eventsIndicatingDeferValueChange () {\n      return ['keydown', 'paste', 'cut']\n    }\n  }\n\n\n  class TextInputLegacyOpera extends TextInput {\n    eventsIndicatingDeferValueChange () {\n      // Opera 10 doesn't always fire the 'input' event for cut, paste, undo & drop operations.\n      // We can try to catch some of those using 'keydown'.\n      return ['keydown']\n    }\n  }\n\n\n  class TextInputLegacyFirefox extends TextInput {\n    eventsIndicatingValueChange () {\n      return [\n        ...super.eventsIndicatingSyncValueChange(),\n        // Firefox <= 3.6 doesn't fire the 'input' event when text is filled in through autocomplete\n        'DOMAutoComplete',\n        // Firefox <=3.5 doesn't fire the 'input' event when text is dropped into the input.\n        'dragdrop', // < 3.5\n        'drop' // 3.5\n      ]\n    }\n  }\n\n\n  const w$1 = options.global; // window / global\n  if (w$1.navigator) {\n    const parseVersion = (matches) => matches && parseFloat(matches[1]);\n    const userAgent = w$1.navigator.userAgent;\n    const isChrome = userAgent.match(/Chrome\\/([^ ]+)/);\n    // Detect various browser versions because some old versions don't fully support the 'input' event\n    operaVersion = w$1.opera && w$1.opera.version && parseInt(w$1.opera.version());\n    safariVersion = parseVersion(userAgent.match(/Version\\/([^ ]+) Safari/));\n    firefoxVersion = parseVersion(userAgent.match(/Firefox\\/([^ ]*)/));\n  }\n\n\n  const textInput =\n    ieVersion === 8 ? TextInputIE8\n    : ieVersion === 9 ? TextInputIE9\n    : ieVersion ? TextInputIE\n    : safariVersion && safariVersion < 5 ? TextInputLegacySafari\n    : operaVersion < 11 ? TextInputLegacyOpera\n    : firefoxVersion && firefoxVersion < 4 ? TextInputLegacyFirefox\n    : TextInput;\n\n  var uniqueName = {\n    init: function (element, valueAccessor) {\n      if (valueAccessor()) {\n        var name = 'ko_unique_' + (++uniqueName.currentIndex);\n        setElementName(element, name);\n      }\n    },\n    currentIndex: 0\n  };\n\n  class value extends BindingHandler {\n    static get after () { return ['options', 'foreach', 'template'] }\n\n    constructor (...args) {\n      super(...args);\n\n      // If the value binding is placed on a radio/checkbox, then just pass through to checkedValue and quit\n      if (this.isCheckboxOrRadio) {\n        applyBindingAccessorsToNode(this.$element,\n          { checkedValue: this.valueAccessor });\n        return\n      }\n\n      this.propertyChangedFired = false;\n      this.elementValueBeforeEvent = null;\n\n      if (this.ieAutoCompleteHackNeeded) {\n        this.addEventListener('propertyChange', () => this.propertyChangedFired = true);\n        this.addEventListener('focus', () => this.propertyChangedFired = false);\n        this.addEventListener('blur', () => this.propertyChangeFired &&\n          this.valueUpdateHandler());\n      }\n\n      arrayForEach(this.eventsToCatch, eventName => this.registerEvent(eventName));\n\n      if (this.isInput && this.$element.type === 'file') {\n        this.updateFromModel = this.updateFromModelForFile;\n      } else {\n        this.updateFromModel = this.updateFromModelForValue;\n      }\n\n      this.computed('updateFromModel');\n    }\n\n    get eventsToCatch () {\n      const requestedEventsToCatch = this.allBindings.get('valueUpdate');\n      const requestedEventsArray = typeof requestedEventsToCatch === 'string' ?\n        [requestedEventsToCatch] : requestedEventsToCatch || [];\n      return [...new Set(['change', ...requestedEventsArray])]\n    }\n\n    get isInput () {\n      return tagNameLower(this.$element) === 'input'\n    }\n\n    get isCheckboxOrRadio () {\n      const e = this.$element;\n      return this.isInput && (e.type == 'checkbox' || e.type == 'radio')\n    }\n\n    // Workaround for https://github.com/SteveSanderson/knockout/issues/122\n    // IE doesn't fire \"change\" events on textboxes if the user selects a value from its autocomplete list\n    get ieAutoCompleteHackNeeded () {\n      return ieVersion && isInputElement &&\n        this.$element.type == 'text' && this.$element.autocomplete != 'off' &&\n        (!this.$element.form || this.$element.form.autocomplete != 'off')\n    }\n\n    valueUpdateHandler () {\n      this.elementValueBeforeEvent = null;\n      this.propertyChangedFired = false;\n      this.value = selectExtensions.readValue(this.$element);\n    }\n\n    registerEvent (eventName) {\n      // The syntax \"after<eventname>\" means \"run the handler asynchronously after the event\"\n      // This is useful, for example, to catch \"keydown\" events after the browser has updated the control\n      // (otherwise, selectExtensions.readValue(this) will receive the control's value *before* the key event)\n      var handler = this.valueUpdateHandler.bind(this);\n      if (stringStartsWith(eventName, 'after')) {\n        handler = () => {\n          // The elementValueBeforeEvent variable is non-null *only* during the brief gap between\n          // a keyX event firing and the valueUpdateHandler running, which is scheduled to happen\n          // at the earliest asynchronous opportunity. We store this temporary information so that\n          // if, between keyX and valueUpdateHandler, the underlying model value changes separately,\n          // we can overwrite that model value change with the value the user just typed. Otherwise,\n          // techniques like rateLimit can trigger model changes at critical moments that will\n          // override the user's inputs, causing keystrokes to be lost.\n          this.elementValueBeforeEvent = selectExtensions.readValue(this.$element);\n          safeSetTimeout(this.valueUpdateHandler.bind(this), 0);\n        };\n        eventName = eventName.substring(5 /* 'after'.length */);\n      }\n      this.addEventListener(eventName, handler);\n    }\n\n    updateFromModelForFile () {\n      // For file input elements, can only write the empty string\n      var newValue = unwrap(this.value);\n      if (newValue === null || newValue === undefined || newValue === '') {\n        this.$element.value = '';\n      } else {\n        ignore(this.valueUpdateHandler, this);   // reset the model to match the element\n      }\n    }\n\n    updateFromModelForValue () {\n      const element = this.$element;\n      var newValue = unwrap(this.value);\n      var elementValue = selectExtensions.readValue(element);\n\n      if (this.elementValueBeforeEvent !== null && newValue === this.elementValueBeforeEvent) {\n        safeSetTimeout(this.updateFromModel.bind(this), 0);\n        return\n      }\n\n      if (newValue === elementValue && elementValue !== undefined) { return }\n\n      if (tagNameLower(element) === 'select') {\n        const allowUnset = this.allBindings.get('valueAllowUnset');\n        selectExtensions.writeValue(element, newValue, allowUnset);\n\n        if (!allowUnset && newValue !== selectExtensions.readValue(element)) {\n         // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,\n         // because you're not allowed to have a model value that disagrees with a visible UI selection.\n          ignore(this.valueUpdateHandler, this);\n        }\n      } else {\n        selectExtensions.writeValue(element, newValue);\n      }\n    }\n  }\n\n  var visible = {\n    update: function (element, valueAccessor) {\n      var value = unwrap(valueAccessor());\n      var isCurrentlyVisible = !(element.style.display === 'none');\n      if (value && !isCurrentlyVisible) {\n        element.style.display = '';\n      } else if (!value && isCurrentlyVisible) {\n        element.style.display = 'none';\n      }\n    }\n  };\n\n  var hidden = {\n    update: function (element, valueAccessor) {\n      visible.update.call(this, element, () => !unwrap(valueAccessor()));\n    }\n  };\n\n  var using = {\n    init: function (element, valueAccessor, allBindings, viewModel, bindingContext$$1) {\n      var innerContext = bindingContext$$1.createChildContext(valueAccessor);\n      applyBindingsToDescendants(innerContext, element);\n      return { controlsDescendantBindings: true }\n    },\n    allowVirtualElements: true\n  };\n\n  var bindings$1 = {\n    attr,\n    checked,\n    checkedValue,\n    click,\n    css,\n    'class': css,\n    descendantsComplete: DescendantsCompleteHandler,\n    enable,\n    'event': eventHandler,\n    disable,\n    hasfocus,\n    hasFocus: hasfocus,\n    hidden,\n    html,\n    'let': $let,\n    on: onHandler,\n    options: options$1,\n    selectedOptions,\n    style,\n    submit,\n    text,\n    textInput,\n    textinput: textInput,\n    uniqueName,\n    using,\n    value,\n    visible\n  };\n\n  /**\n   * Create a DOMbinding that controls DOM nodes presence\n   *\n   * Covers e.g.\n   *\n   * 1. DOM Nodes contents\n   *\n   * <div data-bind='if: x'>\n   * <!-- else --> ... an optional 'if'\n   * </div>\n   *\n   * 2. Virtual elements\n   *\n   * <!-- ko if: x -->\n   * <!-- else -->\n   * <!-- /ko -->\n   *\n   * 3. Else binding\n   * <div data-bind='if: x'></div>\n   * <div data-bind='else'></div>\n   *\n   * Requires `renderStatus` and `get bindingContext` to be overloaded,\n   * and this.computed('render') must be called in the child constructor.\n   */\n  class ConditionalBindingHandler extends AsyncBindingHandler {\n    constructor (params) {\n      super(params);\n      this.hasElse = this.detectElse(this.$element);\n      const elseChainSatisfied = this.completesElseChain = observable();\n      set(this.$element, 'conditional', { elseChainSatisfied });\n    }\n\n    getIfElseNodes () {\n      if (this.ifElseNodes) { return this.ifElseNodes }\n      if (getDependenciesCount() || this.hasElse) {\n        return this.cloneIfElseNodes(this.$element, this.hasElse)\n      }\n    }\n\n    render () {\n      const isFirstRender = !this.ifElseNodes;\n      const {shouldDisplay} = this.renderStatus();\n\n      // Save the nodes before we possibly remove them from the DOM.\n      this.ifElseNodes = this.getIfElseNodes() || {};\n\n      if (shouldDisplay) {\n        const useOriginalNodes = isFirstRender && !this.hasElse;\n        this.renderAndApplyBindings(this.ifElseNodes.ifNodes, useOriginalNodes);\n      } else if (this.hasElse) {\n        this.renderAndApplyBindings(this.ifElseNodes.elseNodes);\n      } else {\n        emptyNode(this.$element);\n      }\n    }\n\n    async renderAndApplyBindings (nodes, useOriginalNodes) {\n      if (!useOriginalNodes) {\n        setDomNodeChildren$1(this.$element, cloneNodes(nodes));\n      }\n      const bound = await applyBindingsToDescendants(this.bindingContext, this.$element);\n      this.completeBinding(bound);\n    }\n\n    /**\n     * This may be truthy for the `else` binding.\n     */\n    get elseChainIsAlreadySatisfied () { return false }\n\n    /**\n     * Test a node for whether it represents an 'else' condition.\n     * @param  {HTMLElement}  node to be tested\n     * @return {Boolean}      true when\n     *\n     * Matches <!-- else -->\n     */\n    isElseNode (node) {\n      return node.nodeType === 8 &&\n            node.nodeValue.trim().toLowerCase() === 'else'\n    }\n\n    detectElse (element) {\n      var children = childNodes(element);\n      for (var i = 0, j = children.length; i < j; ++i) {\n        if (this.isElseNode(children[i])) { return true }\n      }\n      return false\n    }\n\n    /**\n     * Clone the nodes, returning `ifNodes`, `elseNodes`\n     * @param  {HTMLElement} element The nodes to be cloned\n     * @param  {boolean}    hasElse short-circuit to speed up the inner-loop.\n     * @return {object}         Containing the cloned nodes.\n     */\n    cloneIfElseNodes (element, hasElse) {\n      const children = childNodes(element);\n      const ifNodes = [];\n      const elseNodes = [];\n      let target = ifNodes;\n\n      for (var i = 0, j = children.length; i < j; ++i) {\n        if (hasElse && this.isElseNode(children[i])) {\n          target = elseNodes;\n          hasElse = false;\n        } else {\n          target.push(cleanNode(children[i].cloneNode(true)));\n        }\n      }\n\n      return { ifNodes, elseNodes }\n    }\n\n    get controlsDescendants () { return true }\n    static get allowVirtualElements () { return true }\n  }\n\n  /**\n   * For the `if:` binding.\n   */\n  class IfBindingHandler extends ConditionalBindingHandler {\n    constructor (...args) {\n      super(...args);\n      this.ifCondition = this.computed(() => !!unwrap(this.value));\n      this.computed('render');\n    }\n\n    shouldDisplayIf () {\n      return this.ifCondition()\n    }\n\n    get bindingContext () {\n      return this.ifCondition.isActive()\n        ? this.$context.extend(() => {\n          // Ensure that this context is dependant upon the conditional, so the\n          // order of binding application is: conditional before its children.\n          // See https://github.com/knockout/kn\n          // ockout/pull/2226\n          this.ifCondition();\n          return null\n        })\n        : this.$context\n    }\n\n    renderStatus () {\n      let shouldDisplay = this.shouldDisplayIf();\n\n      if (this.elseChainIsAlreadySatisfied) {\n        shouldDisplay = false;\n        // needsRefresh = isFirstRender || this.didDisplayOnLastUpdate FIXME\n        this.completesElseChain(true);\n      } else {\n        this.completesElseChain(shouldDisplay);\n      }\n      return {shouldDisplay}\n    }\n  }\n\n  class UnlessBindingHandler extends IfBindingHandler {\n    shouldDisplayIf () { return !super.shouldDisplayIf() }\n  }\n\n  /**\n   * The following fails somewhere in the `limit` functions of Observables i.e.\n   * it's an issue related to async/deferUpdates.\n   */\n  class WithBindingHandler extends ConditionalBindingHandler {\n    constructor (...args) {\n      super(...args);\n      this.asOption = this.allBindings.get('as');\n\n      // If given `as`, reduce the condition to a boolean, so it does not\n      // change & refresh when the value is updated.\n      const conditionalFn = this.asOption && !options.createChildContextWithAs\n        ? () => Boolean(unwrap(this.value)) : () => unwrap(this.value);\n      this.conditional = this.computed(conditionalFn);\n\n      this.computed('render');\n    }\n\n    get bindingContext () {\n      if (!this.asOption) {\n        return this.$context.createChildContext(this.valueAccessor)\n      }\n      return options.createChildContextWithAs\n        ? this.$context.createChildContext(this.value, this.asOption)\n        : this.$context.extend({[this.asOption]: this.value})\n    }\n\n    renderStatus () {\n      const shouldDisplay = Boolean(this.conditional());\n      return { shouldDisplay }\n    }\n  }\n\n  /**\n   * The `else` binding\n   * (not to be mistaken for `<!-- else -->` inside if bindings.\n   */\n  class ElseBindingHandler extends IfBindingHandler {\n    shouldDisplayIf () {\n      return super.shouldDisplayIf() || this.value === undefined\n    }\n\n    /**\n     * Return any conditional that precedes the given node.\n     * @return {object}      { elseChainSatisfied: observable }\n     */\n    get elseChainIsAlreadySatisfied () {\n      if (!this._elseChain) { this._elseChain = this.readElseChain(); }\n      return unwrap(this._elseChain.elseChainSatisfied)\n    }\n\n    readElseChain () {\n      let node = this.$element;\n      do {\n        node = node.previousSibling;\n      } while (node && node.nodeType !== 1 && node.nodeType !== 8)\n\n      if (!node) { return false }\n\n      if (node.nodeType === 8) {\n        node = previousSibling(node);\n      }\n\n      return get(node, 'conditional') || {}\n    }\n  }\n\n  const bindings$2 = {\n    'if': IfBindingHandler,\n    'with': WithBindingHandler,\n    ifnot: UnlessBindingHandler,\n    unless: UnlessBindingHandler,\n    'else': ElseBindingHandler,\n    'elseif': ElseBindingHandler\n  };\n\n  // index.js\n\n  //      Utilities\n  const MAX_LIST_SIZE = 9007199254740991;\n\n  // from https://github.com/jonschlinkert/is-plain-object\n  function isPlainObject (o) {\n    return !!o && typeof o === 'object' && o.constructor === Object\n  }\n\n  const supportsDocumentFragment = options.document && typeof options.document.createDocumentFragment === 'function';\n\n  // Get a copy of the (possibly virtual) child nodes of the given element,\n  // put them into a container, then empty the given node.\n  function makeTemplateNode (sourceNode) {\n    var container = document.createElement('div');\n    var parentNode;\n    if (sourceNode.content) {\n      // For e.g. <template> tags\n      parentNode = sourceNode.content;\n    } else if (sourceNode.tagName === 'SCRIPT') {\n      parentNode = document.createElement('div');\n      parentNode.innerHTML = sourceNode.text;\n    } else {\n      // Anything else e.g. <div>\n      parentNode = sourceNode;\n    }\n    arrayForEach(childNodes(parentNode), function (child) {\n      // FIXME - This cloneNode could be expensive; we may prefer to iterate over the\n      // parentNode children in reverse (so as not to foul the indexes as childNodes are\n      // removed from parentNode when inserted into the container)\n      if (child) {\n        container.insertBefore(child.cloneNode(true), null);\n      }\n    });\n    return container\n  }\n\n  // Mimic a KO change item 'add'\n  function valueToChangeAddItem (value, index) {\n    return {\n      status: 'added',\n      value: value,\n      index: index\n    }\n  }\n\n  // store a symbol for caching the pending delete info index in the data item objects\n  const PENDING_DELETE_INDEX_SYM = createSymbolOrString('_ko_ffe_pending_delete_index');\n\n\n  class ForEachBinding extends AsyncBindingHandler {\n    // NOTE: valid valueAccessors include:\n    //    []\n    //    observable([])\n    //    observableArray([])\n    //    computed\n    //    {data: array, name: string, as: string}\n\n    constructor (params) {\n      super(params);\n      const settings = {};\n      if (isPlainObject(this.value)) {\n        Object.assign(settings, this.value);\n      }\n\n      this.as = settings.as || this.allBindings.get('as');\n\n      this.data = settings.data || (unwrap(this.$context.$rawData) === this.value ? this.$context.$rawData : this.value);\n\n      this.container = isStartComment(this.$element)\n                       ? this.$element.parentNode : this.$element;\n      this.generateContext = this.createContextGenerator(this.as);\n      this.$indexHasBeenRequested = false;\n\n      this.templateNode = makeTemplateNode(\n        settings.templateNode || (settings.name\n          ? document.getElementById(settings.name).cloneNode(true)\n          : this.$element)\n      )\n\n      ;['afterAdd', 'beforeRemove', 'afterQueueFlush', 'beforeQueueFlush']\n        .forEach(p => { this[p] = settings[p] || this.allBindings.get(p); });\n\n      this.changeQueue = [];\n      this.firstLastNodesList = [];\n      this.indexesToDelete = [];\n      this.rendering_queued = false;\n      this.pendingDeletes = [];\n\n      // Expose the conditional so that if the `foreach` data is empty, successive\n      // 'else' bindings will appear.\n      this.isNotEmpty = observable(Boolean(unwrap(this.data).length));\n      set(this.$element, 'conditional', {\n        elseChainSatisfied: this.isNotEmpty\n      });\n\n      // Remove existing content.\n      emptyNode(this.$element);\n\n      // Prime content\n      const primeData = unwrap(this.data);\n      if (primeData && primeData.map) {\n        this.onArrayChange(primeData.map(valueToChangeAddItem), true);\n      } else {\n        this.completeBinding();\n      }\n\n      // Watch for changes\n      if (isObservable(this.data)) {\n        if (!this.data.indexOf) {\n          // Make sure the observable is trackable.\n          this.data = this.data.extend({ trackArrayChanges: true });\n        }\n        this.changeSubs = this.data.subscribe(this.onArrayChange, this, 'arrayChange');\n      }\n    }\n\n    dispose () {\n      if (this.changeSubs) {\n        this.changeSubs.dispose();\n      }\n      this.flushPendingDeletes();\n    }\n\n    // If the array changes we register the change.\n    onArrayChange (changeSet, isInitial$$1) {\n      var changeMap = {\n        added: [],\n        deleted: []\n      };\n\n      // knockout array change notification index handling:\n      // - sends the original array indexes for deletes\n      // - sends the new array indexes for adds\n      // - sorts them all by index in ascending order\n      // because of this, when checking for possible batch additions, any delete can be between to adds with neighboring indexes, so only additions should be checked\n      for (var i = 0, len = changeSet.length; i < len; i++) {\n        if (changeMap.added.length && changeSet[i].status === 'added') {\n          var lastAdd = changeMap.added[changeMap.added.length - 1];\n          var lastIndex = lastAdd.isBatch ? lastAdd.index + lastAdd.values.length - 1 : lastAdd.index;\n          if (lastIndex + 1 === changeSet[i].index) {\n            if (!lastAdd.isBatch) {\n              // transform the last addition into a batch addition object\n              lastAdd = {\n                isBatch: true,\n                status: 'added',\n                index: lastAdd.index,\n                values: [lastAdd.value]\n              };\n              changeMap.added.splice(changeMap.added.length - 1, 1, lastAdd);\n            }\n            lastAdd.values.push(changeSet[i].value);\n            continue\n          }\n        }\n\n        changeMap[changeSet[i].status].push(changeSet[i]);\n      }\n\n      if (changeMap.deleted.length > 0) {\n        this.changeQueue.push.apply(this.changeQueue, changeMap.deleted);\n        this.changeQueue.push({ status: 'clearDeletedIndexes' });\n      }\n\n      this.changeQueue.push.apply(this.changeQueue, changeMap.added);\n      // Once a change is registered, the ticking count-down starts for the processQueue.\n      if (this.changeQueue.length > 0 && !this.rendering_queued) {\n        this.rendering_queued = true;\n        if (isInitial$$1) {\n          this.processQueue();\n        } else {\n          ForEachBinding.animateFrame.call(window, () => this.processQueue());\n        }\n      }\n    }\n\n    startQueueFlush () {\n      // Callback so folks can do things before the queue flush.\n      if (typeof this.beforeQueueFlush === 'function') {\n        this.beforeQueueFlush(this.changeQueue);\n      }\n    }\n\n    endQueueFlush () {\n      // Callback so folks can do things.\n      if (typeof this.afterQueueFlush === 'function') {\n        this.afterQueueFlush(this.changeQueue);\n      }\n    }\n\n    // Reflect all the changes in the queue in the DOM, then wipe the queue.\n    processQueue () {\n      var isEmpty = !unwrap(this.data).length;\n      var lowestIndexChanged = MAX_LIST_SIZE;\n\n      this.startQueueFlush();\n\n      arrayForEach(this.changeQueue, (changeItem) => {\n        if (typeof changeItem.index === 'number') {\n          lowestIndexChanged = Math.min(lowestIndexChanged, changeItem.index);\n        }\n        this[changeItem.status](changeItem);\n      });\n      this.flushPendingDeletes();\n      this.rendering_queued = false;\n\n      // Update our indexes.\n      if (this.$indexHasBeenRequested) {\n        this.updateIndexes(lowestIndexChanged);\n      }\n\n      this.endQueueFlush();\n      this.changeQueue = [];\n\n      // Update the conditional exposed on the domData\n      if (isEmpty !== !this.isNotEmpty()) {\n        this.isNotEmpty(!isEmpty);\n      }\n    }\n\n    /**\n     * Once the $index has been asked for once, start calculating it.\n     * Note that this significantly degrades performance, from O(1) to O(n)\n     * for arbitrary changes to the list.\n     */\n    _first$indexRequest (ctx$indexRequestedFrom) {\n      this.$indexHasBeenRequested = true;\n      for (let i = 0, len = this.firstLastNodesList.length; i < len; ++i) {\n        const ctx = this.getContextStartingFrom(this.firstLastNodesList[i].first);\n        // Overwrite the defineProperty.\n        if (ctx) { ctx.$index = observable(i); }\n      }\n      return ctx$indexRequestedFrom.$index()\n    }\n\n    _contextExtensions ($ctx) {\n      Object.assign($ctx, { $list: this.data });\n      if (this.$indexHasBeenRequested) {\n        $ctx.$index = $ctx.$index || observable();\n      } else {\n        Object.defineProperty($ctx, '$index', {\n          value: () => this._first$indexRequest($ctx),\n          configurable: true,\n          writable: true\n        });\n      }\n      return $ctx\n    }\n\n    /**\n     * Return a function that generates the context for a given node.\n     *\n     * We generate a single function that reduces our inner-loop calculations,\n     * which has a good chance of being optimized by the browser.\n     *\n     * @param  {string} as  The name given to each item in the list\n     * @param  {bool} index Whether to calculate indexes\n     * @return {function}   A function(dataValue) that returns the context\n     */\n    createContextGenerator (as) {\n      const $ctx = this.$context;\n      if (as) {\n        return v => this._contextExtensions($ctx.extend({ [as]: v }))\n      } else {\n        return v => $ctx.createChildContext(v, null, ctx => this._contextExtensions(ctx))\n      }\n    }\n\n    updateFirstLastNodesList (index, children) {\n      const first = children[0];\n      const last = children[children.length - 1];\n      this.firstLastNodesList.splice(index, 0, { first, last });\n    }\n\n    // Process a changeItem with {status: 'added', ...}\n    added (changeItem) {\n      var index = changeItem.index;\n      var valuesToAdd = changeItem.isBatch ? changeItem.values : [changeItem.value];\n      var referenceElement = this.getLastNodeBeforeIndex(index);\n      // gather all childnodes for a possible batch insertion\n      const allChildNodes = [];\n      const asyncBindingResults = [];\n      var children;\n\n      for (var i = 0, len = valuesToAdd.length; i < len; ++i) {\n        // we check if we have a pending delete with reusable nodesets for this data, and if yes, we reuse one nodeset\n        var pendingDelete = this.getPendingDeleteFor(valuesToAdd[i]);\n        if (pendingDelete && pendingDelete.nodesets.length) {\n          children = pendingDelete.nodesets.pop();\n          this.updateFirstLastNodesList(index + i, children);\n        } else {\n          var templateClone = this.templateNode.cloneNode(true);\n          children = childNodes(templateClone);\n          this.updateFirstLastNodesList(index + i, children);\n\n          // Apply bindings first, and then process child nodes,\n          // because bindings can add childnodes.\n          const bindingResult = applyBindingsToDescendants(\n            this.generateContext(valuesToAdd[i]), templateClone\n          );\n          asyncBindingResults.push(bindingResult);\n        }\n\n        allChildNodes.push(...children);\n      }\n\n      if (typeof this.afterAdd === 'function') {\n        this.afterAdd({\n          nodeOrArrayInserted: this.insertAllAfter(allChildNodes, referenceElement),\n          foreachInstance: this\n        });\n      } else {\n        this.insertAllAfter(allChildNodes, referenceElement);\n      }\n\n      this.completeBinding(Promise.all(asyncBindingResults));\n    }\n\n    getNodesForIndex (index) {\n      let result = [];\n      let ptr = this.firstLastNodesList[index].first;\n      let last = this.firstLastNodesList[index].last;\n      result.push(ptr);\n      while (ptr && ptr !== last) {\n        ptr = ptr.nextSibling;\n        result.push(ptr);\n      }\n      return result\n    }\n\n    getLastNodeBeforeIndex (index) {\n      if (index < 1 || index - 1 >= this.firstLastNodesList.length) { return null }\n      return this.firstLastNodesList[index - 1].last\n    }\n\n    /**\n     * Get the active (focused) node, if it's a child of the given node.\n     */\n    activeChildElement (node) {\n      var active = document.activeElement;\n      if (domNodeIsContainedBy(active, node)) {\n        return active\n      }\n    }\n\n    insertAllAfter (nodeOrNodeArrayToInsert, insertAfterNode) {\n      let frag;\n      let len;\n      let i;\n      let active = null;\n      let containerNode = this.$element;\n\n      // Poor man's node and array check.\n      if (nodeOrNodeArrayToInsert.nodeType === undefined && nodeOrNodeArrayToInsert.length === undefined) {\n        throw new Error('Expected a single node or a node array')\n      }\n      if (nodeOrNodeArrayToInsert.nodeType !== undefined) {\n        active = this.activeChildElement(nodeOrNodeArrayToInsert);\n        insertAfter(containerNode, nodeOrNodeArrayToInsert, insertAfterNode);\n        return [nodeOrNodeArrayToInsert]\n      } else if (nodeOrNodeArrayToInsert.length === 1) {\n        active = this.activeChildElement(nodeOrNodeArrayToInsert[0]);\n        insertAfter(containerNode, nodeOrNodeArrayToInsert[0], insertAfterNode);\n      } else if (supportsDocumentFragment) {\n        frag = document.createDocumentFragment();\n        for (i = 0, len = nodeOrNodeArrayToInsert.length; i !== len; ++i) {\n          active = active || this.activeChildElement(nodeOrNodeArrayToInsert[i]);\n          frag.appendChild(nodeOrNodeArrayToInsert[i]);\n        }\n        insertAfter(containerNode, frag, insertAfterNode);\n      } else {\n        // Nodes are inserted in reverse order - pushed down immediately after\n        // the last node for the previous item or as the first node of element.\n        for (i = nodeOrNodeArrayToInsert.length - 1; i >= 0; --i) {\n          active = active || this.activeChildElement(nodeOrNodeArrayToInsert[i]);\n          var child = nodeOrNodeArrayToInsert[i];\n          if (!child) { break }\n          insertAfter(containerNode, child, insertAfterNode);\n        }\n      }\n\n      if (active) { active.focus(); }\n\n      return nodeOrNodeArrayToInsert\n    }\n\n    // checks if the deleted data item should be handled with delay for a possible reuse at additions\n    shouldDelayDeletion (data) {\n      return data && (typeof data === 'object' || typeof data === 'function')\n    }\n\n    // gets the pending deletion info for this data item\n    getPendingDeleteFor (data) {\n      var index = data && data[PENDING_DELETE_INDEX_SYM];\n      if (index === undefined) return null\n      return this.pendingDeletes[index]\n    }\n\n    // tries to find the existing pending delete info for this data item, and if it can't, it registeres one\n    getOrCreatePendingDeleteFor (data) {\n      var pd = this.getPendingDeleteFor(data);\n      if (pd) {\n        return pd\n      }\n      pd = {\n        data: data,\n        nodesets: []\n      };\n      data[PENDING_DELETE_INDEX_SYM] = this.pendingDeletes.length;\n      this.pendingDeletes.push(pd);\n      return pd\n    }\n\n    // Process a changeItem with {status: 'deleted', ...}\n    deleted (changeItem) {\n      // if we should delay the deletion of this data, we add the nodeset to the pending delete info object\n      if (this.shouldDelayDeletion(changeItem.value)) {\n        let pd = this.getOrCreatePendingDeleteFor(changeItem.value);\n        pd.nodesets.push(this.getNodesForIndex(changeItem.index));\n      } else { // simple data, just remove the nodes\n        this.removeNodes(this.getNodesForIndex(changeItem.index));\n      }\n      this.indexesToDelete.push(changeItem.index);\n    }\n\n    // removes a set of nodes from the DOM\n    removeNodes (nodes) {\n      if (!nodes.length) { return }\n\n      function removeFn () {\n        var parent = nodes[0].parentNode;\n        for (var i = nodes.length - 1; i >= 0; --i) {\n          cleanNode(nodes[i]);\n          parent.removeChild(nodes[i]);\n        }\n      }\n\n      if (this.beforeRemove) {\n        var beforeRemoveReturn = this.beforeRemove({\n          nodesToRemove: nodes, foreachInstance: this\n        }) || {};\n        // If beforeRemove returns a `then`â€“able e.g. a Promise, we remove\n        // the nodes when that thenable completes.  We pass any errors to\n        // ko.onError.\n        if (typeof beforeRemoveReturn.then === 'function') {\n          beforeRemoveReturn.then(removeFn, options.onError);\n        }\n      } else {\n        removeFn();\n      }\n    }\n\n    // flushes the pending delete info store\n    // this should be called after queue processing has finished, so that data items and remaining (not reused) nodesets get cleaned up\n    // we also call it on dispose not to leave any mess\n    flushPendingDeletes () {\n      for (let i = 0, len = this.pendingDeletes.length; i !== len; ++i) {\n        var pd = this.pendingDeletes[i];\n        while (pd.nodesets.length) {\n          this.removeNodes(pd.nodesets.pop());\n        }\n        if (pd.data && pd.data[PENDING_DELETE_INDEX_SYM] !== undefined) { delete pd.data[PENDING_DELETE_INDEX_SYM]; }\n      }\n      this.pendingDeletes = [];\n    }\n\n    // We batch our deletion of item indexes in our parallel array.\n    // See brianmhunt/knockout-fast-foreach#6/#8\n    clearDeletedIndexes () {\n      // We iterate in reverse on the presumption (following the unit tests) that KO's diff engine\n      // processes diffs (esp. deletes) monotonically ascending i.e. from index 0 -> N.\n      for (let i = this.indexesToDelete.length - 1; i >= 0; --i) {\n        this.firstLastNodesList.splice(this.indexesToDelete[i], 1);\n      }\n      this.indexesToDelete = [];\n    }\n\n    updateIndexes (fromIndex) {\n      let ctx;\n      for (let i = fromIndex, len = this.firstLastNodesList.length; i < len; ++i) {\n        ctx = this.getContextStartingFrom(this.firstLastNodesList[i].first);\n        if (ctx) { ctx.$index(i); }\n      }\n    }\n\n    getContextStartingFrom (node) {\n      let ctx;\n      while (node) {\n        ctx = contextFor(node);\n        if (ctx) { return ctx }\n        node = node.nextSibling;\n      }\n    }\n\n    /**\n     * Set whether the binding is always synchronous.\n     * Useful during testing.\n     */\n    static setSync (toggle) {\n      const w = options.global;\n      if (toggle) {\n        ForEachBinding.animateFrame = function (frame) { frame(); };\n      } else {\n        ForEachBinding.animateFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame ||\n          w.mozRequestAnimationFrame || w.msRequestAnimationFrame ||\n          function (cb) { return w.setTimeout(cb, 1000 / 60) };\n      }\n    }\n\n    get controlsDescendants () { return true }\n    static get allowVirtualElements () { return true }\n\n    /* TODO: Remove; for legacy/testing */\n    static get ForEach () { return this }\n    static get PENDING_DELETE_INDEX_SYM () { return PENDING_DELETE_INDEX_SYM }\n  }\n\n  var bindings$3 = {\n    foreach: ForEachBinding\n  };\n\n  // By default, foreach will be async.\n  ForEachBinding.setSync(false);\n\n  const DELAY_MS = 25;\n  const MAX_CLEAN_AT_ONCE = 1000;\n  const cleanNodeQueue = [];\n  let cleanNodeTimeoutID = null;\n\n  function queueCleanNode (node) {\n    cleanNodeQueue.push(node);\n    triggerCleanTimeout();\n  }\n\n  function triggerCleanTimeout () {\n    if (!cleanNodeTimeoutID && cleanNodeQueue.length) {\n      cleanNodeTimeoutID = setTimeout(flushCleanQueue, DELAY_MS);\n    }\n  }\n\n  function flushCleanQueue () {\n    cleanNodeTimeoutID = null;\n    const nodes = cleanNodeQueue.splice(0, MAX_CLEAN_AT_ONCE);\n    for (const node of nodes) { cleanNode(node); }\n    triggerCleanTimeout();\n  }\n\n  const ORIGINAL_JSX_SYM = Symbol('Knockout - Original JSX');\n\n  const NAMESPACES = {\n    svg: 'http://www.w3.org/2000/svg',\n    html: 'http://www.w3.org/1999/xhtml',\n    xml: 'http://www.w3.org/XML/1998/namespace',\n    xlink: 'http://www.w3.org/1999/xlink',\n    xmlns: 'http://www.w3.org/2000/xmlns/'\n  };\n\n  function isIterable (v) {\n    return v && typeof v[Symbol.iterator] === 'function'\n  }\n\n  /**\n   * JSX object from a pre-processor.\n   * @typedef {Object} JSX\n   * @property {string} elementName becomes the `tagName`\n   * @property {Array.<JSX>} children\n   * @property {object} attributes\n   */\n\n  /**\n   * Observe a variety of possible cases from JSX, modifying the\n   * `parentNode` at `insertBefore` with the result.\n   */\n  class JsxObserver extends LifeCycle {\n    /**\n     * @param {any} jsxOrObservable take a long list of permutations\n     */\n    constructor (jsxOrObservable, parentNode, insertBefore = null, xmlns, noInitialBinding) {\n      super();\n\n      const parentNodeIsComment = parentNode.nodeType === 8;\n\n      const parentNodeTarget = this.getParentTarget(parentNode);\n\n      if (isObservable(jsxOrObservable)) {\n        jsxOrObservable.extend({ trackArrayChanges: true });\n        this.subscribe(jsxOrObservable, this.observableArrayChange, 'arrayChange');\n\n        if (!insertBefore) {\n          const insertAt = parentNodeIsComment ? parentNode.nextSibling : null;\n          insertBefore = this.createComment('O');\n          parentNodeTarget.insertBefore(insertBefore, insertAt);\n        } else {\n          this.adoptedInsertBefore = true;\n        }\n      }\n\n      if (parentNodeIsComment && !insertBefore) {\n        // Typcially: insertBefore becomes <!-- /ko -->\n        insertBefore = parentNode.nextSibling;\n        // Mark this so we don't remove the next node - since we didn't create it.\n        this.adoptedInsertBefore = true;\n      }\n\n      this.anchorTo(insertBefore || parentNode);\n\n      Object.assign(this, {\n        insertBefore,\n        noInitialBinding,\n        parentNode,\n        parentNodeTarget,\n        xmlns,\n        nodeArrayOrObservableAtIndex: [],\n        subscriptionsForNode: new Map(),\n      });\n\n      const jsx = unwrap(jsxOrObservable);\n      const computed$$1 = isComputed(jsxOrObservable);\n\n      if (computed$$1 || (jsx !== null && jsx !== undefined)) {\n        this.observableArrayChange(this.createInitialAdditions(jsx));\n      }\n      this.noInitialBinding = false;\n    }\n\n    /**\n     * @param {HMTLElement|Comment|HTMLTemplateElement} parentNode\n     */\n    getParentTarget (parentNode) {\n      if ('content' in parentNode) { return parentNode.content }\n      if (parentNode.nodeType === 8) { return parentNode.parentNode }\n      return parentNode\n    }\n\n    remove () { this.dispose(); }\n    dispose () {\n      super.dispose();\n      const ib = this.insertBefore;\n      const insertBeforeIsChild = ib && this.parentNodeTarget === ib.parentNode;\n      if (insertBeforeIsChild && !this.adoptedInsertBefore) {\n        this.parentNodeTarget.removeChild(ib);\n      }\n      this.removeAllPriorNodes();\n      Object.assign(this, {\n        parentNode: null,\n        parentNodeTarget: null,\n        insertBefore: null,\n        nodeArrayOrObservableAtIndex: []\n      });\n      for (const subscriptions of this.subscriptionsForNode.values()) {\n        subscriptions.forEach(s => s.dispose());\n      }\n      this.subscriptionsForNode.clear();\n    }\n\n    createInitialAdditions (possibleIterable) {\n      const status = 'added';\n      if (typeof possibleIteratable === 'object' &&\n        posibleIterable !== null &&\n        Symbol.iterator in possibleIterable) {\n        possibleIterable = [...possibleIterable];\n      }\n\n      return Array.isArray(possibleIterable)\n        ? possibleIterable.map((value, index) => ({ index, status, value }))\n        : [{ status, index: 0, value: possibleIterable }]\n    }\n\n    /**\n     * Note: array change notification indexes are:\n     *   - to the original array indexes for deletes\n     *   - to the new array indexes for adds\n     *   - sorted by index in ascending order\n     */\n    observableArrayChange (changes) {\n      let adds = [];\n      let dels = [];\n      for (const index in changes) {\n        const change = changes[index];\n        if (change.status === 'added') {\n          adds.push([change.index, change.value]);\n        } else {\n          dels.unshift([change.index, change.value]);\n        }\n      }\n      dels.forEach(change => this.delChange(...change));\n      adds.forEach(change => this.addChange(...change));\n    }\n\n    /**\n     * Add a change at the given index.\n     *\n     * @param {int} index\n     * @param {string|object|Array|Observable.string|Observable.Array|Obseravble.object} jsx\n     */\n    addChange (index, jsx) {\n      this.nodeArrayOrObservableAtIndex.splice(index, 0,\n        this.injectNode(jsx, this.lastNodeFor(index)));\n    }\n\n    injectNode (jsx, nextNode) {\n      let nodeArrayOrObservable;\n\n      if (isObservable(jsx)) {\n        const {parentNode, xmlns} = this;\n        const observer = new JsxObserver(jsx, parentNode, nextNode, xmlns, this.noInitialBinding);\n        nodeArrayOrObservable = [observer];\n      } else if (typeof jsx !== 'string' && isIterable(jsx)) {\n        nodeArrayOrObservable = [];\n        for (const child of jsx) {\n          nodeArrayOrObservable.unshift(\n            this.injectNode(child, nextNode));\n        }\n      } else {\n        const $context = contextFor(this.parentNode);\n        const isInsideTemplate = 'content' in this.parentNode;\n        const shouldApplyBindings = $context && !isInsideTemplate && !this.noInitialBinding;\n\n        if (Array.isArray(jsx)) {\n          nodeArrayOrObservable = jsx.map(j => this.anyToNode(j));\n        } else {\n          nodeArrayOrObservable = [this.anyToNode(jsx)];\n        }\n\n        for (const node of nodeArrayOrObservable) {\n          this.parentNodeTarget.insertBefore(node, nextNode);\n          if (shouldApplyBindings && this.canApplyBindings(node)) {\n            applyBindings($context, node);\n          }\n        }\n      }\n\n      return nodeArrayOrObservable\n    }\n\n    /**\n     * True when Node is a type suitable for applyBindings i.e. a HTMLElement\n     * or a Comment.\n     * @param {Node} node\n     */\n    canApplyBindings (node) {\n      return node.nodeType === 1 || node.nodeType === 8\n    }\n\n    delChange (index) {\n      this.removeNodeArrayOrObservable(\n        this.nodeArrayOrObservableAtIndex[index]);\n      this.nodeArrayOrObservableAtIndex.splice(index, 1);\n    }\n\n    getSubscriptionsForNode (node) {\n      if (!this.subscriptionsForNode.has(node)) {\n        const subscriptions = [];\n        this.subscriptionsForNode.set(node, subscriptions);\n        return subscriptions\n      }\n      return this.subscriptionsForNode.get(node)\n    }\n\n    isJsx (jsx) {\n      return typeof jsx.elementName === 'string' &&\n        'children' in jsx &&\n        'attributes' in jsx\n    }\n\n    /**\n     * @param {any} value acceptable to turn into a Node\n     *\n     * The one thing `any` cannot be here is an Array or Observable; both those\n     * cases are handled with new JsxObservers.\n     */\n    anyToNode (any) {\n      if (isThenable(any)) { return this.futureJsxNode(any) }\n\n      switch (typeof any) {\n        case 'object':\n          if (any instanceof Error) {\n            return this.createComment(any.toString())\n          }\n          if (any === null) {\n            return this.createComment(String(any))\n          }\n          if (any instanceof Node) {\n            return this.cloneJSXorMoveNode(any)\n          }\n          if (Symbol.iterator in any) {\n            return any\n          }\n          break\n        case 'function': return this.anyToNode(any())\n        case 'undefined':\n        case 'Error':\n        case 'symbol':\n          return this.createComment(String(any))\n        case 'string': return this.createTextNode(any)\n        case 'boolean':\n        case 'number':\n        case 'bigint':\n        default:\n          return this.createTextNode(String(any))\n      }\n\n      return this.isJsx(any)\n        ? this.jsxToNode(any)\n        : this.createComment(safeStringify(any))\n    }\n\n    createComment (string) {\n      const node = document.createComment(string);\n      node[NATIVE_BINDINGS] = true;\n      return node\n    }\n\n    createTextNode (string) {\n      const node = document.createTextNode(string);\n      node[NATIVE_BINDINGS] = true;\n      return node\n    }\n\n    /**\n     * Clone a node; if that node was originally from JSX, we clone from there\n     * so we preserve binding handlers.\n     *\n     * @param {HTMLElement} node\n     */\n    cloneJSXorMoveNode (node) {\n      return ORIGINAL_JSX_SYM in node\n        ? this.jsxToNode(node[ORIGINAL_JSX_SYM])\n        : node\n    }\n\n    /**\n     * @param {JSX} jsx to convert to a node.\n     */\n    jsxToNode (jsx) {\n      const xmlns = jsx.attributes.xmlns || NAMESPACES[jsx.elementName] || this.xmlns;\n      const node = document.createElementNS(xmlns || NAMESPACES.html, jsx.elementName);\n\n      /** Slots need to be able to replicate with the attributes, which\n       *  are not preserved when cloning from template nodes. */\n      node[ORIGINAL_JSX_SYM] = jsx;\n\n      if (isObservable(jsx.attributes)) {\n        const subscriptions = this.getSubscriptionsForNode(node);\n        subscriptions.push(\n          jsx.attributes.subscribe(attrs => {\n            this.updateAttributes(node, unwrap(attrs));\n          }));\n      }\n      this.updateAttributes(node, unwrap(jsx.attributes));\n\n      this.addDisposable(new JsxObserver(jsx.children, node, null, xmlns, this.noInitialBinding));\n\n      return node\n    }\n\n    futureJsxNode (promise) {\n      const obs = observable();\n      promise.then(obs).catch(e => obs(e instanceof Error ? e : Error(e)));\n      const jo = new JsxObserver(obs, this.parentNode, null, this.xmlns, this.noInitialBinding);\n      this.addDisposable(jo);\n      return jo.insertBefore\n    }\n\n    updateAttributes (node, attributes) {\n      const subscriptions = this.getSubscriptionsForNode(node);\n      const toRemove = new Set([...node.attributes].map(n => n.name));\n\n      for (const [name, value] of Object.entries(attributes || {})) {\n        toRemove.delete(name);\n        if (isObservable(value)) {\n          subscriptions.push(\n            value.subscribe(attr => this.setNodeAttribute(node, name, value)));\n        }\n        this.setNodeAttribute(node, name, value);\n      }\n\n      for (const name of toRemove) {\n        this.setNodeAttribute(node, name, undefined);\n      }\n    }\n\n    /**\n     * See https://stackoverflow.com/a/52572048\n     * @param {string} attr element attribute\n     * @return {string} namespace argument for setAtttributeNS\n     */\n    getNamespaceOfAttribute (attr) {\n      const [prefix, ...unqualifiedName] = attr.split(':');\n      if (prefix === 'xmlns' || (unqualifiedName.length && NAMESPACES[prefix])) {\n        return NAMESPACES[prefix]\n      }\n      return null\n    }\n\n    /**\n     *\n     * @param {HTMLElement} node\n     * @param {string} name\n     * @param {any} valueOrObservable\n     */\n    setNodeAttribute (node, name, valueOrObservable) {\n      const value = unwrap(valueOrObservable);\n      NativeProvider.addValueToNode(node, name, valueOrObservable);\n      if (value === undefined) {\n        node.removeAttributeNS(null, name);\n      } else if (isThenable(valueOrObservable)) {\n        Promise.resolve(valueOrObservable)\n          .then(v => this.setNodeAttribute(node, name, v));\n      } else {\n        const ns = this.getNamespaceOfAttribute(name);\n        node.setAttributeNS(ns, name, String(value));\n      }\n    }\n\n    /**\n     * @param {int} index\n     * @return {Comment} that immediately precedes this.\n     */\n    lastNodeFor (index) {\n      const nodesAtIndex = this.nodeArrayOrObservableAtIndex[index] || [];\n      const [lastNodeOfPrior] = nodesAtIndex.slice(-1);\n      const insertBefore = lastNodeOfPrior instanceof JsxObserver\n        ? lastNodeOfPrior.insertBefore : lastNodeOfPrior || this.insertBefore;\n      if (insertBefore) { return insertBefore.parentNode ? insertBefore : null }\n      return null\n    }\n\n    removeAllPriorNodes () {\n      const {nodeArrayOrObservableAtIndex} = this;\n      while (nodeArrayOrObservableAtIndex.length) {\n        this.removeNodeArrayOrObservable(nodeArrayOrObservableAtIndex.pop());\n      }\n    }\n\n    removeNodeArrayOrObservable (nodeArrayOrObservable) {\n      for (const nodeOrObservable of nodeArrayOrObservable) {\n        if (nodeOrObservable instanceof JsxObserver) {\n          nodeOrObservable.dispose();\n          continue\n        }\n        const node = nodeOrObservable;\n        delete node[ORIGINAL_JSX_SYM];\n        this.detachAndDispose(node);\n        const subscriptions = this.subscriptionsForNode.get(node);\n        if (subscriptions) {\n          subscriptions.forEach(s => s.dispose());\n          this.subscriptionsForNode.delete(node);\n        }\n      }\n    }\n\n    /**\n     * Detach the given node, and dispose of its children.\n     *\n     * The cleaning can trigger a lot of garbage collection, so we defer that.\n     */\n    detachAndDispose (node) {\n      if (isIterable(node)) {\n        for (const child of node) {\n          this.detachAndDispose(child);\n        }\n      } else {\n        node.remove();\n      }\n      queueCleanNode(node);\n    }\n  }\n\n  /**\n   *\n   * @param {any} possibleJsx Test whether this value is JSX.\n   *\n   * True for\n   *    { elementName }\n   *    [{elementName}]\n   *    observable({elementName} | [])\n   *\n   * Any observable will return truthy if its value is an array that doesn't\n   * contain HTML elements.  Template nodes should not be observable unless they\n   * are JSX.\n   *\n   * There's a bit of guesswork here that we could nail down with more test cases.\n   */\n  function maybeJsx (possibleJsx) {\n    if (isObservable(possibleJsx)) { return true }\n    const value = unwrap(possibleJsx);\n    if (!value) { return false }\n    if (value.elementName) { return true }\n    if (!Array.isArray(value) || !value.length) { return false }\n    if (value[0] instanceof window.Node) { return false }\n    return true\n  }\n\n  function getOriginalJsxForNode (node) {\n    return node[ORIGINAL_JSX_SYM]\n  }\n\n\n  /**\n   * Convert JSX into an object that can be consumed by TKO.\n   * Mimics React.createElement\n   * @param {string} e tagName of the element\n   * @param {object|null} a attributes of the element\n   * @param  {...string|object} c children of the element\n   */\n  function createElement (elementName, attributes, ...children) {\n    return elementName === Fragment ? children\n      : {\n        elementName: elementName,\n        attributes: attributes || {},\n        children: [...children]\n      }\n  }\n\n  const Fragment = Symbol('JSX Fragment');\n\n  //\n\n  var componentLoadingOperationUniqueId = 0;\n\n  class ComponentBinding extends DescendantBindingHandler {\n    constructor (params) {\n      super(params);\n      this.originalChildNodes = makeArray(\n        childNodes(this.$element)\n      );\n      this.computed('computeApplyComponent');\n    }\n\n    cloneTemplateIntoElement (componentName, template, element) {\n      if (!template) {\n        throw new Error('Component \\'' + componentName + '\\' has no template')\n      }\n\n      if (maybeJsx(template)) {\n        emptyNode(element);\n        this.addDisposable(new JsxObserver(template, element, null, undefined, true));\n\n      } else {\n        const clonedNodesArray = cloneNodes(template);\n        setDomNodeChildren$1(element, clonedNodesArray);\n      }\n    }\n\n    createViewModel (componentDefinition, element, originalChildNodes, componentParams) {\n      const componentViewModelFactory = componentDefinition.createViewModel;\n      return componentViewModelFactory\n        ? componentViewModelFactory.call(componentDefinition, componentParams, { element, templateNodes: originalChildNodes })\n        : componentParams // Template-only component\n    }\n\n    /**\n     * Return the $componentTemplateSlotNodes for the given template\n     * @param {HTMLElement|jsx} template\n     */\n    makeTemplateSlotNodes (originalChildNodes) {\n      return Object.assign({}, ...this.genSlotsByName(originalChildNodes))\n    }\n\n    /**\n     * Iterate over the templateNodes, yielding each '<element slot=name>'\n     * as an object * of {name: element}.\n     * @param {HTMLElement} templateNodes\n     */\n    * genSlotsByName (templateNodes) {\n      for (const node of templateNodes) {\n        if (node.nodeType !== 1) { continue }\n        const slotName = node.getAttribute('slot');\n        if (!slotName) { continue }\n        yield {[slotName]: node};\n      }\n    }\n\n    computeApplyComponent () {\n      const value = unwrap(this.value);\n      let componentName;\n      let componentParams;\n\n      if (typeof value === 'string') {\n        componentName = value;\n      } else {\n        componentName = unwrap(value.name);\n        componentParams = NativeProvider.getNodeValues(this.$element) ||\n          unwrap(value.params);\n      }\n\n      this.latestComponentName = componentName;\n\n      if (!componentName) {\n        throw new Error('No component name specified')\n      }\n\n      this.loadingOperationId = this.currentLoadingOperationId = ++componentLoadingOperationUniqueId;\n      registry$1.get(componentName, (defn) => this.applyComponentDefinition(componentName, componentParams, defn));\n    }\n\n    makeChildBindingContext ($component) {\n      const ctxExtender = (ctx) => Object.assign(ctx, {\n        $component,\n        $componentTemplateNodes: this.originalChildNodes,\n        $componentTemplateSlotNodes: this.makeTemplateSlotNodes(\n          this.originalChildNodes)\n      });\n\n      return this.$context.createChildContext($component, undefined, ctxExtender)\n    }\n\n    applyComponentDefinition (componentName, componentParams, componentDefinition) {\n      // If this is not the current load operation for this element, ignore it.\n      if (this.currentLoadingOperationId !== this.loadingOperationId ||\n          this.latestComponentName !== componentName) { return }\n\n      // Clean up previous state\n      this.cleanUpState();\n\n      const element = this.$element;\n\n      // Instantiate and bind new component. Implicitly this cleans any old DOM nodes.\n      if (!componentDefinition) {\n        throw new Error('Unknown component \\'' + componentName + '\\'')\n      }\n\n      if (componentDefinition.template) {\n        this.cloneTemplateIntoElement(componentName, componentDefinition.template, element);\n      }\n\n      const componentViewModel = this.createViewModel(componentDefinition, element, this.originalChildNodes, componentParams);\n\n      this.childBindingContext = this.makeChildBindingContext(componentViewModel);\n\n      const viewTemplate = componentViewModel && componentViewModel.template;\n\n      if (!viewTemplate && !componentDefinition.template) {\n        throw new Error('Component \\'' + componentName + '\\' has no template')\n      }\n\n      if (!componentDefinition.template) {\n        this.cloneTemplateIntoElement(componentName, viewTemplate, element);\n      }\n\n      if (componentViewModel instanceof LifeCycle) {\n        componentViewModel.anchorTo(this.$element);\n      }\n\n      this.currentViewModel = componentViewModel;\n\n      const onBinding = this.onBindingComplete.bind(this, componentViewModel);\n      this.applyBindingsToDescendants(this.childBindingContext, onBinding);\n    }\n\n    onBindingComplete (componentViewModel, bindingResult) {\n      if (componentViewModel && componentViewModel.koDescendantsComplete) {\n        componentViewModel.koDescendantsComplete(this.$element);\n      }\n      this.completeBinding(bindingResult);\n    }\n\n    cleanUpState () {\n      const currentView = this.currentViewModel;\n      const currentViewDispose = currentView && currentView.dispose;\n      if (typeof currentViewDispose === 'function') {\n        currentViewDispose.call(currentView);\n      }\n      this.currentViewModel = null;\n      // Any in-flight loading operation is no longer relevant, so make sure we ignore its completion\n      this.currentLoadingOperationId = null;\n    }\n\n    dispose () {\n      this.cleanUpState();\n      super.dispose();\n    }\n\n    get controlsDescendants () { return true }\n    static get allowVirtualElements () { return true }\n  }\n\n  /**\n   * Slots work as follows (you'll note a similarity to vue).\n   *\n   * Component template definitions have <slot name='abc'> tags.\n   *\n   *    <template id='custom-component-template'>\n   *      <slot name='abc'>\n   *\n   * Component use these slots with e.g.\n   *\n   *    <custom-component>\n   *       <template slot='abc'>\n   *\n   * When the component template is rendered, the `slot` binding will map\n   * every binding to its respective slot.\n   */\n\n  /**\n   * SlotBinding replaces a slot with\n   */\n  class SlotBinding extends DescendantBindingHandler {\n    constructor (...params) {\n      super(...params);\n      const slotNode = this.getSlot(this.value);\n      const $slotContext = contextFor(slotNode);\n\n      const childContext = this.$context.extend({\n        $slotContext,\n        $slotData: $slotContext && $slotContext.$data\n      });\n\n      this.replaceSlotWithNode(this.$element, slotNode);\n\n      this.applyBindingsToDescendants(childContext);\n    }\n\n    /**\n     *\n     * @param {HTMLElement} nodeToReplace\n     * @param {HTMLElement}} slotValue\n     */\n    replaceSlotWithNode (nodeInComponentTemplate, slotNode) {\n      const nodes = this.cloneNodeFromOriginal(slotNode);\n      emptyNode(nodeInComponentTemplate);\n      this.addDisposable(new JsxObserver(nodes, nodeInComponentTemplate, undefined, undefined, true));\n    }\n\n    cloneNodeFromOriginal (node) {\n      if (!node) { return [] }\n      const jsx = getOriginalJsxForNode(node);\n      if (jsx) { return jsx.children }\n\n      if ('content' in node) {\n        const clone = document.importNode(node.content, true);\n        return [...clone.childNodes]\n      }\n\n      const nodeArray = Array.isArray(node) ? node : [node];\n      return nodeArray.map(n => n.cloneNode(true))\n    }\n\n\n    getSlot (slotName) {\n      const {$componentTemplateSlotNodes} = this.$context;\n\n      if (!slotName) {\n        return $componentTemplateSlotNodes[''] ||\n          [...this.$context.$componentTemplateNodes]\n            .filter(n => !n.getAttribute || !n.getAttribute('slot'))\n      }\n\n      return $componentTemplateSlotNodes[slotName]\n    }\n\n    static get allowVirtualElements () { return true }\n  }\n\n  var bindings$4 = { component: ComponentBinding, slot: SlotBinding };\n\n  var sproto = String.prototype;\n\n  var filters = {};\n\n  // Convert value to uppercase\n  filters.uppercase = function (value) {\n    return sproto.toUpperCase.call(unwrap(value))\n  };\n\n  // Convert value to lowercase\n  filters.lowercase = function (value) {\n    return sproto.toLowerCase.call(unwrap(value))\n  };\n\n  // Return default value if the input value is empty or null\n  filters['default'] = function (value, defaultValue) {\n    value = unwrap(value);\n    if (typeof value === 'function') {\n      return value\n    }\n    if (typeof value === 'string') {\n      return sproto.trim.call(value) === '' ? defaultValue : value\n    }\n    return value == null || value.length == 0 ? defaultValue : value\n  };\n\n  // Return the value with the search string replaced with the replacement string\n  filters.replace = function (value, search, replace) {\n    return sproto.replace.call(unwrap(value), search, replace)\n  };\n\n  filters.fit = function (value, length, replacement, trimWhere) {\n    value = unwrap(value);\n    if (length && ('' + value).length > length) {\n      replacement = '' + (replacement || '...');\n      length = length - replacement.length;\n      value = '' + value;\n      switch (trimWhere) {\n        case 'left':\n          return replacement + value.slice(-length)\n        case 'middle':\n          var leftLen = Math.ceil(length / 2);\n          return value.substr(0, leftLen) + replacement + value.slice(leftLen - length)\n        default:\n          return value.substr(0, length) + replacement\n      }\n    } else {\n      return value\n    }\n  };\n\n  // Convert a model object to JSON\n  filters.json = function (rootObject, space, replacer) {\n         // replacer and space are optional\n    return JSON.stringify(toJS(rootObject), replacer, space)\n  };\n\n  // Format a number using the browser's toLocaleString\n  filters.number = function (value) {\n    return (+unwrap(value)).toLocaleString()\n  };\n\n  var builder = new Builder({\r\n      filters: filters,\r\n      provider: new MultiProvider({\r\n          providers: [\r\n              new ComponentProvider(),\r\n              new NativeProvider(),\r\n              new AttributeMustacheProvider(),\r\n              new TextMustacheProvider(),\r\n              new DataBindProvider(),\r\n              new VirtualProvider(),\r\n              new AttrProvider(),\r\n          ]\r\n      }),\r\n      bindings: [\r\n          bindings$1,\r\n          bindings,\r\n          bindings$2,\r\n          bindings$3,\r\n          bindings$4,\r\n          { each: bindings$3.foreach }\r\n      ]\r\n  });\r\n  var index = builder.create({\r\n      jsx: {\r\n          createElement: createElement,\r\n          Fragment: Fragment\r\n      },\r\n      components: registry$1,\r\n      version: '4.0.0-alpha9.0',\r\n      Component: registry$1.ComponentABC\r\n  });\n\n  return index;\n\n})));\n//# sourceMappingURL=build.reference.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRrby9idWlsZC5yZWZlcmVuY2UvZGlzdC9idWlsZC5yZWZlcmVuY2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQsRUFBRSxDQUN1QjtBQUN6QixDQUFDLHNCQUFzQjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7O0FBRWxCO0FBQ0EsZ0NBQWdDO0FBQ2hDLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0NBQStDLE9BQU8sT0FBTztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLE1BQU07QUFDTix1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVSxPQUFPO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0ZBQXdGO0FBQzNILG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlDQUFpQztBQUN6RSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsc0JBQXNCO0FBQ2pHLGlEQUFpRCwwQkFBMEIsZ0JBQWdCO0FBQzNGO0FBQ0E7O0FBRUEsNkNBQTZDLGtHQUFrRyxPQUFPO0FBQ3RKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0JBQStCO0FBQ3hFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQscUJBQXFCO0FBQzlFO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1IsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBLDRFQUE0RTtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLG9CQUFvQixZQUFZLFVBQVUscUJBQU07O0FBRXhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixTQUFTOztBQUVyQztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCLEdBQUc7O0FBRUg7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGFBQWE7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDLGdDQUFnQyxlQUFlO0FBQy9DLG9DQUFvQztBQUNwQyxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1EQUFtRCxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsdUJBQXVCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNCQUFzQixzQkFBc0IsT0FBTztBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxPQUFPLE9BQU87QUFDbkU7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2YsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0QsT0FBTztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLE9BQU87QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU8sT0FBTztBQUM5RCxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQSwrRkFBK0Y7O0FBRS9GO0FBQ0EsZ0lBQWdJOztBQUVoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsbURBQW1ELE9BQU87QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsTUFBTSxPQUFPLGNBQWM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9DQUFvQztBQUNsRDtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFrQyxPQUFPLGtDQUFrQztBQUNqRyxjQUFjO0FBQ2Qsa0RBQWtEO0FBQ2xEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQSxrREFBa0QsT0FBTyxPQUFPO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsd0NBQXdDO0FBQ3pFO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyx1RUFBdUUsT0FBTztBQUNwSCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EseUNBQXlDLHlFQUF5RSxPQUFPO0FBQ3pILE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSLDJCQUEyQjtBQUMzQjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjs7QUFFakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZELHdDQUF3Qyx1RUFBdUUsT0FBTztBQUN0SDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIsd0JBQXdCLE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9DQUFvQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUIsbUNBQW1DO0FBQ3BGLE1BQU07QUFDTiwrRUFBK0UsT0FBTyxPQUFPO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxNQUFNLFVBQVU7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLDJCQUEyQjtBQUMzQiw2QkFBNkIscUNBQXFDO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlCQUFpQjtBQUN0RSwyQkFBMkI7QUFDM0IsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRUFBMEU7QUFDMUUscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixhQUFhOztBQUUxQztBQUNBLGtDQUFrQztBQUNsQztBQUNBLEtBQUs7O0FBRUw7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLGdEQUFnRCxnQ0FBZ0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLGNBQWMsbURBQW1EOztBQUVqRSxrQkFBa0IsMEJBQTBCOztBQUU1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBLHFEQUFxRCxrQkFBa0I7O0FBRXZFOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsa0JBQWtCO0FBQ3hFLDBDQUEwQztBQUMxQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5QjtBQUMxRCxpREFBaUQsNEJBQTRCO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0lBQXdJO0FBQ3hJLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQSx3SUFBd0k7QUFDeEk7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx5Q0FBeUMsa0NBQWtDLGFBQWE7O0FBRXhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNERBQTRELE9BQU87QUFDekY7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUIsT0FBTzs7QUFFcEQ7QUFDQSx3REFBd0Q7QUFDeEQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0NBQXNDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDLG1DQUFtQyxZQUFZO0FBQy9DLG1DQUFtQyxZQUFZO0FBQy9DLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsK0JBQStCLGNBQWM7QUFDN0MsK0JBQStCLGNBQWM7QUFDN0M7QUFDQSwrQkFBK0IsY0FBYztBQUM3QywrQkFBK0IsNEJBQTRCO0FBQzNELGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUMsK0JBQStCLGVBQWU7QUFDOUMsOEJBQThCLGNBQWM7QUFDNUMsK0JBQStCLGVBQWU7QUFDOUMsd0NBQXdDLGdCQUFnQjtBQUN4RCxnREFBZ0Qsd0JBQXdCO0FBQ3hFO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRCwrQkFBK0IsZ0JBQWdCO0FBQy9DLG9DQUFvQyxnQkFBZ0I7QUFDcEQsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hELCtCQUErQixjQUFjO0FBQzdDLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQsb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQyxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUEsbUNBQW1DLE9BQU87QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixzQkFBc0I7QUFDckQ7O0FBRUEscUVBQXFFO0FBQ3JFO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DOztBQUVBLG1CQUFtQjs7QUFFbkIscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMkJBQTJCLE1BQU0sRUFBRSxLQUFLO0FBQ3hDLE1BQU0sVUFBVTtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQjtBQUNBLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2Qiw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLG9CQUFvQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEIseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0EsU0FBUyxXQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUdBQWlHO0FBQ3pHO0FBQ0E7QUFDQSxRQUFRLDRDQUE0QztBQUNwRDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhDQUE4QyxVQUFVO0FBQ2hFO0FBQ0EsUUFBUSw4Q0FBOEMsVUFBVTtBQUNoRTtBQUNBLDRDQUE0QztBQUM1QyxRQUFRLDZEQUE2RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0Q7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMkZBQTJGLDJCQUEyQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RixNQUFNO0FBQ04sNENBQTRDLGlDQUFpQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFdBQVcsZ0JBQWdCO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsMENBQTBDO0FBQzFDLDJCQUEyQix1QkFBdUI7QUFDbEQsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDBCQUEwQixzQ0FBc0M7QUFDaEUsdUNBQXVDLDZDQUE2QztBQUNwRiw0Q0FBNEMsa0RBQWtEO0FBQzlGLDZCQUE2Qix5Q0FBeUM7QUFDdEUsd0JBQXdCLG9DQUFvQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDLG9DQUFvQztBQUNwQyxpQ0FBaUM7O0FBRWpDLHlCQUF5Qix3Q0FBd0M7O0FBRWpFO0FBQ0EsZ0VBQWdFLGlCQUFpQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QyxRQUFRO0FBQ1I7QUFDQSxzREFBc0Q7QUFDdEQsbUJBQW1CO0FBQ25CLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5QkFBeUIsYUFBYTtBQUM3RSx1REFBdUQ7QUFDdkQsMkJBQTJCO0FBQzNCLDhCQUE4Qjs7QUFFOUIsdUNBQXVDLE1BQU07QUFDN0MsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0EsZ0ZBQWdGLDRCQUE0QjtBQUM1RztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsK0NBQStDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdEQUFnRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDLHlDQUF5QztBQUN6QywwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0EsaUJBQWlCO0FBQ2pCLHdCQUF3QjtBQUN4Qjs7QUFFQSx3REFBd0Q7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSw4QkFBOEI7QUFDOUIsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0VBQXdFO0FBQ3RHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0VBQWtFO0FBQ2xHO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxNQUFNO0FBQ04sZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxVQUFVLG9FQUFvRSx1REFBdUQ7QUFDMUksYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyRkFBMkYscUJBQXFCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQsZ0NBQWdDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQsNkJBQTZCO0FBQzFGO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUEwQztBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrREFBa0QsMENBQTBDLE9BQU87QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsdUNBQXVDLDRDQUE0QztBQUNuRjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DLDRCQUE0QjtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQSxNQUFNO0FBQ047QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxxQ0FBcUM7QUFDckM7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxPQUFPO0FBQ1A7QUFDQSwwREFBMEQ7QUFDMUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBO0FBQ0Esb0pBQW9KOztBQUVwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3Qyw4RUFBOEU7QUFDdEg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSw0QkFBNEI7O0FBRTNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUiwyR0FBMkcseUJBQXlCO0FBQ3BJOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPLFVBQVUsc0NBQXNDO0FBQ3ZEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkRBQTZELHlCQUF5QjtBQUN0RixpQkFBaUIsc0NBQXNDLGdDQUFnQyx5Q0FBeUM7QUFDaEk7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix3RkFBd0Y7QUFDM0c7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQ0FBa0M7QUFDckUscUNBQXFDO0FBQ3JDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQkFBMkIsS0FBSztBQUN4Qyx1Q0FBdUM7QUFDdkMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0JBQWtCLEVBQUUsU0FBUyxHQUFHLE9BQU87QUFDdkM7O0FBRUEsZ0JBQWdCLFlBQVksSUFBSSxNQUFNO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0IsaUJBQWlCLHlCQUF5QixJQUFJLE1BQU07QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixlQUFlOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVixpQ0FBaUMsd0NBQXdDO0FBQ3pFO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFDQUFxQztBQUN6RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLCtCQUErQjtBQUN4RTtBQUNBLFVBQVUsZ0ZBQWdGLE9BQU87QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTiw4REFBOEQ7QUFDOUQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RCxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix5QkFBeUI7QUFDOUMsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0EsNEJBQTRCLGVBQWU7O0FBRTNDO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxlQUFlO0FBQ2Y7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7O0FBRTNDLG9CQUFvQjs7QUFFcEI7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUF1RDtBQUN2RCwrQkFBK0I7QUFDL0IsbUNBQW1DOztBQUVuQyx1Q0FBdUMsT0FBTztBQUM5QztBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qiw2Q0FBNkM7QUFDN0MsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFlBQVksRUFBRTtBQUN0RCx5Q0FBeUMsRUFBRSxXQUFXO0FBQ3RELHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4QkFBOEIseUJBQXlCLG9CQUFvQjtBQUNuRjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiwwQ0FBMEMsVUFBVTtBQUMxRTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7O0FBRTNDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELHFEQUFxRCxNQUFNO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUTtBQUNqRTtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsU0FBUztBQUMxRTtBQUNBO0FBQ0Esd0JBQXdCLDJEQUEyRDtBQUNuRjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsU0FBUyxJQUFJLEtBQUssUUFBUSxLQUFLLE1BQU0sS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlOztBQUUzQztBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7O0FBRTVFLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qix3QkFBd0I7O0FBRXhCO0FBQ0Esb0NBQW9DO0FBQ3BDLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DLG1DQUFtQztBQUN2RTs7QUFFQTtBQUNBLG1DQUFtQyxtQ0FBbUM7O0FBRXRFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCwyQkFBMkI7QUFDaEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNFQUFzRTtBQUNyRiw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLDJCQUEyQjs7QUFFM0I7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0VBQWtFO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxpQ0FBaUM7QUFDNUU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9COztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSx3RUFBd0U7QUFDeEUsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOERBQThELHNCQUFzQjtBQUNwRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxrQkFBa0IsMkJBQTJCLHVEQUF1RDtBQUNwRyxrQkFBa0IsMkJBQTJCLGlFQUFpRTtBQUM5RyxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBLHVGQUF1RjtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVMsa0NBQWtDOztBQUUzQztBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxRUFBcUU7QUFDbkYsNkNBQTZDO0FBQzdDLHdDQUF3QywwQkFBMEIsT0FBTztBQUN6RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGtCQUFrQjtBQUN4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RDs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxlQUFlOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmOztBQUVBLGlDQUFpQztBQUNqQyx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQLHdCQUF3QixtREFBbUQ7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLCtCQUErQjtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFNBQVM7QUFDckU7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkUsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxXQUFXO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRSxTQUFTO0FBQzdFO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pELFFBQVE7QUFDUjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDLHlDQUF5Qzs7QUFFekMscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1Qiw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsYUFBYTtBQUM3QixnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWlDLHlCQUF5QjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUseUNBQXlDO0FBQ3hEO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Qsc0JBQXNCO0FBQzFFLGFBQWEsMkNBQTJDO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSwwRUFBMEU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVLFlBQVk7QUFDdEIsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLGtCQUFrQjtBQUNsQiw2QkFBNkI7QUFDN0Isa0RBQWtEO0FBQ2xELDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsYUFBYTtBQUMxQixjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDRDQUE0QztBQUM3SDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QyxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EseUJBQXlCO0FBQ3pCLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQyx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsYUFBYSw2QkFBNkI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7O0FBRUEscUJBQXFCOztBQUVyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUEsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0a28vYnVpbGQucmVmZXJlbmNlL2Rpc3QvYnVpbGQucmVmZXJlbmNlLmpzPzU0ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgVEtPIFJlZmVyZW5jZSBCdWlsZCDwn6WKICBAdGtvL2J1aWxkLnJlZmVyZW5jZUA0LjAuMC1hbHBoYTkuMFxuICogKGMpIFRoZSBLbm9ja291dC5qcyBUZWFtIC0gaHR0cHM6Ly90a28uaW9cbiAqIExpY2Vuc2U6IE1JVCAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsLmtvID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vXG4gIC8vIEFycmF5IHV0aWxpdGllc1xuICAvL1xuICAvLyBOb3RlIHRoYXQgdGhlIGFycmF5IGZ1bmN0aW9ucyBtYXkgYmUgY2FsbGVkIHdpdGhcbiAgLy8gQXJyYXktbGlrZSB0aGluZ3MsIHN1Y2ggYXMgTm9kZUxpc3QuXG5cbiAgY29uc3Qge2lzQXJyYXl9ID0gQXJyYXk7XG5cbiAgZnVuY3Rpb24gYXJyYXlGb3JFYWNoIChhcnJheSwgYWN0aW9uLCB0aGlzQXJnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7IGFjdGlvbiA9IGFjdGlvbi5iaW5kKHRoaXNBcmcpOyB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgIGFjdGlvbihhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyYXksIGl0ZW0pIHtcbiAgICByZXR1cm4gKGlzQXJyYXkoYXJyYXkpID8gYXJyYXkgOiBbLi4uYXJyYXldKS5pbmRleE9mKGl0ZW0pXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUZpcnN0IChhcnJheSwgcHJlZGljYXRlLCBwcmVkaWNhdGVPd25lcikge1xuICAgIHJldHVybiAoaXNBcnJheShhcnJheSkgPyBhcnJheSA6IFsuLi5hcnJheV0pXG4gICAgICAuZmluZChwcmVkaWNhdGUsIHByZWRpY2F0ZU93bmVyKVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlNYXAgKGFycmF5ID0gW10sIG1hcHBpbmcsIHRoaXNBcmcpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHsgbWFwcGluZyA9IG1hcHBpbmcuYmluZCh0aGlzQXJnKTsgfVxuICAgIHJldHVybiBhcnJheSA9PT0gbnVsbCA/IFtdIDogQXJyYXkuZnJvbShhcnJheSwgbWFwcGluZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5UmVtb3ZlSXRlbSAoYXJyYXksIGl0ZW1Ub1JlbW92ZSkge1xuICAgIHZhciBpbmRleCA9IGFycmF5SW5kZXhPZihhcnJheSwgaXRlbVRvUmVtb3ZlKTtcbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIGFycmF5LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlHZXREaXN0aW5jdFZhbHVlcyAoYXJyYXkgPSBbXSkge1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgaWYgKGFycmF5ID09PSBudWxsKSB7IHJldHVybiBbXSB9XG4gICAgcmV0dXJuIChpc0FycmF5KGFycmF5KSA/IGFycmF5IDogWy4uLmFycmF5XSlcbiAgICAgIC5maWx0ZXIoaXRlbSA9PiBzZWVuLmhhcyhpdGVtKSA/IGZhbHNlIDogc2Vlbi5hZGQoaXRlbSkpXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUZpbHRlciAoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikgeyBwcmVkaWNhdGUgPSBwcmVkaWNhdGUuYmluZCh0aGlzQXJnKTsgfVxuICAgIHJldHVybiBhcnJheSA9PT0gbnVsbCA/IFtdIDogKGlzQXJyYXkoYXJyYXkpID8gYXJyYXkgOiBbLi4uYXJyYXldKS5maWx0ZXIocHJlZGljYXRlKVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlQdXNoQWxsIChhcnJheSwgdmFsdWVzVG9QdXNoKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWVzVG9QdXNoKSkge1xuICAgICAgYXJyYXkucHVzaC5hcHBseShhcnJheSwgdmFsdWVzVG9QdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB2YWx1ZXNUb1B1c2gubGVuZ3RoOyBpIDwgajsgaSsrKSB7IGFycmF5LnB1c2godmFsdWVzVG9QdXNoW2ldKTsgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE9yUmVtb3ZlSXRlbSAoYXJyYXksIHZhbHVlLCBpbmNsdWRlZCkge1xuICAgIHZhciBleGlzdGluZ0VudHJ5SW5kZXggPSBhcnJheUluZGV4T2YodHlwZW9mIGFycmF5LnBlZWsgPT09ICdmdW5jdGlvbicgPyBhcnJheS5wZWVrKCkgOiBhcnJheSwgdmFsdWUpO1xuICAgIGlmIChleGlzdGluZ0VudHJ5SW5kZXggPCAwKSB7XG4gICAgICBpZiAoaW5jbHVkZWQpIHsgYXJyYXkucHVzaCh2YWx1ZSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFpbmNsdWRlZCkgeyBhcnJheS5zcGxpY2UoZXhpc3RpbmdFbnRyeUluZGV4LCAxKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VBcnJheSAoYXJyYXlMaWtlT2JqZWN0KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXlMaWtlT2JqZWN0KVxuICB9XG5cbiAgZnVuY3Rpb24gcmFuZ2UgKG1pbiwgbWF4KSB7XG4gICAgbWluID0gdHlwZW9mIG1pbiA9PT0gJ2Z1bmN0aW9uJyA/IG1pbigpIDogbWluO1xuICAgIG1heCA9IHR5cGVvZiBtYXggPT09ICdmdW5jdGlvbicgPyBtYXgoKSA6IG1heDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IG1pbjsgaSA8PSBtYXg7IGkrKykgeyByZXN1bHQucHVzaChpKTsgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIEdvIHRocm91Z2ggdGhlIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIGFuZCBkZWxldGVkIGFuZCB0cnkgdG8gZmluZCBtYXRjaGVzIGJldHdlZW4gdGhlbS5cbiAgZnVuY3Rpb24gZmluZE1vdmVzSW5BcnJheUNvbXBhcmlzb24gKGxlZnQsIHJpZ2h0LCBsaW1pdEZhaWxlZENvbXBhcmVzKSB7XG4gICAgaWYgKGxlZnQubGVuZ3RoICYmIHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgdmFyIGZhaWxlZENvbXBhcmVzLCBsLCByLCBsZWZ0SXRlbSwgcmlnaHRJdGVtO1xuICAgICAgZm9yIChmYWlsZWRDb21wYXJlcyA9IGwgPSAwOyAoIWxpbWl0RmFpbGVkQ29tcGFyZXMgfHwgZmFpbGVkQ29tcGFyZXMgPCBsaW1pdEZhaWxlZENvbXBhcmVzKSAmJiAobGVmdEl0ZW0gPSBsZWZ0W2xdKTsgKytsKSB7XG4gICAgICAgIGZvciAociA9IDA7IHJpZ2h0SXRlbSA9IHJpZ2h0W3JdOyArK3IpIHtcbiAgICAgICAgICBpZiAobGVmdEl0ZW0udmFsdWUgPT09IHJpZ2h0SXRlbS52YWx1ZSkge1xuICAgICAgICAgICAgbGVmdEl0ZW0ubW92ZWQgPSByaWdodEl0ZW0uaW5kZXg7XG4gICAgICAgICAgICByaWdodEl0ZW0ubW92ZWQgPSBsZWZ0SXRlbS5pbmRleDtcbiAgICAgICAgICAgIHJpZ2h0LnNwbGljZShyLCAxKTsgICAgICAgICAvLyBUaGlzIGl0ZW0gaXMgbWFya2VkIGFzIG1vdmVkOyBzbyByZW1vdmUgaXQgZnJvbSByaWdodCBsaXN0XG4gICAgICAgICAgICBmYWlsZWRDb21wYXJlcyA9IHIgPSAwOyAgICAgLy8gUmVzZXQgZmFpbGVkIGNvbXBhcmVzIGNvdW50IGJlY2F1c2Ugd2UncmUgY2hlY2tpbmcgZm9yIGNvbnNlY3V0aXZlIGZhaWx1cmVzXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmYWlsZWRDb21wYXJlcyArPSByO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0YXR1c05vdEluT2xkID0gJ2FkZGVkJztcbiAgY29uc3Qgc3RhdHVzTm90SW5OZXcgPSAnZGVsZXRlZCc7XG5cbiAgICAgIC8vIFNpbXBsZSBjYWxjdWxhdGlvbiBiYXNlZCBvbiBMZXZlbnNodGVpbiBkaXN0YW5jZS5cbiAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyAob2xkQXJyYXksIG5ld0FycmF5LCBvcHRpb25zKSB7XG4gICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgaWYgdGhlIHRoaXJkIGFyZyBpcyBhY3R1YWxseSBhIGJvb2wsIGludGVycHJldFxuICAgICAgLy8gaXQgYXMgdGhlIG9sZCBwYXJhbWV0ZXIgJ2RvbnRMaW1pdE1vdmVzJy4gTmV3ZXIgY29kZSBzaG91bGQgdXNlIHsgZG9udExpbWl0TW92ZXM6IHRydWUgfS5cbiAgICBvcHRpb25zID0gKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpID8geyBkb250TGltaXRNb3Zlczogb3B0aW9ucyB9IDogKG9wdGlvbnMgfHwge30pO1xuICAgIG9sZEFycmF5ID0gb2xkQXJyYXkgfHwgW107XG4gICAgbmV3QXJyYXkgPSBuZXdBcnJheSB8fCBbXTtcblxuICAgIGlmIChvbGRBcnJheS5sZW5ndGggPCBuZXdBcnJheS5sZW5ndGgpIHsgcmV0dXJuIGNvbXBhcmVTbWFsbEFycmF5VG9CaWdBcnJheShvbGRBcnJheSwgbmV3QXJyYXksIHN0YXR1c05vdEluT2xkLCBzdGF0dXNOb3RJbk5ldywgb3B0aW9ucykgfSBlbHNlIHsgcmV0dXJuIGNvbXBhcmVTbWFsbEFycmF5VG9CaWdBcnJheShuZXdBcnJheSwgb2xkQXJyYXksIHN0YXR1c05vdEluTmV3LCBzdGF0dXNOb3RJbk9sZCwgb3B0aW9ucykgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZVNtYWxsQXJyYXlUb0JpZ0FycmF5IChzbWxBcnJheSwgYmlnQXJyYXksIHN0YXR1c05vdEluU21sLCBzdGF0dXNOb3RJbkJpZywgb3B0aW9ucykge1xuICAgIHZhciBteU1pbiA9IE1hdGgubWluLFxuICAgICAgbXlNYXggPSBNYXRoLm1heCxcbiAgICAgIGVkaXREaXN0YW5jZU1hdHJpeCA9IFtdLFxuICAgICAgc21sSW5kZXgsIHNtbEluZGV4TWF4ID0gc21sQXJyYXkubGVuZ3RoLFxuICAgICAgYmlnSW5kZXgsIGJpZ0luZGV4TWF4ID0gYmlnQXJyYXkubGVuZ3RoLFxuICAgICAgY29tcGFyZVJhbmdlID0gKGJpZ0luZGV4TWF4IC0gc21sSW5kZXhNYXgpIHx8IDEsXG4gICAgICBtYXhEaXN0YW5jZSA9IHNtbEluZGV4TWF4ICsgYmlnSW5kZXhNYXggKyAxLFxuICAgICAgdGhpc1JvdywgbGFzdFJvdyxcbiAgICAgIGJpZ0luZGV4TWF4Rm9yUm93LCBiaWdJbmRleE1pbkZvclJvdztcblxuICAgIGZvciAoc21sSW5kZXggPSAwOyBzbWxJbmRleCA8PSBzbWxJbmRleE1heDsgc21sSW5kZXgrKykge1xuICAgICAgbGFzdFJvdyA9IHRoaXNSb3c7XG4gICAgICBlZGl0RGlzdGFuY2VNYXRyaXgucHVzaCh0aGlzUm93ID0gW10pO1xuICAgICAgYmlnSW5kZXhNYXhGb3JSb3cgPSBteU1pbihiaWdJbmRleE1heCwgc21sSW5kZXggKyBjb21wYXJlUmFuZ2UpO1xuICAgICAgYmlnSW5kZXhNaW5Gb3JSb3cgPSBteU1heCgwLCBzbWxJbmRleCAtIDEpO1xuICAgICAgZm9yIChiaWdJbmRleCA9IGJpZ0luZGV4TWluRm9yUm93OyBiaWdJbmRleCA8PSBiaWdJbmRleE1heEZvclJvdzsgYmlnSW5kZXgrKykge1xuICAgICAgICBpZiAoIWJpZ0luZGV4KSB7XG4gICAgICAgICAgdGhpc1Jvd1tiaWdJbmRleF0gPSBzbWxJbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoIXNtbEluZGV4KSB7XG4gICAgICAgICAgIC8vIFRvcCByb3cgLSB0cmFuc2Zvcm0gZW1wdHkgYXJyYXkgaW50byBuZXcgYXJyYXkgdmlhIGFkZGl0aW9uc1xuICAgICAgICAgIHRoaXNSb3dbYmlnSW5kZXhdID0gYmlnSW5kZXggKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKHNtbEFycmF5W3NtbEluZGV4IC0gMV0gPT09IGJpZ0FycmF5W2JpZ0luZGV4IC0gMV0pIHtcbiAgICAgICAgICB0aGlzUm93W2JpZ0luZGV4XSA9IGxhc3RSb3dbYmlnSW5kZXggLSAxXTtcbiAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAvLyBjb3B5IHZhbHVlIChubyBlZGl0KVxuICAgICAgICAgIHZhciBub3J0aERpc3RhbmNlID0gbGFzdFJvd1tiaWdJbmRleF0gfHwgbWF4RGlzdGFuY2U7ICAgICAgIC8vIG5vdCBpbiBiaWcgKGRlbGV0aW9uKVxuICAgICAgICAgIHZhciB3ZXN0RGlzdGFuY2UgPSB0aGlzUm93W2JpZ0luZGV4IC0gMV0gfHwgbWF4RGlzdGFuY2U7ICAgIC8vIG5vdCBpbiBzbWFsbCAoYWRkaXRpb24pXG4gICAgICAgICAgdGhpc1Jvd1tiaWdJbmRleF0gPSBteU1pbihub3J0aERpc3RhbmNlLCB3ZXN0RGlzdGFuY2UpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlZGl0U2NyaXB0ID0gW10sIG1lTWludXNPbmUsIG5vdEluU21sID0gW10sIG5vdEluQmlnID0gW107XG4gICAgZm9yIChzbWxJbmRleCA9IHNtbEluZGV4TWF4LCBiaWdJbmRleCA9IGJpZ0luZGV4TWF4OyBzbWxJbmRleCB8fCBiaWdJbmRleDspIHtcbiAgICAgIG1lTWludXNPbmUgPSBlZGl0RGlzdGFuY2VNYXRyaXhbc21sSW5kZXhdW2JpZ0luZGV4XSAtIDE7XG4gICAgICBpZiAoYmlnSW5kZXggJiYgbWVNaW51c09uZSA9PT0gZWRpdERpc3RhbmNlTWF0cml4W3NtbEluZGV4XVtiaWdJbmRleCAtIDFdKSB7XG4gICAgICAgIG5vdEluU21sLnB1c2goZWRpdFNjcmlwdFtlZGl0U2NyaXB0Lmxlbmd0aF0gPSB7ICAgICAvLyBhZGRlZFxuICAgICAgICAgICdzdGF0dXMnOiBzdGF0dXNOb3RJblNtbCxcbiAgICAgICAgICAndmFsdWUnOiBiaWdBcnJheVstLWJpZ0luZGV4XSxcbiAgICAgICAgICAnaW5kZXgnOiBiaWdJbmRleCB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc21sSW5kZXggJiYgbWVNaW51c09uZSA9PT0gZWRpdERpc3RhbmNlTWF0cml4W3NtbEluZGV4IC0gMV1bYmlnSW5kZXhdKSB7XG4gICAgICAgIG5vdEluQmlnLnB1c2goZWRpdFNjcmlwdFtlZGl0U2NyaXB0Lmxlbmd0aF0gPSB7ICAgICAvLyBkZWxldGVkXG4gICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1c05vdEluQmlnLFxuICAgICAgICAgICd2YWx1ZSc6IHNtbEFycmF5Wy0tc21sSW5kZXhdLFxuICAgICAgICAgICdpbmRleCc6IHNtbEluZGV4IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLS1iaWdJbmRleDtcbiAgICAgICAgLS1zbWxJbmRleDtcbiAgICAgICAgaWYgKCFvcHRpb25zLnNwYXJzZSkge1xuICAgICAgICAgIGVkaXRTY3JpcHQucHVzaCh7XG4gICAgICAgICAgICAnc3RhdHVzJzogJ3JldGFpbmVkJyxcbiAgICAgICAgICAgICd2YWx1ZSc6IGJpZ0FycmF5W2JpZ0luZGV4XSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgICAgLy8gU2V0IGEgbGltaXQgb24gdGhlIG51bWJlciBvZiBjb25zZWN1dGl2ZSBub24tbWF0Y2hpbmcgY29tcGFyaXNvbnM7IGhhdmluZyBpdCBhIG11bHRpcGxlIG9mXG4gICAgICAvLyBzbWxJbmRleE1heCBrZWVwcyB0aGUgdGltZSBjb21wbGV4aXR5IG9mIHRoaXMgYWxnb3JpdGhtIGxpbmVhci5cbiAgICBmaW5kTW92ZXNJbkFycmF5Q29tcGFyaXNvbihub3RJbkJpZywgbm90SW5TbWwsICFvcHRpb25zLmRvbnRMaW1pdE1vdmVzICYmIHNtbEluZGV4TWF4ICogMTApO1xuXG4gICAgcmV0dXJuIGVkaXRTY3JpcHQucmV2ZXJzZSgpXG4gIH1cblxuICAvL1xuICAvLyBUaGlzIGJlY29tZXMga28ub3B0aW9uc1xuICAvLyAtLVxuICAvL1xuICAvLyBUaGlzIGlzIHRoZSByb290ICdvcHRpb25zJywgd2hpY2ggbXVzdCBiZSBleHRlbmRlZCBieSBvdGhlcnMuXG5cbiAgdmFyIF9nbG9iYWw7XG5cbiAgdHJ5IHsgX2dsb2JhbCA9IHdpbmRvdzsgfSBjYXRjaCAoZSkgeyBfZ2xvYmFsID0gZ2xvYmFsOyB9XG5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgZGVmZXJVcGRhdGVzOiBmYWxzZSxcblxuICAgIHVzZU9ubHlOYXRpdmVFdmVudHM6IGZhbHNlLFxuXG4gICAgcHJvdG9Qcm9wZXJ0eTogJ19fa29fcHJvdG9fXycsXG5cbiAgICAgIC8vIE1vZGlmeSB0aGUgZGVmYXVsdCBhdHRyaWJ1dGUgZnJvbSBgZGF0YS1iaW5kYC5cbiAgICBkZWZhdWx0QmluZGluZ0F0dHJpYnV0ZTogJ2RhdGEtYmluZCcsXG5cbiAgICAgIC8vIEVuYWJsZS9kaXNhYmxlIDwhLS0ga28gYmluZGluZzogLi4uIC0+IHN0eWxlIGJpbmRpbmdzXG4gICAgYWxsb3dWaXJ0dWFsRWxlbWVudHM6IHRydWUsXG5cbiAgICAgIC8vIEdsb2JhbCB2YXJpYWJsZXMgdGhhdCBjYW4gYmUgYWNjZXNzZWQgZnJvbSBiaW5kaW5ncy5cbiAgICBiaW5kaW5nR2xvYmFsczogX2dsb2JhbCxcblxuICAgICAgLy8gQW4gaW5zdGFuY2Ugb2YgdGhlIGJpbmRpbmcgcHJvdmlkZXIuXG4gICAgYmluZGluZ1Byb3ZpZGVySW5zdGFuY2U6IG51bGwsXG5cbiAgICAvLyBXaGV0aGVyIHRoZSBgd2l0aGAgYmluZGluZyBjcmVhdGVzIGEgY2hpbGQgY29udGV4dCB3aGVuIHVzZWQgd2l0aCBgYXNgLlxuICAgIGNyZWF0ZUNoaWxkQ29udGV4dFdpdGhBczogZmFsc2UsXG5cbiAgICAgIC8vIGpRdWVyeSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIF9nbG9iYWwualF1ZXJ5IGluIGFwcGx5QmluZGluZ3NcbiAgICAgIC8vIGlmIGl0IGlzIChzdHJpY3RseSBlcXVhbCB0bykgdW5kZWZpbmVkLiAgU2V0IGl0IHRvIGZhbHNlIG9yIG51bGwgdG9cbiAgICAgIC8vIGRpc2FibGUgYXV0b21hdGljYWxseSBzZXR0aW5nIGpRdWVyeS5cbiAgICBqUXVlcnk6IF9nbG9iYWwgJiYgX2dsb2JhbC5qUXVlcnksXG5cbiAgICBQcm9taXNlOiBfZ2xvYmFsICYmIF9nbG9iYWwuUHJvbWlzZSxcblxuICAgIHRhc2tTY2hlZHVsZXI6IG51bGwsXG5cbiAgICBkZWJ1ZzogZmFsc2UsXG5cbiAgICBnbG9iYWw6IF9nbG9iYWwsXG4gICAgZG9jdW1lbnQ6IF9nbG9iYWwuZG9jdW1lbnQsXG5cbiAgICAgIC8vIEZpbHRlcnMgZm9yIGJpbmRpbmdzXG4gICAgICAvLyAgIGRhdGEtYmluZD1cImV4cHJlc3Npb24gfCBmaWx0ZXJfMSB8IGZpbHRlcl8yXCJcbiAgICBmaWx0ZXJzOiB7fSxcblxuICAgIC8vIFVzZWQgYnkgdGhlIHRlbXBsYXRlIGJpbmRpbmcuXG4gICAgaW5jbHVkZURlc3Ryb3llZDogZmFsc2UsXG4gICAgZm9yZWFjaEhpZGVzRGVzdHJveWVkOiBmYWxzZSxcblxuICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlKSB7IHRocm93IGUgfSxcblxuICAgIHNldDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICBvcHRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8vIE92ZXJsb2FkIGdldEJpbmRpbmdIYW5kbGVyIHRvIGhhdmUgYSBjdXN0b20gbG9va3VwIGZ1bmN0aW9uLlxuICAgIGdldEJpbmRpbmdIYW5kbGVyICgvKiBrZXkgKi8pIHt9LFxuICAgIGNsZWFuRXh0ZXJuYWxEYXRhICgvKiBub2RlLCBjYWxsYmFjayAqLykge31cbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucywgJyQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvcHRpb25zLmpRdWVyeSB9XG4gIH0pO1xuXG4gIC8vXG5cbiAgZnVuY3Rpb24gY2F0Y2hGdW5jdGlvbkVycm9ycyAoZGVsZWdhdGUpIHtcbiAgICBpZiAoIW9wdGlvbnMub25FcnJvcikgeyByZXR1cm4gZGVsZWdhdGUgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlKC4uLmFyZ3MpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgb3B0aW9ucy5vbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmZXJFcnJvciAoZXJyb3IpIHtcbiAgICBzYWZlU2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycm9yIH0sIDApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2FmZVNldFRpbWVvdXQgKGhhbmRsZXIsIHRpbWVvdXQpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChjYXRjaEZ1bmN0aW9uRXJyb3JzKGhhbmRsZXIpLCB0aW1lb3V0KVxuICB9XG5cbiAgLy9cblxuICBmdW5jdGlvbiB0aHJvdHRsZSAoY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dEluc3RhbmNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgaWYgKCF0aW1lb3V0SW5zdGFuY2UpIHtcbiAgICAgICAgdGltZW91dEluc3RhbmNlID0gc2FmZVNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRpbWVvdXRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjYWxsYmFjayguLi5hcmdzKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2UgKGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXRJbnN0YW5jZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SW5zdGFuY2UpO1xuICAgICAgdGltZW91dEluc3RhbmNlID0gc2FmZVNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soLi4uYXJncyksIHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8vXG5cbiAgY29uc3QgaWVWZXJzaW9uID0gb3B0aW9ucy5kb2N1bWVudCAmJiAoZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ZXJzaW9uID0gMywgZGl2ID0gb3B0aW9ucy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgaUVsZW1zID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpJyk7XG5cbiAgICAgIC8vIEtlZXAgY29uc3RydWN0aW5nIGNvbmRpdGlvbmFsIEhUTUwgYmxvY2tzIHVudGlsIHdlIGhpdCBvbmUgdGhhdCByZXNvbHZlcyB0byBhbiBlbXB0eSBmcmFnbWVudFxuICAgIHdoaWxlIChcbiAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzwhLS1baWYgZ3QgSUUgJyArICgrK3ZlcnNpb24pICsgJ10+PGk+PC9pPjwhW2VuZGlmXS0tPicsXG4gICAgICAgICAgaUVsZW1zWzBdXG4gICAgICApIHt9XG5cbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIGNvbnN0IHVzZXJBZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgLy8gRGV0ZWN0IElFIDEwLzExXG4gICAgICByZXR1cm4gdWEubWF0Y2goL01TSUUgKFteIF0rKS8pIHx8IHVhLm1hdGNoKC9ydjooW14gKV0rKS8pXG4gICAgfVxuICAgIHJldHVybiB2ZXJzaW9uID4gNCA/IHZlcnNpb24gOiB1bmRlZmluZWRcbiAgfSgpKTtcblxuICAvL1xuICAvLyBPYmplY3QgZnVuY3Rpb25zXG4gIC8vXG5cbiAgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wTmFtZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZCAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3RGb3JFYWNoIChvYmosIGFjdGlvbikge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSkge1xuICAgICAgICBhY3Rpb24ocHJvcCwgb2JqW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3RNYXAgKHNvdXJjZSwgbWFwcGluZywgdGhpc0FyZykge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybiBzb3VyY2UgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikgeyBtYXBwaW5nID0gbWFwcGluZy5iaW5kKHRoaXNBcmcpOyB9XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkoc291cmNlLCBwcm9wKSkge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSBtYXBwaW5nKHNvdXJjZVtwcm9wXSwgcHJvcCwgc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG4gIGZ1bmN0aW9uIGdldE9iamVjdE93blByb3BlcnR5IChvYmosIHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5KG9iaiwgcHJvcE5hbWUpID8gb2JqW3Byb3BOYW1lXSA6IHVuZGVmaW5lZFxuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmVQbGFpbk9iamVjdERlZXAgKG9iaiwgc2Vlbikge1xuICAgIGlmICghc2VlbikgeyBzZWVuID0gW107IH1cblxuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgb2JqLmNvbnN0cnVjdG9yICE9PSBPYmplY3QgfHxcbiAgICAgICAgICBzZWVuLmluZGV4T2Yob2JqKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG5cbiAgICAgIC8vIEFueXRoaW5nIHRoYXQgbWFrZXMgaXQgYmVsb3cgaXMgYSBwbGFpbiBvYmplY3QgdGhhdCBoYXMgbm90IHlldFxuICAgICAgLy8gYmVlbiBzZWVuL2Nsb25lZC5cbiAgICBzZWVuLnB1c2gob2JqKTtcblxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkpIHtcbiAgICAgICAgcmVzdWx0W3Byb3BdID0gY2xvbmVQbGFpbk9iamVjdERlZXAob2JqW3Byb3BdLCBzZWVuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyoqXG4gICAqIEpTT04uc3RyaW5naWZ5LCBidXQgaW5zZXJ0cyBgLi4uYCBmb3Igb2JqZWN0cyB0aGF0IGFyZSByZWZlcmVuY2VkXG4gICAqIG11bHRpcGxlIHRpbWVzLCBwcmV2ZW50aW5nIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkgKHZhbHVlKSB7XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrLCB2KSA9PiB7XG4gICAgICBpZiAoc2Vlbi5oYXModikpIHsgcmV0dXJuICcuLi4nIH1cbiAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ29iamVjdCcpIHsgc2Vlbi5hZGQodik7IH1cbiAgICAgIHJldHVybiB2XG4gICAgfSlcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFByb21pc2VzL0ErIGNvbXBsaWFudCBpc1RoZW5hYmxlIChwZXIgc2VjdGlvbiAxLjIpXG4gICAqL1xuICBmdW5jdGlvbiBpc1RoZW5hYmxlIChvYmplY3QpIHtcbiAgICBjb25zdCBvYmplY3RUeXBlID0gdHlwZW9mIG9iamVjdDtcbiAgICBjb25zdCB0aGVuYWJsZVR5cGUgPSBvYmplY3RUeXBlID09PSAnb2JqZWN0JyB8fCBvYmplY3RUeXBlID09PSAnZnVuY3Rpb24nO1xuICAgIHJldHVybiB0aGVuYWJsZVR5cGUgJiYgb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuICB9XG5cbiAgZnVuY3Rpb24gdGVzdE92ZXJ3cml0ZSAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiB4ICgpIHt9LCAnbGVuZ3RoJywge30pO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBjb25zdCBmdW5jdGlvblN1cHBvcnRzTGVuZ3RoT3ZlcndyaXRlID0gdGVzdE92ZXJ3cml0ZSgpO1xuXG4gIGZ1bmN0aW9uIG92ZXJ3cml0ZUxlbmd0aFByb3BlcnR5SWZTdXBwb3J0ZWQgKGZuLCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGZ1bmN0aW9uU3VwcG9ydHNMZW5ndGhPdmVyd3JpdGUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ2xlbmd0aCcsIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIFN0cmluZyAoYW5kIEpTT04pXG4gIC8vXG5cbiAgZnVuY3Rpb24gc3RyaW5nVHJpbSAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcnXG4gICAgICAgICAgOiBzdHJpbmcudHJpbVxuICAgICAgICAgICAgICA/IHN0cmluZy50cmltKClcbiAgICAgICAgICAgICAgOiBzdHJpbmcudG9TdHJpbmcoKS5yZXBsYWNlKC9eW1xcc1xceGEwXSt8W1xcc1xceGEwXSskL2csICcnKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5nU3RhcnRzV2l0aCAoc3RyaW5nLCBzdGFydHNXaXRoKSB7XG4gICAgc3RyaW5nID0gc3RyaW5nIHx8ICcnO1xuICAgIGlmIChzdGFydHNXaXRoLmxlbmd0aCA+IHN0cmluZy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZygwLCBzdGFydHNXaXRoLmxlbmd0aCkgPT09IHN0YXJ0c1dpdGhcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSnNvbiAoanNvblN0cmluZykge1xuICAgIGlmICh0eXBlb2YganNvblN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGpzb25TdHJpbmcgPSBzdHJpbmdUcmltKGpzb25TdHJpbmcpO1xuICAgICAgaWYgKGpzb25TdHJpbmcpIHtcbiAgICAgICAgaWYgKEpTT04gJiYgSlNPTi5wYXJzZSkgLy8gVXNlIG5hdGl2ZSBwYXJzaW5nIHdoZXJlIGF2YWlsYWJsZVxuICAgICAgICAgICAgICB7IHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcpIH1cbiAgICAgICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsganNvblN0cmluZykpKCkgLy8gRmFsbGJhY2sgb24gbGVzcyBzYWZlIHBhcnNpbmcgZm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvL1xuICAvLyBFUzYgU3ltYm9sc1xuICAvL1xuXG4gIHZhciB1c2VTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJztcblxuICBmdW5jdGlvbiBjcmVhdGVTeW1ib2xPclN0cmluZyAoaWRlbnRpZmllcikge1xuICAgIHJldHVybiB1c2VTeW1ib2xzID8gU3ltYm9sKGlkZW50aWZpZXIpIDogaWRlbnRpZmllclxuICB9XG5cbiAgLy9cblxuICAvLyBGb3IgZGV0YWlscyBvbiB0aGUgcGF0dGVybiBmb3IgY2hhbmdpbmcgbm9kZSBjbGFzc2VzXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2tub2Nrb3V0L2tub2Nrb3V0L2lzc3Vlcy8xNTk3XG4gIHZhciBjc3NDbGFzc05hbWVSZWdleCA9IC9cXFMrL2c7XG5cbiAgZnVuY3Rpb24gdG9nZ2xlRG9tTm9kZUNzc0NsYXNzIChub2RlLCBjbGFzc05hbWVzLCBzaG91bGRIYXZlQ2xhc3MpIHtcbiAgICB2YXIgYWRkT3JSZW1vdmVGbjtcbiAgICBpZiAoIWNsYXNzTmFtZXMpIHsgcmV0dXJuIH1cbiAgICBpZiAodHlwZW9mIG5vZGUuY2xhc3NMaXN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgYWRkT3JSZW1vdmVGbiA9IG5vZGUuY2xhc3NMaXN0W3Nob3VsZEhhdmVDbGFzcyA/ICdhZGQnIDogJ3JlbW92ZSddO1xuICAgICAgYXJyYXlGb3JFYWNoKGNsYXNzTmFtZXMubWF0Y2goY3NzQ2xhc3NOYW1lUmVnZXgpLCBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGFkZE9yUmVtb3ZlRm4uY2FsbChub2RlLmNsYXNzTGlzdCwgY2xhc3NOYW1lKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUuY2xhc3NOYW1lWydiYXNlVmFsJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gU1ZHIHRhZyAuY2xhc3NOYW1lcyBpcyBhbiBTVkdBbmltYXRlZFN0cmluZyBpbnN0YW5jZVxuICAgICAgdG9nZ2xlT2JqZWN0Q2xhc3NQcm9wZXJ0eVN0cmluZyhub2RlLmNsYXNzTmFtZSwgJ2Jhc2VWYWwnLCBjbGFzc05hbWVzLCBzaG91bGRIYXZlQ2xhc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm9kZS5jbGFzc05hbWUgb3VnaHQgdG8gYmUgYSBzdHJpbmcuXG4gICAgICB0b2dnbGVPYmplY3RDbGFzc1Byb3BlcnR5U3RyaW5nKG5vZGUsICdjbGFzc05hbWUnLCBjbGFzc05hbWVzLCBzaG91bGRIYXZlQ2xhc3MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZU9iamVjdENsYXNzUHJvcGVydHlTdHJpbmcgKG9iaiwgcHJvcCwgY2xhc3NOYW1lcywgc2hvdWxkSGF2ZUNsYXNzKSB7XG4gICAgICAvLyBvYmovcHJvcCBpcyBlaXRoZXIgYSBub2RlLydjbGFzc05hbWUnIG9yIGEgU1ZHQW5pbWF0ZWRTdHJpbmcvJ2Jhc2VWYWwnLlxuICAgIHZhciBjdXJyZW50Q2xhc3NOYW1lcyA9IG9ialtwcm9wXS5tYXRjaChjc3NDbGFzc05hbWVSZWdleCkgfHwgW107XG4gICAgYXJyYXlGb3JFYWNoKGNsYXNzTmFtZXMubWF0Y2goY3NzQ2xhc3NOYW1lUmVnZXgpLCBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICBhZGRPclJlbW92ZUl0ZW0oY3VycmVudENsYXNzTmFtZXMsIGNsYXNzTmFtZSwgc2hvdWxkSGF2ZUNsYXNzKTtcbiAgICB9KTtcbiAgICBvYmpbcHJvcF0gPSBjdXJyZW50Q2xhc3NOYW1lcy5qb2luKCcgJyk7XG4gIH1cblxuICAvL1xuXG4gIHZhciBqUXVlcnlJbnN0YW5jZSA9IG9wdGlvbnMuZ2xvYmFsICYmIG9wdGlvbnMuZ2xvYmFsLmpRdWVyeTtcblxuICAvL1xuXG4gIGZ1bmN0aW9uIGRvbU5vZGVJc0NvbnRhaW5lZEJ5IChub2RlLCBjb250YWluZWRCeU5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gY29udGFpbmVkQnlOb2RlKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMTEpIHsgcmV0dXJuIGZhbHNlIH0gLy8gRml4ZXMgaXNzdWUgIzExNjIgLSBjYW4ndCB1c2Ugbm9kZS5jb250YWlucyBmb3IgZG9jdW1lbnQgZnJhZ21lbnRzIG9uIElFOFxuICAgIGlmIChjb250YWluZWRCeU5vZGUuY29udGFpbnMpIHsgcmV0dXJuIGNvbnRhaW5lZEJ5Tm9kZS5jb250YWlucyhub2RlLm5vZGVUeXBlICE9PSAxID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZSkgfVxuICAgIGlmIChjb250YWluZWRCeU5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHsgcmV0dXJuIChjb250YWluZWRCeU5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiAxNikgPT0gMTYgfVxuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT0gY29udGFpbmVkQnlOb2RlKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gISFub2RlXG4gIH1cblxuICBmdW5jdGlvbiBkb21Ob2RlSXNBdHRhY2hlZFRvRG9jdW1lbnQgKG5vZGUpIHtcbiAgICByZXR1cm4gZG9tTm9kZUlzQ29udGFpbmVkQnkobm9kZSwgbm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFueURvbU5vZGVJc0F0dGFjaGVkVG9Eb2N1bWVudCAobm9kZXMpIHtcbiAgICByZXR1cm4gISFhcnJheUZpcnN0KG5vZGVzLCBkb21Ob2RlSXNBdHRhY2hlZFRvRG9jdW1lbnQpXG4gIH1cblxuICBmdW5jdGlvbiB0YWdOYW1lTG93ZXIgKGVsZW1lbnQpIHtcbiAgICAgIC8vIEZvciBIVE1MIGVsZW1lbnRzLCB0YWdOYW1lIHdpbGwgYWx3YXlzIGJlIHVwcGVyIGNhc2U7IGZvciBYSFRNTCBlbGVtZW50cywgaXQnbGwgYmUgbG93ZXIgY2FzZS5cbiAgICAgIC8vIFBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IElmIHdlIGtub3cgaXQncyBhbiBlbGVtZW50IGZyb20gYW4gWEhUTUwgZG9jdW1lbnQgKG5vdCBIVE1MKSxcbiAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZG8gdGhlIC50b0xvd2VyQ2FzZSgpIGFzIGl0IHdpbGwgYWx3YXlzIGJlIGxvd2VyIGNhc2UgYW55d2F5LlxuICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSAmJiBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNEb21FbGVtZW50IChvYmopIHtcbiAgICBpZiAod2luZG93LkhUTUxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmoudGFnTmFtZSAmJiBvYmoubm9kZVR5cGUgPT09IDFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0RvY3VtZW50RnJhZ21lbnQgKG9iaikge1xuICAgIGlmICh3aW5kb3cuRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDExXG4gICAgfVxuICB9XG5cbiAgLy9cblxuICBjb25zdCBkYXRhc3RvcmVUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIGNvbnN0IGRhdGFTdG9yZUtleUV4cGFuZG9Qcm9wZXJ0eU5hbWUgPSBgX19rb19fJHtkYXRhc3RvcmVUaW1lfWA7XG4gIGNvbnN0IGRhdGFTdG9yZVN5bWJvbCA9IFN5bWJvbCgnS25vY2tvdXQgZGF0YScpO1xuICB2YXIgZGF0YVN0b3JlO1xuICBsZXQgdW5pcXVlSWQgPSAwO1xuXG4gIC8qXG4gICAqIFdlIGNvbnNpZGVyZWQgdXNpbmcgV2Vha01hcCwgYnV0IGl0IGhhcyBhIHByb2JsZW0gaW4gSUUgMTEgYW5kIEVkZ2UgdGhhdFxuICAgKiBwcmV2ZW50cyB1c2luZyBpdCBjcm9zcy13aW5kb3csIHNvIGluc3RlYWQgd2UganVzdCBzdG9yZSB0aGUgZGF0YSBkaXJlY3RseVxuICAgKiBvbiB0aGUgbm9kZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rbm9ja291dC9rbm9ja291dC9pc3N1ZXMvMjE0MVxuICAgKi9cbiAgY29uc3QgbW9kZXJuID0ge1xuICAgIGdldERhdGFGb3JOb2RlIChub2RlLCBjcmVhdGVJZk5vdEZvdW5kKSB7XG4gICAgICBsZXQgZGF0YUZvck5vZGUgPSBub2RlW2RhdGFTdG9yZVN5bWJvbF07XG4gICAgICBpZiAoIWRhdGFGb3JOb2RlICYmIGNyZWF0ZUlmTm90Rm91bmQpIHtcbiAgICAgICAgZGF0YUZvck5vZGUgPSBub2RlW2RhdGFTdG9yZVN5bWJvbF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhRm9yTm9kZVxuICAgIH0sXG5cbiAgICBjbGVhciAobm9kZSkge1xuICAgICAgaWYgKG5vZGVbZGF0YVN0b3JlU3ltYm9sXSkge1xuICAgICAgICBkZWxldGUgbm9kZVtkYXRhU3RvcmVTeW1ib2xdO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBPbGQgSUUgdmVyc2lvbnMgaGF2ZSBtZW1vcnkgaXNzdWVzIGlmIHlvdSBzdG9yZSBvYmplY3RzIG9uIHRoZSBub2RlLCBzbyB3ZVxuICAgKiB1c2UgYSBzZXBhcmF0ZSBkYXRhIHN0b3JhZ2UgYW5kIGxpbmsgdG8gaXQgZnJvbSB0aGUgbm9kZSB1c2luZyBhIHN0cmluZyBrZXkuXG4gICAqL1xuICBjb25zdCBJRSA9IHtcbiAgICBnZXREYXRhZm9yTm9kZSAobm9kZSwgY3JlYXRlSWZOb3RGb3VuZCkge1xuICAgICAgbGV0IGRhdGFTdG9yZUtleSA9IG5vZGVbZGF0YVN0b3JlS2V5RXhwYW5kb1Byb3BlcnR5TmFtZV07XG4gICAgICBjb25zdCBoYXNFeGlzdGluZ0RhdGFTdG9yZSA9IGRhdGFTdG9yZUtleSAmJiAoZGF0YVN0b3JlS2V5ICE9PSAnbnVsbCcpICYmIGRhdGFTdG9yZVtkYXRhU3RvcmVLZXldO1xuICAgICAgaWYgKCFoYXNFeGlzdGluZ0RhdGFTdG9yZSkge1xuICAgICAgICBpZiAoIWNyZWF0ZUlmTm90Rm91bmQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgICAgZGF0YVN0b3JlS2V5ID0gbm9kZVtkYXRhU3RvcmVLZXlFeHBhbmRvUHJvcGVydHlOYW1lXSA9ICdrbycgKyB1bmlxdWVJZCsrO1xuICAgICAgICBkYXRhU3RvcmVbZGF0YVN0b3JlS2V5XSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFTdG9yZVtkYXRhU3RvcmVLZXldXG4gICAgfSxcblxuICAgIGNsZWFyIChub2RlKSB7XG4gICAgICBjb25zdCBkYXRhU3RvcmVLZXkgPSBub2RlW2RhdGFTdG9yZUtleUV4cGFuZG9Qcm9wZXJ0eU5hbWVdO1xuICAgICAgaWYgKGRhdGFTdG9yZUtleSkge1xuICAgICAgICBkZWxldGUgZGF0YVN0b3JlW2RhdGFTdG9yZUtleV07XG4gICAgICAgIG5vZGVbZGF0YVN0b3JlS2V5RXhwYW5kb1Byb3BlcnR5TmFtZV0gPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZSAvLyBFeHBvc2luZyAnZGlkIGNsZWFuJyBmbGFnIHB1cmVseSBzbyBzcGVjcyBjYW4gaW5mZXIgd2hldGhlciB0aGluZ3MgaGF2ZSBiZWVuIGNsZWFuZWQgdXAgYXMgaW50ZW5kZWRcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICBjb25zdCB7Z2V0RGF0YUZvck5vZGUsIGNsZWFyfSA9IGllVmVyc2lvbiA/IElFIDogbW9kZXJuO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB1bmlxdWUga2V5LXN0cmluZyBpZGVudGlmaWVyLlxuICAgKi9cbiAgZnVuY3Rpb24gbmV4dEtleSAoKSB7XG4gICAgcmV0dXJuICh1bmlxdWVJZCsrKSArIGRhdGFTdG9yZUtleUV4cGFuZG9Qcm9wZXJ0eU5hbWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCAobm9kZSwga2V5KSB7XG4gICAgY29uc3QgZGF0YUZvck5vZGUgPSBnZXREYXRhRm9yTm9kZShub2RlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGRhdGFGb3JOb2RlICYmIGRhdGFGb3JOb2RlW2tleV1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldCAobm9kZSwga2V5LCB2YWx1ZSkge1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBhY3R1YWxseSBjcmVhdGUgYSBuZXcgZG9tRGF0YSBrZXkgaWYgd2UgYXJlIGFjdHVhbGx5IGRlbGV0aW5nIGEgdmFsdWVcbiAgICB2YXIgZGF0YUZvck5vZGUgPSBnZXREYXRhRm9yTm9kZShub2RlLCB2YWx1ZSAhPT0gdW5kZWZpbmVkIC8qIGNyZWF0ZUlmTm90Rm91bmQgKi8pO1xuICAgIGRhdGFGb3JOb2RlICYmIChkYXRhRm9yTm9kZVtrZXldID0gdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3JTZXQgKG5vZGUsIGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBkYXRhRm9yTm9kZSA9IGdldERhdGFGb3JOb2RlKG5vZGUsIHRydWUsIC8qIGNyZWF0ZUlmTm90Rm91bmQgKi8pO1xuICAgIHJldHVybiBkYXRhRm9yTm9kZVtrZXldIHx8IChkYXRhRm9yTm9kZVtrZXldID0gdmFsdWUpXG4gIH1cblxuICB2YXIgZG9tRGF0YSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBuZXh0S2V5OiBuZXh0S2V5LFxuICAgIGdldDogZ2V0LFxuICAgIHNldDogc2V0LFxuICAgIGdldE9yU2V0OiBnZXRPclNldCxcbiAgICBjbGVhcjogY2xlYXJcbiAgfSk7XG5cbiAgLy9cblxuICB2YXIgZG9tRGF0YUtleSA9IG5leHRLZXkoKTtcbiAgLy8gTm9kZSB0eXBlczpcbiAgLy8gMTogRWxlbWVudFxuICAvLyA4OiBDb21tZW50XG4gIC8vIDk6IERvY3VtZW50XG4gIHZhciBjbGVhbmFibGVOb2RlVHlwZXMgPSB7IDE6IHRydWUsIDg6IHRydWUsIDk6IHRydWUgfTtcbiAgdmFyIGNsZWFuYWJsZU5vZGVUeXBlc1dpdGhEZXNjZW5kYW50cyA9IHsgMTogdHJ1ZSwgOTogdHJ1ZSB9O1xuXG4gIGZ1bmN0aW9uIGdldERpc3Bvc2VDYWxsYmFja3NDb2xsZWN0aW9uIChub2RlLCBjcmVhdGVJZk5vdEZvdW5kKSB7XG4gICAgdmFyIGFsbERpc3Bvc2VDYWxsYmFja3MgPSBnZXQobm9kZSwgZG9tRGF0YUtleSk7XG4gICAgaWYgKChhbGxEaXNwb3NlQ2FsbGJhY2tzID09PSB1bmRlZmluZWQpICYmIGNyZWF0ZUlmTm90Rm91bmQpIHtcbiAgICAgIGFsbERpc3Bvc2VDYWxsYmFja3MgPSBbXTtcbiAgICAgIHNldChub2RlLCBkb21EYXRhS2V5LCBhbGxEaXNwb3NlQ2FsbGJhY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbERpc3Bvc2VDYWxsYmFja3NcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95Q2FsbGJhY2tzQ29sbGVjdGlvbiAobm9kZSkge1xuICAgIHNldChub2RlLCBkb21EYXRhS2V5LCB1bmRlZmluZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW5TaW5nbGVOb2RlIChub2RlKSB7XG4gICAgICAvLyBSdW4gYWxsIHRoZSBkaXNwb3NlIGNhbGxiYWNrc1xuICAgIHZhciBjYWxsYmFja3MgPSBnZXREaXNwb3NlQ2FsbGJhY2tzQ29sbGVjdGlvbihub2RlLCBmYWxzZSk7XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApOyAvLyBDbG9uZSwgYXMgdGhlIGFycmF5IG1heSBiZSBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uICh0eXBpY2FsbHksIGNhbGxiYWNrcyB3aWxsIHJlbW92ZSB0aGVtc2VsdmVzKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHsgY2FsbGJhY2tzW2ldKG5vZGUpOyB9XG4gICAgfVxuXG4gICAgICAvLyBFcmFzZSB0aGUgRE9NIGRhdGFcbiAgICBjbGVhcihub2RlKTtcblxuICAgICAgLy8gUGVyZm9ybSBjbGVhbnVwIG5lZWRlZCBieSBleHRlcm5hbCBsaWJyYXJpZXMgKGN1cnJlbnRseSBvbmx5IGpRdWVyeSwgYnV0IGNhbiBiZSBleHRlbmRlZClcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IG90aGVyTm9kZUNsZWFuZXJGdW5jdGlvbnMubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICBvdGhlck5vZGVDbGVhbmVyRnVuY3Rpb25zW2ldKG5vZGUpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNsZWFuRXh0ZXJuYWxEYXRhKSB7XG4gICAgICBvcHRpb25zLmNsZWFuRXh0ZXJuYWxEYXRhKG5vZGUpO1xuICAgIH1cblxuICAgICAgLy8gQ2xlYXIgYW55IGltbWVkaWF0ZS1jaGlsZCBjb21tZW50IG5vZGVzLCBhcyB0aGVzZSB3b3VsZG4ndCBoYXZlIGJlZW4gZm91bmQgYnlcbiAgICAgIC8vIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSBpbiBjbGVhbk5vZGUoKSAoY29tbWVudCBub2RlcyBhcmVuJ3QgZWxlbWVudHMpXG4gICAgaWYgKGNsZWFuYWJsZU5vZGVUeXBlc1dpdGhEZXNjZW5kYW50c1tub2RlLm5vZGVUeXBlXSkge1xuICAgICAgY2xlYW5Ob2Rlc0luTGlzdChub2RlLmNoaWxkTm9kZXMsIHRydWUgLyogb25seUNvbW1lbnRzICovKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbk5vZGVzSW5MaXN0IChub2RlTGlzdCwgb25seUNvbW1lbnRzKSB7XG4gICAgY29uc3QgY2xlYW5lZE5vZGVzID0gW107XG4gICAgbGV0IGxhc3RDbGVhbmVkTm9kZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9ubHlDb21tZW50cyB8fCBub2RlTGlzdFtpXS5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICBjbGVhblNpbmdsZU5vZGUoY2xlYW5lZE5vZGVzW2NsZWFuZWROb2Rlcy5sZW5ndGhdID0gbGFzdENsZWFuZWROb2RlID0gbm9kZUxpc3RbaV0pO1xuICAgICAgICBpZiAobm9kZUxpc3RbaV0gIT09IGxhc3RDbGVhbmVkTm9kZSkge1xuICAgICAgICAgIHdoaWxlIChpLS0gJiYgYXJyYXlJbmRleE9mKGNsZWFuZWROb2Rlcywgbm9kZUxpc3RbaV0pID09PSAtMSkge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEV4cG9ydHNcbiAgZnVuY3Rpb24gYWRkRGlzcG9zZUNhbGxiYWNrIChub2RlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHsgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKSB9XG4gICAgZ2V0RGlzcG9zZUNhbGxiYWNrc0NvbGxlY3Rpb24obm9kZSwgdHJ1ZSkucHVzaChjYWxsYmFjayk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVEaXNwb3NlQ2FsbGJhY2sgKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNhbGxiYWNrc0NvbGxlY3Rpb24gPSBnZXREaXNwb3NlQ2FsbGJhY2tzQ29sbGVjdGlvbihub2RlLCBmYWxzZSk7XG4gICAgaWYgKGNhbGxiYWNrc0NvbGxlY3Rpb24pIHtcbiAgICAgIGFycmF5UmVtb3ZlSXRlbShjYWxsYmFja3NDb2xsZWN0aW9uLCBjYWxsYmFjayk7XG4gICAgICBpZiAoY2FsbGJhY2tzQ29sbGVjdGlvbi5sZW5ndGggPT09IDApIHsgZGVzdHJveUNhbGxiYWNrc0NvbGxlY3Rpb24obm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbk5vZGUgKG5vZGUpIHtcbiAgICAvLyBGaXJzdCBjbGVhbiB0aGlzIG5vZGUsIHdoZXJlIGFwcGxpY2FibGVcbiAgICBpZiAoY2xlYW5hYmxlTm9kZVR5cGVzW25vZGUubm9kZVR5cGVdKSB7XG4gICAgICBjbGVhblNpbmdsZU5vZGUobm9kZSk7XG5cbiAgICAgIC8vIC4uLiB0aGVuIGl0cyBkZXNjZW5kYW50cywgd2hlcmUgYXBwbGljYWJsZVxuICAgICAgaWYgKGNsZWFuYWJsZU5vZGVUeXBlc1dpdGhEZXNjZW5kYW50c1tub2RlLm5vZGVUeXBlXSkge1xuICAgICAgICBjbGVhbk5vZGVzSW5MaXN0KG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKG5vZGUpIHtcbiAgICBjbGVhbk5vZGUobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkgeyBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7IH1cbiAgfVxuXG4gIC8vIEV4cG9zZSBzdXBwbGVtZW50YWwgbm9kZSBjbGVhbmluZyBmdW5jdGlvbnMuXG4gIGNvbnN0IG90aGVyTm9kZUNsZWFuZXJGdW5jdGlvbnMgPSBbXTtcblxuICBmdW5jdGlvbiBhZGRDbGVhbmVyIChmbikge1xuICAgIG90aGVyTm9kZUNsZWFuZXJGdW5jdGlvbnMucHVzaChmbik7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDbGVhbmVyIChmbikge1xuICAgIGNvbnN0IGZuSW5kZXggPSBvdGhlck5vZGVDbGVhbmVyRnVuY3Rpb25zLmluZGV4T2YoZm4pO1xuICAgIGlmIChmbkluZGV4ID49IDApIHsgb3RoZXJOb2RlQ2xlYW5lckZ1bmN0aW9ucy5zcGxpY2UoZm5JbmRleCwgMSk7IH1cbiAgfVxuXG4gIC8vIFNwZWNpYWwgc3VwcG9ydCBmb3IgalF1ZXJ5IGhlcmUgYmVjYXVzZSBpdCdzIHNvIGNvbW1vbmx5IHVzZWQuXG4gIC8vIE1hbnkgalF1ZXJ5IHBsdWdpbnMgKGluY2x1ZGluZyBqcXVlcnkudG1wbCkgc3RvcmUgZGF0YSB1c2luZyBqUXVlcnkncyBlcXVpdmFsZW50IG9mIGRvbURhdGFcbiAgLy8gc28gbm90aWZ5IGl0IHRvIHRlYXIgZG93biBhbnkgcmVzb3VyY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZSAmIGRlc2NlbmRhbnRzIGhlcmUuXG4gIGZ1bmN0aW9uIGNsZWFualF1ZXJ5RGF0YSAobm9kZSkge1xuICAgIHZhciBqUXVlcnlDbGVhbk5vZGVGbiA9IGpRdWVyeUluc3RhbmNlID8galF1ZXJ5SW5zdGFuY2UuY2xlYW5EYXRhIDogbnVsbDtcblxuICAgIGlmIChqUXVlcnlDbGVhbk5vZGVGbikge1xuICAgICAgalF1ZXJ5Q2xlYW5Ob2RlRm4oW25vZGVdKTtcbiAgICB9XG4gIH1cblxuICBvdGhlck5vZGVDbGVhbmVyRnVuY3Rpb25zLnB1c2goY2xlYW5qUXVlcnlEYXRhKTtcblxuICAvL1xuXG4gIC8vIFJlcHJlc2VudCB0aGUga25vd24gZXZlbnQgdHlwZXMgaW4gYSBjb21wYWN0IHdheSwgdGhlbiBhdCBydW50aW1lIHRyYW5zZm9ybSBpdCBpbnRvIGEgaGFzaCB3aXRoIGV2ZW50IG5hbWUgYXMga2V5IChmb3IgZmFzdCBsb29rdXApXG4gIHZhciBrbm93bkV2ZW50cyA9IHt9LFxuICAgIGtub3duRXZlbnRUeXBlc0J5RXZlbnROYW1lID0ge307XG5cbiAgdmFyIGtleUV2ZW50VHlwZU5hbWUgPSAob3B0aW9ucy5nbG9iYWwubmF2aWdhdG9yICYmIC9GaXJlZm94XFwvMi9pLnRlc3Qob3B0aW9ucy5nbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCkpID8gJ0tleWJvYXJkRXZlbnQnIDogJ1VJRXZlbnRzJztcblxuICBrbm93bkV2ZW50c1trZXlFdmVudFR5cGVOYW1lXSA9IFsna2V5dXAnLCAna2V5ZG93bicsICdrZXlwcmVzcyddO1xuXG4gIGtub3duRXZlbnRzWydNb3VzZUV2ZW50cyddID0gW1xuICAgICdjbGljaycsICdkYmxjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZW1vdmUnLCAnbW91c2VvdmVyJyxcbiAgICAnbW91c2VvdXQnLCAnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJ107XG5cbiAgb2JqZWN0Rm9yRWFjaChrbm93bkV2ZW50cywgZnVuY3Rpb24gKGV2ZW50VHlwZSwga25vd25FdmVudHNGb3JUeXBlKSB7XG4gICAgaWYgKGtub3duRXZlbnRzRm9yVHlwZS5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0ga25vd25FdmVudHNGb3JUeXBlLmxlbmd0aDsgaSA8IGo7IGkrKykgeyBrbm93bkV2ZW50VHlwZXNCeUV2ZW50TmFtZVtrbm93bkV2ZW50c0ZvclR5cGVbaV1dID0gZXZlbnRUeXBlOyB9XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBpc0NsaWNrT25DaGVja2FibGVFbGVtZW50IChlbGVtZW50LCBldmVudFR5cGUpIHtcbiAgICBpZiAoKHRhZ05hbWVMb3dlcihlbGVtZW50KSAhPT0gJ2lucHV0JykgfHwgIWVsZW1lbnQudHlwZSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKGV2ZW50VHlwZS50b0xvd2VyQ2FzZSgpICE9ICdjbGljaycpIHJldHVybiBmYWxzZVxuICAgIHZhciBpbnB1dFR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgcmV0dXJuIChpbnB1dFR5cGUgPT0gJ2NoZWNrYm94JykgfHwgKGlucHV0VHlwZSA9PSAncmFkaW8nKVxuICB9XG5cbiAgLy8gV29ya2Fyb3VuZCBmb3IgYW4gSUU5IGlzc3VlIC0gaHR0cHM6Ly9naXRodWIuY29tL1N0ZXZlU2FuZGVyc29uL2tub2Nrb3V0L2lzc3Vlcy80MDZcbiAgdmFyIGV2ZW50c1RoYXRNdXN0QmVSZWdpc3RlcmVkVXNpbmdBdHRhY2hFdmVudCA9IHsgJ3Byb3BlcnR5Y2hhbmdlJzogdHJ1ZSB9O1xuICBsZXQgalF1ZXJ5RXZlbnRBdHRhY2hOYW1lO1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRIYW5kbGVyIChlbGVtZW50LCBldmVudFR5cGUsIGhhbmRsZXIsIGV2ZW50T3B0aW9ucyA9IGZhbHNlKSB7XG4gICAgY29uc3Qgd3JhcHBlZEhhbmRsZXIgPSBjYXRjaEZ1bmN0aW9uRXJyb3JzKGhhbmRsZXIpO1xuICAgIGNvbnN0IG11c3RVc2VBdHRhY2hFdmVudCA9IGllVmVyc2lvbiAmJiBldmVudHNUaGF0TXVzdEJlUmVnaXN0ZXJlZFVzaW5nQXR0YWNoRXZlbnRbZXZlbnRUeXBlXTtcbiAgICBjb25zdCBtdXN0VXNlTmF0aXZlID0gQm9vbGVhbihldmVudE9wdGlvbnMpO1xuXG4gICAgaWYgKCFvcHRpb25zLnVzZU9ubHlOYXRpdmVFdmVudHMgJiYgIW11c3RVc2VBdHRhY2hFdmVudCAmJiAhbXVzdFVzZU5hdGl2ZSAmJiBqUXVlcnlJbnN0YW5jZSkge1xuICAgICAgaWYgKCFqUXVlcnlFdmVudEF0dGFjaE5hbWUpIHtcbiAgICAgICAgalF1ZXJ5RXZlbnRBdHRhY2hOYW1lID0gKHR5cGVvZiBqUXVlcnlJbnN0YW5jZShlbGVtZW50KS5vbiA9PT0gJ2Z1bmN0aW9uJykgPyAnb24nIDogJ2JpbmQnO1xuICAgICAgfVxuICAgICAgalF1ZXJ5SW5zdGFuY2UoZWxlbWVudClbalF1ZXJ5RXZlbnRBdHRhY2hOYW1lXShldmVudFR5cGUsIHdyYXBwZWRIYW5kbGVyKTtcbiAgICB9IGVsc2UgaWYgKCFtdXN0VXNlQXR0YWNoRXZlbnQgJiYgdHlwZW9mIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgd3JhcHBlZEhhbmRsZXIsIGV2ZW50T3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC5hdHRhY2hFdmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGF0dGFjaEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkgeyB3cmFwcGVkSGFuZGxlci5jYWxsKGVsZW1lbnQsIGV2ZW50KTsgfTtcbiAgICAgIGNvbnN0IGF0dGFjaEV2ZW50TmFtZSA9ICdvbicgKyBldmVudFR5cGU7XG4gICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KGF0dGFjaEV2ZW50TmFtZSwgYXR0YWNoRXZlbnRIYW5kbGVyKTtcblxuICAgICAgLy8gSUUgZG9lcyBub3QgZGlzcG9zZSBhdHRhY2hFdmVudCBoYW5kbGVycyBhdXRvbWF0aWNhbGx5ICh1bmxpa2Ugd2l0aCBhZGRFdmVudExpc3RlbmVyKVxuICAgICAgLy8gc28gdG8gYXZvaWQgbGVha3MsIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZW0gbWFudWFsbHkuIFNlZSBidWcgIzg1NlxuICAgICAgYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWxlbWVudC5kZXRhY2hFdmVudChhdHRhY2hFdmVudE5hbWUsIGF0dGFjaEV2ZW50SGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgYWRkRXZlbnRMaXN0ZW5lciBvciBhdHRhY2hFdmVudFwiKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWdnZXJFdmVudCAoZWxlbWVudCwgZXZlbnRUeXBlKSB7XG4gICAgaWYgKCEoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgbXVzdCBiZSBhIERPTSBub2RlIHdoZW4gY2FsbGluZyB0cmlnZ2VyRXZlbnQnKSB9XG5cbiAgICAgIC8vIEZvciBjbGljayBldmVudHMgb24gY2hlY2tib3hlcyBhbmQgcmFkaW8gYnV0dG9ucywgalF1ZXJ5IHRvZ2dsZXMgdGhlIGVsZW1lbnQgY2hlY2tlZCBzdGF0ZSAqYWZ0ZXIqIHRoZVxuICAgICAgLy8gZXZlbnQgaGFuZGxlciBydW5zIGluc3RlYWQgb2YgKmJlZm9yZSouIChUaGlzIHdhcyBmaXhlZCBpbiAxLjkgZm9yIGNoZWNrYm94ZXMgYnV0IG5vdCBmb3IgcmFkaW8gYnV0dG9ucy4pXG4gICAgICAvLyBJRSBkb2Vzbid0IGNoYW5nZSB0aGUgY2hlY2tlZCBzdGF0ZSB3aGVuIHlvdSB0cmlnZ2VyIHRoZSBjbGljayBldmVudCB1c2luZyBcImZpcmVFdmVudFwiLlxuICAgICAgLy8gSW4gYm90aCBjYXNlcywgd2UnbGwgdXNlIHRoZSBjbGljayBtZXRob2QgaW5zdGVhZC5cbiAgICB2YXIgdXNlQ2xpY2tXb3JrYXJvdW5kID0gaXNDbGlja09uQ2hlY2thYmxlRWxlbWVudChlbGVtZW50LCBldmVudFR5cGUpO1xuXG4gICAgaWYgKCFvcHRpb25zLnVzZU9ubHlOYXRpdmVFdmVudHMgJiYgalF1ZXJ5SW5zdGFuY2UgJiYgIXVzZUNsaWNrV29ya2Fyb3VuZCkge1xuICAgICAgalF1ZXJ5SW5zdGFuY2UoZWxlbWVudCkudHJpZ2dlcihldmVudFR5cGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgZXZlbnRDYXRlZ29yeSA9IGtub3duRXZlbnRUeXBlc0J5RXZlbnROYW1lW2V2ZW50VHlwZV0gfHwgJ0hUTUxFdmVudHMnO1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChldmVudENhdGVnb3J5KTtcbiAgICAgICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgdHJ1ZSwgdHJ1ZSwgb3B0aW9ucy5nbG9iYWwsIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7IHRocm93IG5ldyBFcnJvcihcIlRoZSBzdXBwbGllZCBlbGVtZW50IGRvZXNuJ3Qgc3VwcG9ydCBkaXNwYXRjaEV2ZW50XCIpIH1cbiAgICB9IGVsc2UgaWYgKHVzZUNsaWNrV29ya2Fyb3VuZCAmJiBlbGVtZW50LmNsaWNrKSB7XG4gICAgICBlbGVtZW50LmNsaWNrKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC5maXJlRXZlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbGVtZW50LmZpcmVFdmVudCgnb24nICsgZXZlbnRUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdHJpZ2dlcmluZyBldmVudHNcIilcbiAgICB9XG4gIH1cblxuICAvL1xuXG4gIGZ1bmN0aW9uIG1vdmVDbGVhbmVkTm9kZXNUb0NvbnRhaW5lckVsZW1lbnQgKG5vZGVzKSB7XG4gICAgICAvLyBFbnN1cmUgaXQncyBhIHJlYWwgYXJyYXksIGFzIHdlJ3JlIGFib3V0IHRvIHJlcGFyZW50IHRoZSBub2RlcyBhbmRcbiAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHVuZGVybHlpbmcgY29sbGVjdGlvbiB0byBjaGFuZ2Ugd2hpbGUgd2UncmUgZG9pbmcgdGhhdC5cbiAgICB2YXIgbm9kZXNBcnJheSA9IG1ha2VBcnJheShub2Rlcyk7XG4gICAgdmFyIHRlbXBsYXRlRG9jdW1lbnQgPSAobm9kZXNBcnJheVswXSAmJiBub2Rlc0FycmF5WzBdLm93bmVyRG9jdW1lbnQpIHx8IGRvY3VtZW50O1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IHRlbXBsYXRlRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBub2Rlc0FycmF5Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNsZWFuTm9kZShub2Rlc0FycmF5W2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lTm9kZXMgKG5vZGVzQXJyYXksIHNob3VsZENsZWFuTm9kZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IG5vZGVzQXJyYXkubGVuZ3RoLCBuZXdOb2Rlc0FycmF5ID0gW107IGkgPCBqOyBpKyspIHtcbiAgICAgIHZhciBjbG9uZWROb2RlID0gbm9kZXNBcnJheVtpXS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICBuZXdOb2Rlc0FycmF5LnB1c2goc2hvdWxkQ2xlYW5Ob2RlcyA/IGNsZWFuTm9kZShjbG9uZWROb2RlKSA6IGNsb25lZE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Tm9kZXNBcnJheVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0RG9tTm9kZUNoaWxkcmVuIChkb21Ob2RlLCBjaGlsZE5vZGVzKSB7XG4gICAgZW1wdHlEb21Ob2RlKGRvbU5vZGUpO1xuICAgIGlmIChjaGlsZE5vZGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7IGRvbU5vZGUuYXBwZW5kQ2hpbGQoY2hpbGROb2Rlc1tpXSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlRG9tTm9kZXMgKG5vZGVUb1JlcGxhY2VPck5vZGVBcnJheSwgbmV3Tm9kZXNBcnJheSkge1xuICAgIHZhciBub2Rlc1RvUmVwbGFjZUFycmF5ID0gbm9kZVRvUmVwbGFjZU9yTm9kZUFycmF5Lm5vZGVUeXBlID8gW25vZGVUb1JlcGxhY2VPck5vZGVBcnJheV0gOiBub2RlVG9SZXBsYWNlT3JOb2RlQXJyYXk7XG4gICAgaWYgKG5vZGVzVG9SZXBsYWNlQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGluc2VydGlvblBvaW50ID0gbm9kZXNUb1JlcGxhY2VBcnJheVswXTtcbiAgICAgIHZhciBwYXJlbnQgPSBpbnNlcnRpb25Qb2ludC5wYXJlbnROb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBuZXdOb2Rlc0FycmF5Lmxlbmd0aDsgaSA8IGo7IGkrKykgeyBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld05vZGVzQXJyYXlbaV0sIGluc2VydGlvblBvaW50KTsgfVxuICAgICAgZm9yIChpID0gMCwgaiA9IG5vZGVzVG9SZXBsYWNlQXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobm9kZXNUb1JlcGxhY2VBcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0RWxlbWVudE5hbWUgKGVsZW1lbnQsIG5hbWUpIHtcbiAgICBlbGVtZW50Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAvLyBXb3JrYXJvdW5kIElFIDYvNyBpc3N1ZVxuICAgICAgLy8gLSBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzE5N1xuICAgICAgLy8gLSBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L3NldHRpbmdfdGhlX25hbWVfYXR0cmlidXRlX2luX2llX2RvbS9cbiAgICBpZiAoaWVWZXJzaW9uIDw9IDcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsZW1lbnQubWVyZ2VBdHRyaWJ1dGVzKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCI8aW5wdXQgbmFtZT0nXCIgKyBlbGVtZW50Lm5hbWUgKyBcIicvPlwiKSwgZmFsc2UpO1xuICAgICAgfSBjYXRjaCAoZSkge30gLy8gRm9yIElFOSB3aXRoIGRvYyBtb2RlIFwiSUU5IFN0YW5kYXJkc1wiIGFuZCBicm93c2VyIG1vZGUgXCJJRTkgQ29tcGF0aWJpbGl0eSBWaWV3XCJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eURvbU5vZGUgKGRvbU5vZGUpIHtcbiAgICB3aGlsZSAoZG9tTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICByZW1vdmVOb2RlKGRvbU5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgLy9cblxuICBmdW5jdGlvbiBmaXhVcENvbnRpbnVvdXNOb2RlQXJyYXkgKGNvbnRpbnVvdXNOb2RlQXJyYXksIHBhcmVudE5vZGUpIHtcbiAgICAgIC8vIEJlZm9yZSBhY3Rpbmcgb24gYSBzZXQgb2Ygbm9kZXMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgb3V0cHV0dGVkIGJ5IGEgdGVtcGxhdGUgZnVuY3Rpb24sIHdlIGhhdmUgdG8gcmVjb25jaWxlXG4gICAgICAvLyB0aGVtIGFnYWluc3Qgd2hhdCBpcyBpbiB0aGUgRE9NIHJpZ2h0IG5vdy4gSXQgbWF5IGJlIHRoYXQgc29tZSBvZiB0aGUgbm9kZXMgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCwgb3IgdGhhdFxuICAgICAgLy8gbmV3IG5vZGVzIG1pZ2h0IGhhdmUgYmVlbiBpbnNlcnRlZCBpbiB0aGUgbWlkZGxlLCBmb3IgZXhhbXBsZSBieSBhIGJpbmRpbmcuIEFsc28sIHRoZXJlIG1heSBwcmV2aW91c2x5IGhhdmUgYmVlblxuICAgICAgLy8gbGVhZGluZyBjb21tZW50IG5vZGVzIChjcmVhdGVkIGJ5IHJld3JpdHRlbiBzdHJpbmctYmFzZWQgdGVtcGxhdGVzKSB0aGF0IGhhdmUgc2luY2UgYmVlbiByZW1vdmVkIGR1cmluZyBiaW5kaW5nLlxuICAgICAgLy8gU28sIHRoaXMgZnVuY3Rpb24gdHJhbnNsYXRlcyB0aGUgb2xkIFwibWFwXCIgb3V0cHV0IGFycmF5IGludG8gaXRzIGJlc3QgZ3Vlc3Mgb2YgdGhlIHNldCBvZiBjdXJyZW50IERPTSBub2Rlcy5cbiAgICAgIC8vXG4gICAgICAvLyBSdWxlczpcbiAgICAgIC8vICAgW0FdIEFueSBsZWFkaW5nIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgc2hvdWxkIGJlIGlnbm9yZWRcbiAgICAgIC8vICAgICAgIFRoZXNlIG1vc3QgbGlrZWx5IGNvcnJlc3BvbmQgdG8gbWVtb2l6YXRpb24gbm9kZXMgdGhhdCB3ZXJlIGFscmVhZHkgcmVtb3ZlZCBkdXJpbmcgYmluZGluZ1xuICAgICAgLy8gICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rbm9ja291dC9rbm9ja291dC9wdWxsLzQ0MFxuICAgICAgLy8gICBbQl0gQW55IHRyYWlsaW5nIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZSBzaG91bGQgYmUgaWdub3JlZFxuICAgICAgLy8gICAgICAgVGhpcyBwcmV2ZW50cyB0aGUgY29kZSBoZXJlIGZyb20gYWRkaW5nIHVucmVsYXRlZCBub2RlcyB0byB0aGUgYXJyYXkgd2hpbGUgcHJvY2Vzc2luZyBydWxlIFtDXVxuICAgICAgLy8gICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rbm9ja291dC9rbm9ja291dC9wdWxsLzE5MDNcbiAgICAgIC8vICAgW0NdIFdlIHdhbnQgdG8gb3V0cHV0IGEgY29udGludW91cyBzZXJpZXMgb2Ygbm9kZXMuIFNvLCBpZ25vcmUgYW55IG5vZGVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCxcbiAgICAgIC8vICAgICAgIGFuZCBpbmNsdWRlIGFueSBub2RlcyB0aGF0IGhhdmUgYmVlbiBpbnNlcnRlZCBhbW9uZyB0aGUgcHJldmlvdXMgY29sbGVjdGlvblxuXG4gICAgaWYgKGNvbnRpbnVvdXNOb2RlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVGhlIHBhcmVudCBub2RlIGNhbiBiZSBhIHZpcnR1YWwgZWxlbWVudDsgc28gZ2V0IHRoZSByZWFsIHBhcmVudCBub2RlXG4gICAgICBwYXJlbnROb2RlID0gKHBhcmVudE5vZGUubm9kZVR5cGUgPT09IDggJiYgcGFyZW50Tm9kZS5wYXJlbnROb2RlKSB8fCBwYXJlbnROb2RlO1xuXG4gICAgICAgICAgLy8gUnVsZSBbQV1cbiAgICAgIHdoaWxlIChjb250aW51b3VzTm9kZUFycmF5Lmxlbmd0aCAmJiBjb250aW51b3VzTm9kZUFycmF5WzBdLnBhcmVudE5vZGUgIT09IHBhcmVudE5vZGUpIHsgY29udGludW91c05vZGVBcnJheS5zcGxpY2UoMCwgMSk7IH1cblxuICAgICAgICAgIC8vIFJ1bGUgW0JdXG4gICAgICB3aGlsZSAoY29udGludW91c05vZGVBcnJheS5sZW5ndGggPiAxICYmIGNvbnRpbnVvdXNOb2RlQXJyYXlbY29udGludW91c05vZGVBcnJheS5sZW5ndGggLSAxXS5wYXJlbnROb2RlICE9PSBwYXJlbnROb2RlKSB7IGNvbnRpbnVvdXNOb2RlQXJyYXkubGVuZ3RoLS07IH1cblxuICAgICAgICAgIC8vIFJ1bGUgW0NdXG4gICAgICBpZiAoY29udGludW91c05vZGVBcnJheS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gY29udGludW91c05vZGVBcnJheVswXSwgbGFzdCA9IGNvbnRpbnVvdXNOb2RlQXJyYXlbY29udGludW91c05vZGVBcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgLy8gUmVwbGFjZSB3aXRoIHRoZSBhY3R1YWwgbmV3IGNvbnRpbnVvdXMgbm9kZSBzZXRcbiAgICAgICAgY29udGludW91c05vZGVBcnJheS5sZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbGFzdCkge1xuICAgICAgICAgIGNvbnRpbnVvdXNOb2RlQXJyYXkucHVzaChjdXJyZW50KTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51b3VzTm9kZUFycmF5LnB1c2gobGFzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250aW51b3VzTm9kZUFycmF5XG4gIH1cblxuICBmdW5jdGlvbiBzZXRPcHRpb25Ob2RlU2VsZWN0aW9uU3RhdGUgKG9wdGlvbk5vZGUsIGlzU2VsZWN0ZWQpIHtcbiAgICAgIC8vIElFNiBzb21ldGltZXMgdGhyb3dzIFwidW5rbm93biBlcnJvclwiIGlmIHlvdSB0cnkgdG8gd3JpdGUgdG8gLnNlbGVjdGVkIGRpcmVjdGx5LCB3aGVyZWFzIEZpcmVmb3ggc3RydWdnbGVzIHdpdGggc2V0QXR0cmlidXRlLiBQaWNrIG9uZSBiYXNlZCBvbiBicm93c2VyLlxuICAgIGlmIChpZVZlcnNpb24gPCA3KSB7IG9wdGlvbk5vZGUuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsIGlzU2VsZWN0ZWQpOyB9IGVsc2UgeyBvcHRpb25Ob2RlLnNlbGVjdGVkID0gaXNTZWxlY3RlZDsgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VSZWZyZXNoIChub2RlKSB7XG4gICAgICAvLyBXb3JrYXJvdW5kIGZvciBhbiBJRTkgcmVuZGVyaW5nIGJ1ZyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9pc3N1ZXMvMjA5XG4gICAgaWYgKGllVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgICAgLy8gRm9yIHRleHQgbm9kZXMgYW5kIGNvbW1lbnQgbm9kZXMgKG1vc3QgbGlrZWx5IHZpcnR1YWwgZWxlbWVudHMpLCB3ZSB3aWxsIGhhdmUgdG8gcmVmcmVzaCB0aGUgY29udGFpbmVyXG4gICAgICB2YXIgZWxlbSA9IG5vZGUubm9kZVR5cGUgPT0gMSA/IG5vZGUgOiBub2RlLnBhcmVudE5vZGU7XG4gICAgICBpZiAoZWxlbS5zdHlsZSkgeyBlbGVtLnN0eWxlLnpvb20gPSBlbGVtLnN0eWxlLnpvb207IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVTZWxlY3RFbGVtZW50SXNSZW5kZXJlZENvcnJlY3RseSAoc2VsZWN0RWxlbWVudCkge1xuICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgSUU5IHJlbmRlcmluZyBidWcgLSBpdCBkb2Vzbid0IHJlbGlhYmx5IGRpc3BsYXkgYWxsIHRoZSB0ZXh0IGluIGR5bmFtaWNhbGx5LWFkZGVkIHNlbGVjdCBib3hlcyB1bmxlc3MgeW91IGZvcmNlIGl0IHRvIHJlLXJlbmRlciBieSB1cGRhdGluZyB0aGUgd2lkdGguXG4gICAgICAvLyAoU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9pc3N1ZXMvMzEyLCBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU5MDg0OTQvc2VsZWN0LW9ubHktc2hvd3MtZmlyc3QtY2hhci1vZi1zZWxlY3RlZC1vcHRpb24pXG4gICAgICAvLyBBbHNvIGZpeGVzIElFNyBhbmQgSUU4IGJ1ZyB0aGF0IGNhdXNlcyBzZWxlY3RzIHRvIGJlIHplcm8gd2lkdGggaWYgZW5jbG9zZWQgYnkgJ2lmJyBvciAnd2l0aCcuIChTZWUgaXNzdWUgIzgzOSlcbiAgICBpZiAoaWVWZXJzaW9uKSB7XG4gICAgICB2YXIgb3JpZ2luYWxXaWR0aCA9IHNlbGVjdEVsZW1lbnQuc3R5bGUud2lkdGg7XG4gICAgICBzZWxlY3RFbGVtZW50LnN0eWxlLndpZHRoID0gMDtcbiAgICAgIHNlbGVjdEVsZW1lbnQuc3R5bGUud2lkdGggPSBvcmlnaW5hbFdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIC8qIGVzbGludCBuby1jb25kLWFzc2lnbjogMCAqL1xuXG4gIHZhciBjb21tZW50Tm9kZXNIYXZlVGV4dFByb3BlcnR5ID0gb3B0aW9ucy5kb2N1bWVudCAmJiBvcHRpb25zLmRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3Rlc3QnKS50ZXh0ID09PSAnPCEtLXRlc3QtLT4nO1xuXG4gIHZhciBzdGFydENvbW1lbnRSZWdleCA9IGNvbW1lbnROb2Rlc0hhdmVUZXh0UHJvcGVydHkgPyAvXjwhLS1cXHMqa28oPzpcXHMrKFtcXHNcXFNdKykpP1xccyotLT4kLyA6IC9eXFxzKmtvKD86XFxzKyhbXFxzXFxTXSspKT9cXHMqJC87XG4gIHZhciBlbmRDb21tZW50UmVnZXggPSBjb21tZW50Tm9kZXNIYXZlVGV4dFByb3BlcnR5ID8gL148IS0tXFxzKlxcL2tvXFxzKi0tPiQvIDogL15cXHMqXFwva29cXHMqJC87XG4gIHZhciBodG1sVGFnc1dpdGhPcHRpb25hbGx5Q2xvc2luZ0NoaWxkcmVuID0geyAndWwnOiB0cnVlLCAnb2wnOiB0cnVlIH07XG5cbiAgZnVuY3Rpb24gaXNTdGFydENvbW1lbnQgKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZVR5cGUgPT0gOCkgJiYgc3RhcnRDb21tZW50UmVnZXgudGVzdChjb21tZW50Tm9kZXNIYXZlVGV4dFByb3BlcnR5ID8gbm9kZS50ZXh0IDogbm9kZS5ub2RlVmFsdWUpXG4gIH1cblxuICBmdW5jdGlvbiBpc0VuZENvbW1lbnQgKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZVR5cGUgPT0gOCkgJiYgZW5kQ29tbWVudFJlZ2V4LnRlc3QoY29tbWVudE5vZGVzSGF2ZVRleHRQcm9wZXJ0eSA/IG5vZGUudGV4dCA6IG5vZGUubm9kZVZhbHVlKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbm1hdGNoZWRFbmRDb21tZW50IChub2RlKSB7XG4gICAgcmV0dXJuIGlzRW5kQ29tbWVudChub2RlKSAmJiAhZ2V0KG5vZGUsIG1hdGNoZWRFbmRDb21tZW50RGF0YUtleSlcbiAgfVxuXG4gIGNvbnN0IG1hdGNoZWRFbmRDb21tZW50RGF0YUtleSA9ICdfX2tvX21hdGNoZWRFbmRDb21tZW50X18nO1xuXG4gIGZ1bmN0aW9uIGdldFZpcnR1YWxDaGlsZHJlbiAoc3RhcnRDb21tZW50LCBhbGxvd1VuYmFsYW5jZWQpIHtcbiAgICB2YXIgY3VycmVudE5vZGUgPSBzdGFydENvbW1lbnQ7XG4gICAgdmFyIGRlcHRoID0gMTtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0U2libGluZykge1xuICAgICAgaWYgKGlzRW5kQ29tbWVudChjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgc2V0KGN1cnJlbnROb2RlLCBtYXRjaGVkRW5kQ29tbWVudERhdGFLZXksIHRydWUpO1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgICBpZiAoZGVwdGggPT09IDApIHsgcmV0dXJuIGNoaWxkcmVuIH1cbiAgICAgIH1cblxuICAgICAgY2hpbGRyZW4ucHVzaChjdXJyZW50Tm9kZSk7XG5cbiAgICAgIGlmIChpc1N0YXJ0Q29tbWVudChjdXJyZW50Tm9kZSkpIHsgZGVwdGgrKzsgfVxuICAgIH1cbiAgICBpZiAoIWFsbG93VW5iYWxhbmNlZCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGNsb3NpbmcgY29tbWVudCB0YWcgdG8gbWF0Y2g6ICcgKyBzdGFydENvbW1lbnQubm9kZVZhbHVlKSB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1hdGNoaW5nRW5kQ29tbWVudCAoc3RhcnRDb21tZW50LCBhbGxvd1VuYmFsYW5jZWQpIHtcbiAgICB2YXIgYWxsVmlydHVhbENoaWxkcmVuID0gZ2V0VmlydHVhbENoaWxkcmVuKHN0YXJ0Q29tbWVudCwgYWxsb3dVbmJhbGFuY2VkKTtcbiAgICBpZiAoYWxsVmlydHVhbENoaWxkcmVuKSB7XG4gICAgICBpZiAoYWxsVmlydHVhbENoaWxkcmVuLmxlbmd0aCA+IDApIHsgcmV0dXJuIGFsbFZpcnR1YWxDaGlsZHJlblthbGxWaXJ0dWFsQ2hpbGRyZW4ubGVuZ3RoIC0gMV0ubmV4dFNpYmxpbmcgfVxuICAgICAgcmV0dXJuIHN0YXJ0Q29tbWVudC5uZXh0U2libGluZ1xuICAgIH0gZWxzZSB7IHJldHVybiBudWxsIH0gLy8gTXVzdCBoYXZlIG5vIG1hdGNoaW5nIGVuZCBjb21tZW50LCBhbmQgYWxsb3dVbmJhbGFuY2VkIGlzIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVuYmFsYW5jZWRDaGlsZFRhZ3MgKG5vZGUpIHtcbiAgICAgIC8vIGUuZy4sIGZyb20gPGRpdj5PSzwvZGl2PjwhLS0ga28gYmxhaCAtLT48c3Bhbj5Bbm90aGVyPC9zcGFuPiwgcmV0dXJuczogPCEtLSBrbyBibGFoIC0tPjxzcGFuPkFub3RoZXI8L3NwYW4+XG4gICAgICAvLyAgICAgICBmcm9tIDxkaXY+T0s8L2Rpdj48IS0tIC9rbyAtLT48IS0tIC9rbyAtLT4sICAgICAgICAgICAgIHJldHVybnM6IDwhLS0gL2tvIC0tPjwhLS0gL2tvIC0tPlxuICAgIHZhciBjaGlsZE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQsIGNhcHR1cmVSZW1haW5pbmcgPSBudWxsO1xuICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNhcHR1cmVSZW1haW5pbmcpICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgaGl0IGFuIHVuYmFsYW5jZWQgbm9kZSBhbmQgYXJlIG5vdyBqdXN0IHNjb29waW5nIHVwIGFsbCBzdWJzZXF1ZW50IG5vZGVzXG4gICAgICAgICAgICB7IGNhcHR1cmVSZW1haW5pbmcucHVzaChjaGlsZE5vZGUpOyB9IGVsc2UgaWYgKGlzU3RhcnRDb21tZW50KGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nRW5kQ29tbWVudCA9IGdldE1hdGNoaW5nRW5kQ29tbWVudChjaGlsZE5vZGUsIC8qIGFsbG93VW5iYWxhbmNlZDogKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaGluZ0VuZENvbW1lbnQpICAgICAgICAgICAgIC8vIEl0J3MgYSBiYWxhbmNlZCB0YWcsIHNvIHNraXAgaW1tZWRpYXRlbHkgdG8gdGhlIGVuZCBvZiB0aGlzIHZpcnR1YWwgc2V0XG4gICAgICAgICAgICAgICAgICAgIHsgY2hpbGROb2RlID0gbWF0Y2hpbmdFbmRDb21tZW50OyB9IGVsc2UgeyBjYXB0dXJlUmVtYWluaW5nID0gW2NoaWxkTm9kZV07IH0gLy8gSXQncyB1bmJhbGFuY2VkLCBzbyBzdGFydCBjYXB0dXJpbmcgZnJvbSB0aGlzIHBvaW50XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRW5kQ29tbWVudChjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVSZW1haW5pbmcgPSBbY2hpbGROb2RlXTsgICAgIC8vIEl0J3MgdW5iYWxhbmNlZCAoaWYgaXQgd2Fzbid0LCB3ZSdkIGhhdmUgc2tpcHBlZCBvdmVyIGl0IGFscmVhZHkpLCBzbyBzdGFydCBjYXB0dXJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZylcbiAgICB9XG4gICAgcmV0dXJuIGNhcHR1cmVSZW1haW5pbmdcbiAgfVxuXG4gIHZhciBhbGxvd2VkQmluZGluZ3MgPSB7fTtcbiAgdmFyIGhhc0JpbmRpbmdWYWx1ZSA9IGlzU3RhcnRDb21tZW50O1xuXG4gIGZ1bmN0aW9uIGNoaWxkTm9kZXMgKG5vZGUpIHtcbiAgICByZXR1cm4gaXNTdGFydENvbW1lbnQobm9kZSkgPyBnZXRWaXJ0dWFsQ2hpbGRyZW4obm9kZSkgOiBub2RlLmNoaWxkTm9kZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZSAobm9kZSkge1xuICAgIGlmICghaXNTdGFydENvbW1lbnQobm9kZSkpIHsgZW1wdHlEb21Ob2RlKG5vZGUpOyB9IGVsc2Uge1xuICAgICAgdmFyIHZpcnR1YWxDaGlsZHJlbiA9IGNoaWxkTm9kZXMobm9kZSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHZpcnR1YWxDaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHsgcmVtb3ZlTm9kZSh2aXJ0dWFsQ2hpbGRyZW5baV0pOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0RG9tTm9kZUNoaWxkcmVuJDEgKG5vZGUsIGNoaWxkTm9kZXMpIHtcbiAgICBpZiAoIWlzU3RhcnRDb21tZW50KG5vZGUpKSB7IHNldERvbU5vZGVDaGlsZHJlbihub2RlLCBjaGlsZE5vZGVzKTsgfSBlbHNlIHtcbiAgICAgIGVtcHR5Tm9kZShub2RlKTtcbiAgICAgIGNvbnN0IGVuZENvbW1lbnROb2RlID0gbm9kZS5uZXh0U2libGluZzsgLy8gTXVzdCBiZSB0aGUgbmV4dCBzaWJsaW5nLCBhcyB3ZSBqdXN0IGVtcHRpZWQgdGhlIGNoaWxkcmVuXG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gZW5kQ29tbWVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGROb2Rlc1tpXSwgZW5kQ29tbWVudE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBlbmQgKGNvbnRhaW5lck5vZGUsIG5vZGVUb1ByZXBlbmQpIHtcbiAgICBpZiAoIWlzU3RhcnRDb21tZW50KGNvbnRhaW5lck5vZGUpKSB7XG4gICAgICBpZiAoY29udGFpbmVyTm9kZS5maXJzdENoaWxkKSB7IGNvbnRhaW5lck5vZGUuaW5zZXJ0QmVmb3JlKG5vZGVUb1ByZXBlbmQsIGNvbnRhaW5lck5vZGUuZmlyc3RDaGlsZCk7IH0gZWxzZSB7IGNvbnRhaW5lck5vZGUuYXBwZW5kQ2hpbGQobm9kZVRvUHJlcGVuZCk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFN0YXJ0IGNvbW1lbnRzIG11c3QgYWx3YXlzIGhhdmUgYSBwYXJlbnQgYW5kIGF0IGxlYXN0IG9uZSBmb2xsb3dpbmcgc2libGluZyAodGhlIGVuZCBjb21tZW50KVxuICAgICAgY29udGFpbmVyTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlVG9QcmVwZW5kLCBjb250YWluZXJOb2RlLm5leHRTaWJsaW5nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRBZnRlciAoY29udGFpbmVyTm9kZSwgbm9kZVRvSW5zZXJ0LCBpbnNlcnRBZnRlck5vZGUpIHtcbiAgICBpZiAoIWluc2VydEFmdGVyTm9kZSkge1xuICAgICAgcHJlcGVuZChjb250YWluZXJOb2RlLCBub2RlVG9JbnNlcnQpO1xuICAgIH0gZWxzZSBpZiAoIWlzU3RhcnRDb21tZW50KGNvbnRhaW5lck5vZGUpKSB7XG4gICAgICAgICAgLy8gSW5zZXJ0IGFmdGVyIGluc2VydGlvbiBwb2ludFxuICAgICAgaWYgKGluc2VydEFmdGVyTm9kZS5uZXh0U2libGluZykgeyBjb250YWluZXJOb2RlLmluc2VydEJlZm9yZShub2RlVG9JbnNlcnQsIGluc2VydEFmdGVyTm9kZS5uZXh0U2libGluZyk7IH0gZWxzZSB7IGNvbnRhaW5lck5vZGUuYXBwZW5kQ2hpbGQobm9kZVRvSW5zZXJ0KTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2hpbGRyZW4gb2Ygc3RhcnQgY29tbWVudHMgbXVzdCBhbHdheXMgaGF2ZSBhIHBhcmVudCBhbmQgYXQgbGVhc3Qgb25lIGZvbGxvd2luZyBzaWJsaW5nICh0aGUgZW5kIGNvbW1lbnQpXG4gICAgICBjb250YWluZXJOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGVUb0luc2VydCwgaW5zZXJ0QWZ0ZXJOb2RlLm5leHRTaWJsaW5nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaXJzdENoaWxkIChub2RlKSB7XG4gICAgaWYgKCFpc1N0YXJ0Q29tbWVudChub2RlKSkge1xuICAgICAgaWYgKG5vZGUuZmlyc3RDaGlsZCAmJiBpc0VuZENvbW1lbnQobm9kZS5maXJzdENoaWxkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGludmFsaWQgZW5kIGNvbW1lbnQsIGFzIHRoZSBmaXJzdCBjaGlsZCBvZiAnICsgbm9kZS5vdXRlckhUTUwpXG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZS5maXJzdENoaWxkXG4gICAgfVxuICAgIGlmICghbm9kZS5uZXh0U2libGluZyB8fCBpc0VuZENvbW1lbnQobm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG4gIH1cblxuICBmdW5jdGlvbiBsYXN0Q2hpbGQgKG5vZGUpIHtcbiAgICBsZXQgbmV4dENoaWxkID0gZmlyc3RDaGlsZChub2RlKTtcbiAgICBsZXQgbGFzdENoaWxkTm9kZTtcblxuICAgIGRvIHtcbiAgICAgIGxhc3RDaGlsZE5vZGUgPSBuZXh0Q2hpbGQ7XG4gICAgfSB3aGlsZSAobmV4dENoaWxkID0gbmV4dFNpYmxpbmcobmV4dENoaWxkKSlcblxuICAgIHJldHVybiBsYXN0Q2hpbGROb2RlXG4gIH1cblxuICBmdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICAgIGlmIChpc1N0YXJ0Q29tbWVudChub2RlKSkge1xuICAgICAgbm9kZSA9IGdldE1hdGNoaW5nRW5kQ29tbWVudChub2RlKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5uZXh0U2libGluZyAmJiBpc0VuZENvbW1lbnQobm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgIGlmIChpc1VubWF0Y2hlZEVuZENvbW1lbnQobm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ZvdW5kIGVuZCBjb21tZW50IHdpdGhvdXQgYSBtYXRjaGluZyBvcGVuaW5nIGNvbW1lbnQsIGFzIG5leHQgc2libGluZyBvZiAnICsgbm9kZS5vdXRlckhUTUwpXG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXZpb3VzU2libGluZyAobm9kZSkge1xuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgZG8ge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgaWYgKGlzU3RhcnRDb21tZW50KG5vZGUpKSB7XG4gICAgICAgICAgaWYgKC0tZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzRW5kQ29tbWVudChub2RlKSkge1xuICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkgeyByZXR1cm4gbm9kZSB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAobm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKVxuICB9XG5cbiAgZnVuY3Rpb24gdmlydHVhbE5vZGVCaW5kaW5nVmFsdWUgKG5vZGUpIHtcbiAgICB2YXIgcmVnZXhNYXRjaCA9IChjb21tZW50Tm9kZXNIYXZlVGV4dFByb3BlcnR5ID8gbm9kZS50ZXh0IDogbm9kZS5ub2RlVmFsdWUpLm1hdGNoKHN0YXJ0Q29tbWVudFJlZ2V4KTtcbiAgICByZXR1cm4gcmVnZXhNYXRjaCA/IHJlZ2V4TWF0Y2hbMV0gOiBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpc2VWaXJ0dWFsRWxlbWVudERvbVN0cnVjdHVyZSAoZWxlbWVudFZlcmlmaWVkKSB7XG4gICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzE1NVxuICAgICAgLy8gKElFIDw9IDggb3IgSUUgOSBxdWlya3MgbW9kZSBwYXJzZXMgeW91ciBIVE1MIHdlaXJkbHksIHRyZWF0aW5nIGNsb3NpbmcgPC9saT4gdGFncyBhcyBpZiB0aGV5IGRvbid0IGV4aXN0LCB0aGVyZWJ5IG1vdmluZyBjb21tZW50IG5vZGVzXG4gICAgICAvLyB0aGF0IGFyZSBkaXJlY3QgZGVzY2VuZGFudHMgb2YgPHVsPiBpbnRvIHRoZSBwcmVjZWRpbmcgPGxpPilcbiAgICBpZiAoIWh0bWxUYWdzV2l0aE9wdGlvbmFsbHlDbG9zaW5nQ2hpbGRyZW5bdGFnTmFtZUxvd2VyKGVsZW1lbnRWZXJpZmllZCldKSB7IHJldHVybiB9XG5cbiAgICAgIC8vIFNjYW4gaW1tZWRpYXRlIGNoaWxkcmVuIHRvIHNlZSBpZiB0aGV5IGNvbnRhaW4gdW5iYWxhbmNlZCBjb21tZW50IHRhZ3MuIElmIHRoZXkgZG8sIHRob3NlIGNvbW1lbnQgdGFnc1xuICAgICAgLy8gbXVzdCBiZSBpbnRlbmRlZCB0byBhcHBlYXIgKmFmdGVyKiB0aGF0IGNoaWxkLCBzbyBtb3ZlIHRoZW0gdGhlcmUuXG4gICAgdmFyIGNoaWxkTm9kZSA9IGVsZW1lbnRWZXJpZmllZC5maXJzdENoaWxkO1xuICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHZhciB1bmJhbGFuY2VkVGFncyA9IGdldFVuYmFsYW5jZWRDaGlsZFRhZ3MoY2hpbGROb2RlKTtcbiAgICAgICAgICBpZiAodW5iYWxhbmNlZFRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGaXggdXAgdGhlIERPTSBieSBtb3ZpbmcgdGhlIHVuYmFsYW5jZWQgdGFncyB0byB3aGVyZSB0aGV5IG1vc3QgbGlrZWx5IHdlcmUgaW50ZW5kZWQgdG8gYmUgcGxhY2VkIC0gKmFmdGVyKiB0aGUgY2hpbGRcbiAgICAgICAgICAgIHZhciBub2RlVG9JbnNlcnRCZWZvcmUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuYmFsYW5jZWRUYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlVG9JbnNlcnRCZWZvcmUpIHsgZWxlbWVudFZlcmlmaWVkLmluc2VydEJlZm9yZSh1bmJhbGFuY2VkVGFnc1tpXSwgbm9kZVRvSW5zZXJ0QmVmb3JlKTsgfSBlbHNlIHsgZWxlbWVudFZlcmlmaWVkLmFwcGVuZENoaWxkKHVuYmFsYW5jZWRUYWdzW2ldKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nKVxuICAgIH1cbiAgfVxuXG4gIHZhciB2aXJ0dWFsRWxlbWVudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgc3RhcnRDb21tZW50UmVnZXg6IHN0YXJ0Q29tbWVudFJlZ2V4LFxuICAgIGVuZENvbW1lbnRSZWdleDogZW5kQ29tbWVudFJlZ2V4LFxuICAgIGlzU3RhcnRDb21tZW50OiBpc1N0YXJ0Q29tbWVudCxcbiAgICBpc0VuZENvbW1lbnQ6IGlzRW5kQ29tbWVudCxcbiAgICBnZXRWaXJ0dWFsQ2hpbGRyZW46IGdldFZpcnR1YWxDaGlsZHJlbixcbiAgICBhbGxvd2VkQmluZGluZ3M6IGFsbG93ZWRCaW5kaW5ncyxcbiAgICBoYXNCaW5kaW5nVmFsdWU6IGhhc0JpbmRpbmdWYWx1ZSxcbiAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzLFxuICAgIGVtcHR5Tm9kZTogZW1wdHlOb2RlLFxuICAgIHNldERvbU5vZGVDaGlsZHJlbjogc2V0RG9tTm9kZUNoaWxkcmVuJDEsXG4gICAgcHJlcGVuZDogcHJlcGVuZCxcbiAgICBpbnNlcnRBZnRlcjogaW5zZXJ0QWZ0ZXIsXG4gICAgZmlyc3RDaGlsZDogZmlyc3RDaGlsZCxcbiAgICBsYXN0Q2hpbGQ6IGxhc3RDaGlsZCxcbiAgICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gICAgcHJldmlvdXNTaWJsaW5nOiBwcmV2aW91c1NpYmxpbmcsXG4gICAgdmlydHVhbE5vZGVCaW5kaW5nVmFsdWU6IHZpcnR1YWxOb2RlQmluZGluZ1ZhbHVlLFxuICAgIG5vcm1hbGlzZVZpcnR1YWxFbGVtZW50RG9tU3RydWN0dXJlOiBub3JtYWxpc2VWaXJ0dWFsRWxlbWVudERvbVN0cnVjdHVyZVxuICB9KTtcblxuICAvL1xuXG4gIHZhciBub25lID0gWzAsICcnLCAnJ10sXG4gICAgdGFibGUgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXSxcbiAgICB0Ym9keSA9IFsyLCAnPHRhYmxlPjx0Ym9keT4nLCAnPC90Ym9keT48L3RhYmxlPiddLFxuICAgIGNvbGdyb3VwID0gWyAyLCAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLCAnPC9jb2xncm91cD48L3RhYmxlPiddLFxuICAgIHRyID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J10sXG4gICAgc2VsZWN0ID0gWzEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCAnPC9zZWxlY3Q+J10sXG4gICAgZmllbGRzZXQgPSBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgICBtYXAgPSBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAgIG9iamVjdCA9IFsxLCAnPG9iamVjdD4nLCAnPC9vYmplY3Q+J10sXG4gICAgbG9va3VwID0ge1xuICAgICAgJ2FyZWEnOiBtYXAsXG4gICAgICAnY29sJzogY29sZ3JvdXAsXG4gICAgICAnY29sZ3JvdXAnOiB0YWJsZSxcbiAgICAgICdjYXB0aW9uJzogdGFibGUsXG4gICAgICAnbGVnZW5kJzogZmllbGRzZXQsXG4gICAgICAndGhlYWQnOiB0YWJsZSxcbiAgICAgICd0Ym9keSc6IHRhYmxlLFxuICAgICAgJ3Rmb290JzogdGFibGUsXG4gICAgICAndHInOiB0Ym9keSxcbiAgICAgICd0ZCc6IHRyLFxuICAgICAgJ3RoJzogdHIsXG4gICAgICAnb3B0aW9uJzogc2VsZWN0LFxuICAgICAgJ29wdGdyb3VwJzogc2VsZWN0LFxuICAgICAgJ3BhcmFtJzogb2JqZWN0XG4gICAgfSxcblxuICAgICAgLy8gVGhlIGNhbm9uaWNhbCB3YXkgdG8gdGVzdCB0aGF0IHRoZSBIVE1MNSA8dGVtcGxhdGU+IHRhZyBpcyBzdXBwb3J0ZWRcbiAgICBzdXBwb3J0c1RlbXBsYXRlVGFnID0gb3B0aW9ucy5kb2N1bWVudCAmJiAnY29udGVudCcgaW4gb3B0aW9ucy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuXG4gIGZ1bmN0aW9uIGdldFdyYXAgKHRhZ3MpIHtcbiAgICBjb25zdCBtID0gdGFncy5tYXRjaCgvXig/OjwhLS0uKj8tLT5cXHMqPykqPzwoW2Etel0rKVtcXHM+XS8pO1xuICAgIHJldHVybiAobSAmJiBsb29rdXBbbVsxXV0pIHx8IG5vbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpbXBsZUh0bWxQYXJzZSAoaHRtbCwgZG9jdW1lbnRDb250ZXh0KSB7XG4gICAgZG9jdW1lbnRDb250ZXh0IHx8IChkb2N1bWVudENvbnRleHQgPSBkb2N1bWVudCk7XG4gICAgdmFyIHdpbmRvd0NvbnRleHQgPSBkb2N1bWVudENvbnRleHRbJ3BhcmVudFdpbmRvdyddIHx8IGRvY3VtZW50Q29udGV4dFsnZGVmYXVsdFZpZXcnXSB8fCB3aW5kb3c7XG5cbiAgICAgIC8vIEJhc2VkIG9uIGpRdWVyeSdzIFwiY2xlYW5cIiBmdW5jdGlvbiwgYnV0IG9ubHkgYWNjb3VudGluZyBmb3IgdGFibGUtcmVsYXRlZCBlbGVtZW50cy5cbiAgICAgIC8vIElmIHlvdSBoYXZlIHJlZmVyZW5jZWQgalF1ZXJ5LCB0aGlzIHdvbid0IGJlIHVzZWQgYW55d2F5IC0gS08gd2lsbCB1c2UgalF1ZXJ5J3MgXCJjbGVhblwiIGZ1bmN0aW9uIGRpcmVjdGx5XG5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGVyZSdzIHN0aWxsIGFuIGlzc3VlIGluIElFIDwgOSB3aGVyZWJ5IGl0IHdpbGwgZGlzY2FyZCBjb21tZW50IG5vZGVzIHRoYXQgYXJlIHRoZSBmaXJzdCBjaGlsZCBvZlxuICAgICAgLy8gYSBkZXNjZW5kYW50IG5vZGUuIEZvciBleGFtcGxlOiBcIjxkaXY+PCEtLSBteWNvbW1lbnQgLS0+YWJjPC9kaXY+XCIgd2lsbCBnZXQgcGFyc2VkIGFzIFwiPGRpdj5hYmM8L2Rpdj5cIlxuICAgICAgLy8gVGhpcyB3b24ndCBhZmZlY3QgYW55b25lIHdobyBoYXMgcmVmZXJlbmNlZCBqUXVlcnksIGFuZCB0aGVyZSdzIGFsd2F5cyB0aGUgd29ya2Fyb3VuZCBvZiBpbnNlcnRpbmcgYSBkdW1teSBub2RlXG4gICAgICAvLyAocG9zc2libHkgYSB0ZXh0IG5vZGUpIGluIGZyb250IG9mIHRoZSBjb21tZW50LiBTbywgS08gZG9lcyBub3QgYXR0ZW1wdCB0byB3b3JrYXJvdW5kIHRoaXMgSUUgaXNzdWUgYXV0b21hdGljYWxseSBhdCBwcmVzZW50LlxuXG4gICAgICAvLyBUcmltIHdoaXRlc3BhY2UsIG90aGVyd2lzZSBpbmRleE9mIHdvbid0IHdvcmsgYXMgZXhwZWN0ZWRcbiAgICB2YXIgdGFncyA9IHN0cmluZ1RyaW0oaHRtbCkudG9Mb3dlckNhc2UoKSwgZGl2ID0gZG9jdW1lbnRDb250ZXh0LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgd3JhcCA9IGdldFdyYXAodGFncyksXG4gICAgICBkZXB0aCA9IHdyYXBbMF07XG5cbiAgICAgIC8vIEdvIHRvIGh0bWwgYW5kIGJhY2ssIHRoZW4gcGVlbCBvZmYgZXh0cmEgd3JhcHBlcnNcbiAgICAgIC8vIE5vdGUgdGhhdCB3ZSBhbHdheXMgcHJlZml4IHdpdGggc29tZSBkdW1teSB0ZXh0LCBiZWNhdXNlIG90aGVyd2lzZSwgSUU8OSB3aWxsIHN0cmlwIG91dCBsZWFkaW5nIGNvbW1lbnQgbm9kZXMgaW4gZGVzY2VuZGFudHMuIFRvdGFsIG1hZG5lc3MuXG4gICAgdmFyIG1hcmt1cCA9ICdpZ25vcmVkPGRpdj4nICsgd3JhcFsxXSArIGh0bWwgKyB3cmFwWzJdICsgJzwvZGl2Pic7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3dDb250ZXh0Wydpbm5lclNoaXYnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIE5vdGUgdGhhdCBpbm5lclNoaXYgaXMgZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgaHRtbDVzaGl2LiBXZSBzaG91bGQgY29uc2lkZXIgYWRkaW5nXG4gICAgICAgICAgLy8gc3VwcG9ydCBmb3IgaHRtbDVzaGl2IChleGNlcHQgaWYgbm8gZXhwbGljaXQgc3VwcG9ydCBpcyBuZWVkZWQsIGUuZy4sIGlmIGh0bWw1c2hpdlxuICAgICAgICAgIC8vIHNvbWVob3cgc2hpbXMgdGhlIG5hdGl2ZSBBUElzIHNvIGl0IGp1c3Qgd29ya3MgYW55d2F5KVxuICAgICAgZGl2LmFwcGVuZENoaWxkKHdpbmRvd0NvbnRleHRbJ2lubmVyU2hpdiddKG1hcmt1cCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gbWFya3VwO1xuICAgIH1cblxuICAgICAgLy8gTW92ZSB0byB0aGUgcmlnaHQgZGVwdGhcbiAgICB3aGlsZSAoZGVwdGgtLSkgeyBkaXYgPSBkaXYubGFzdENoaWxkOyB9XG5cbiAgICByZXR1cm4gbWFrZUFycmF5KGRpdi5sYXN0Q2hpbGQuY2hpbGROb2RlcylcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlbXBsYXRlSHRtbFBhcnNlIChodG1sLCBkb2N1bWVudENvbnRleHQpIHtcbiAgICBpZiAoIWRvY3VtZW50Q29udGV4dCkgeyBkb2N1bWVudENvbnRleHQgPSBkb2N1bWVudDsgfVxuICAgIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50Q29udGV4dC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIG1ha2VBcnJheSh0ZW1wbGF0ZS5jb250ZW50LmNoaWxkTm9kZXMpXG4gIH1cblxuICBmdW5jdGlvbiBqUXVlcnlIdG1sUGFyc2UgKGh0bWwsIGRvY3VtZW50Q29udGV4dCkge1xuICAgICAgLy8galF1ZXJ5J3MgXCJwYXJzZUhUTUxcIiBmdW5jdGlvbiB3YXMgaW50cm9kdWNlZCBpbiBqUXVlcnkgMS44LjAgYW5kIGlzIGEgZG9jdW1lbnRlZCBwdWJsaWMgQVBJLlxuICAgIGlmIChqUXVlcnlJbnN0YW5jZS5wYXJzZUhUTUwpIHtcbiAgICAgIHJldHVybiBqUXVlcnlJbnN0YW5jZS5wYXJzZUhUTUwoaHRtbCwgZG9jdW1lbnRDb250ZXh0KSB8fCBbXSAvLyBFbnN1cmUgd2UgYWx3YXlzIHJldHVybiBhbiBhcnJheSBhbmQgbmV2ZXIgbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRm9yIGpRdWVyeSA8IDEuOC4wLCB3ZSBmYWxsIGJhY2sgb24gdGhlIHVuZG9jdW1lbnRlZCBpbnRlcm5hbCBcImNsZWFuXCIgZnVuY3Rpb24uXG4gICAgICB2YXIgZWxlbXMgPSBqUXVlcnlJbnN0YW5jZS5jbGVhbihbaHRtbF0sIGRvY3VtZW50Q29udGV4dCk7XG5cbiAgICAgICAgICAvLyBBcyBvZiBqUXVlcnkgMS43LjEsIGpRdWVyeSBwYXJzZXMgdGhlIEhUTUwgYnkgYXBwZW5kaW5nIGl0IHRvIHNvbWUgZHVtbXkgcGFyZW50IG5vZGVzIGhlbGQgaW4gYW4gaW4tbWVtb3J5IGRvY3VtZW50IGZyYWdtZW50LlxuICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIGl0IG5ldmVyIGNsZWFycyB0aGUgZHVtbXkgcGFyZW50IG5vZGVzIGZyb20gdGhlIGRvY3VtZW50IGZyYWdtZW50LCBzbyBpdCBsZWFrcyBtZW1vcnkgb3ZlciB0aW1lLlxuICAgICAgICAgIC8vIEZpeCB0aGlzIGJ5IGZpbmRpbmcgdGhlIHRvcC1tb3N0IGR1bW15IHBhcmVudCBlbGVtZW50LCBhbmQgZGV0YWNoaW5nIGl0IGZyb20gaXRzIG93bmVyIGZyYWdtZW50LlxuICAgICAgaWYgKGVsZW1zICYmIGVsZW1zWzBdKSB7XG4gICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRvcC1tb3N0IHBhcmVudCBlbGVtZW50IHRoYXQncyBhIGRpcmVjdCBjaGlsZCBvZiBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICAgIHZhciBlbGVtID0gZWxlbXNbMF07XG4gICAgICAgIHdoaWxlIChlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSAxMSAvKiBpLmUuLCBEb2N1bWVudEZyYWdtZW50ICovKSB7IGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7IH1cbiAgICAgICAgICAgICAgLy8gLi4uIHRoZW4gZGV0YWNoIGl0XG4gICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHsgZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZUh0bWxGcmFnbWVudCBjb252ZXJ0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIERPTSBOb2Rlcy5cbiAgICogSWYgc3VwcG9ydGVkLCBpdCB1c2VzIDx0ZW1wbGF0ZT4tdGFnIHBhcnNpbmcsIGZhbGxpbmcgYmFjayBvblxuICAgKiBqUXVlcnkgcGFyc2luZyAoaWYgalF1ZXJ5IGlzIHByZXNlbnQpLCBhbmQgZmluYWxseSBvbiBhXG4gICAqIHN0cmFpZ2h0Zm9yd2FyZCBwYXJzZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaHRtbCAgICAgICAgICAgIFRvIGJlIHBhcnNlZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBkb2N1bWVudENvbnRleHQgVGhhdCBvd25zIHRoZSBleGVjdXRpbmcgY29kZS5cbiAgICogQHJldHVybiB7W0RPTU5vZGVdfSAgICAgICAgICAgICAgUGFyc2VkIERPTSBOb2Rlc1xuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VIdG1sRnJhZ21lbnQgKGh0bWwsIGRvY3VtZW50Q29udGV4dCkge1xuICAgICAgLy8gUHJlZmVyIDx0ZW1wbGF0ZT4tdGFnIGJhc2VkIEhUTUwgcGFyc2luZy5cbiAgICByZXR1cm4gc3VwcG9ydHNUZW1wbGF0ZVRhZyA/IHRlbXBsYXRlSHRtbFBhcnNlKGh0bWwsIGRvY3VtZW50Q29udGV4dClcblxuICAgICAgICAgIC8vIEJlbmVmaXQgZnJvbSBqUXVlcnkncyBvbiBvbGQgYnJvd3NlcnMsIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgICAgLy8gTk9URTogalF1ZXJ5J3MgSFRNTCBwYXJzaW5nIGZhaWxzIG9uIGVsZW1lbnQgbmFtZXMgbGlrZSB0ci0qLlxuICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC8xOTg4XG4gICAgICAgICAgOiAoalF1ZXJ5SW5zdGFuY2UgPyBqUXVlcnlIdG1sUGFyc2UoaHRtbCwgZG9jdW1lbnRDb250ZXh0KVxuXG4gICAgICAgICAgLy8gLi4uIG90aGVyd2lzZSwgdGhpcyBzaW1wbGUgbG9naWMgd2lsbCBkbyBpbiBtb3N0IGNvbW1vbiBjYXNlcy5cbiAgICAgICAgICA6IHNpbXBsZUh0bWxQYXJzZShodG1sLCBkb2N1bWVudENvbnRleHQpKVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIdG1sRm9yVGVtcGxhdGVOb2RlcyAoaHRtbCwgZG9jdW1lbnRDb250ZXh0KSB7XG4gICAgY29uc3Qgbm9kZXMgPSBwYXJzZUh0bWxGcmFnbWVudChodG1sLCBkb2N1bWVudENvbnRleHQpO1xuICAgIHJldHVybiAobm9kZXMubGVuZ3RoICYmIG5vZGVzWzBdLnBhcmVudEVsZW1lbnQpIHx8IG1vdmVDbGVhbmVkTm9kZXNUb0NvbnRhaW5lckVsZW1lbnQobm9kZXMpXG4gIH1cblxuICAvKipcbiAgICAqIHNldEh0bWwgZW1wdGllcyB0aGUgbm9kZSdzIGNvbnRlbnRzLCB1bndyYXBzIHRoZSBIVE1MLCBhbmRcbiAgICAqIHNldHMgdGhlIG5vZGUncyBIVE1MIHVzaW5nIGpRdWVyeS5odG1sIG9yIHBhcnNlSHRtbEZyYWdtZW50XG4gICAgKlxuICAgICogQHBhcmFtIHtET01Ob2RlfSBub2RlIE5vZGUgaW4gd2hpY2ggSFRNTCBuZWVkcyB0byBiZSBzZXRcbiAgICAqIEBwYXJhbSB7RE9NTm9kZX0gaHRtbCBIVE1MIHRvIGJlIGluc2VydGVkIGluIG5vZGVcbiAgICAqIEByZXR1cm5zIHVuZGVmaW5lZFxuICAgICovXG4gIGZ1bmN0aW9uIHNldEh0bWwgKG5vZGUsIGh0bWwpIHtcbiAgICBlbXB0eURvbU5vZGUobm9kZSk7XG5cbiAgICAgIC8vIFRoZXJlJ3MgZmV3IGNhc2VzIHdoZXJlIHdlIHdvdWxkIHdhbnQgdG8gZGlzcGxheSBhIHN0cmluZ2lmaWVkXG4gICAgICAvLyBmdW5jdGlvbiwgc28gd2UgdW53cmFwIGl0LlxuICAgIGlmICh0eXBlb2YgaHRtbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaHRtbCA9IGh0bWwoKTtcbiAgICB9XG5cbiAgICBpZiAoKGh0bWwgIT09IG51bGwpICYmIChodG1sICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICBpZiAodHlwZW9mIGh0bWwgIT09ICdzdHJpbmcnKSB7IGh0bWwgPSBodG1sLnRvU3RyaW5nKCk7IH1cblxuICAgICAgICAgIC8vIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIDx0ZW1wbGF0ZT4gdGFncywgcHJlZmVyIHRoYXQsIGFzXG4gICAgICAgICAgLy8gaXQgb2J2aWF0ZXMgYWxsIHRoZSBjb21wbGV4IHdvcmthcm91bmRzIG9mIGpRdWVyeS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEhvd2V2ZXIsIGpRdWVyeSBjb250YWlucyBhIGxvdCBvZiBzb3BoaXN0aWNhdGVkIGNvZGUgdG8gcGFyc2UgYXJiaXRyYXJ5IEhUTUwgZnJhZ21lbnRzLFxuICAgICAgICAgIC8vIGZvciBleGFtcGxlIDx0cj4gZWxlbWVudHMgd2hpY2ggYXJlIG5vdCBub3JtYWxseSBhbGxvd2VkIHRvIGV4aXN0IG9uIHRoZWlyIG93bi5cbiAgICAgICAgICAvLyBJZiB5b3UndmUgcmVmZXJlbmNlZCBqUXVlcnkgKGFuZCB0ZW1wbGF0ZSB0YWdzIGFyZSBub3Qgc3VwcG9ydGVkKSB3ZSdsbCB1c2UgdGhhdCByYXRoZXIgdGhhbiBkdXBsaWNhdGluZyBpdHMgY29kZS5cbiAgICAgIGlmIChqUXVlcnlJbnN0YW5jZSAmJiAhc3VwcG9ydHNUZW1wbGF0ZVRhZykge1xuICAgICAgICBqUXVlcnlJbnN0YW5jZShub2RlKS5odG1sKGh0bWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gLi4uIG90aGVyd2lzZSwgdXNlIEtPJ3Mgb3duIHBhcnNpbmcgbG9naWMuXG4gICAgICAgIHZhciBwYXJzZWROb2RlcyA9IHBhcnNlSHRtbEZyYWdtZW50KGh0bWwsIG5vZGUub3duZXJEb2N1bWVudCk7XG5cbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgICBpZiAoaHRtbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZW1wdHlOb2RlKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXREb21Ob2RlQ2hpbGRyZW4kMShub2RlLCBwYXJzZWROb2Rlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyc2VkTm9kZXMubGVuZ3RoOyBpKyspIHsgbm9kZS5hcHBlbmRDaGlsZChwYXJzZWROb2Rlc1tpXSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKGVsZW1lbnQsIHRleHRDb250ZW50KSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIHRleHRDb250ZW50ID09PSAnZnVuY3Rpb24nID8gdGV4dENvbnRlbnQoKSA6IHRleHRDb250ZW50O1xuICAgIGlmICgodmFsdWUgPT09IG51bGwpIHx8ICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSkgeyB2YWx1ZSA9ICcnOyB9XG5cbiAgICAgIC8vIFdlIG5lZWQgdGhlcmUgdG8gYmUgZXhhY3RseSBvbmUgY2hpbGQ6IGEgdGV4dCBub2RlLlxuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNoaWxkcmVuLCBtb3JlIHRoYW4gb25lLCBvciBpZiBpdCdzIG5vdCBhIHRleHQgbm9kZSxcbiAgICAgIC8vIHdlJ2xsIGNsZWFyIGV2ZXJ5dGhpbmcgYW5kIGNyZWF0ZSBhIHNpbmdsZSB0ZXh0IG5vZGUuXG4gICAgdmFyIGlubmVyVGV4dE5vZGUgPSBmaXJzdENoaWxkKGVsZW1lbnQpO1xuICAgIGlmICghaW5uZXJUZXh0Tm9kZSB8fCBpbm5lclRleHROb2RlLm5vZGVUeXBlICE9IDMgfHwgbmV4dFNpYmxpbmcoaW5uZXJUZXh0Tm9kZSkpIHtcbiAgICAgIHNldERvbU5vZGVDaGlsZHJlbiQxKGVsZW1lbnQsIFtlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlubmVyVGV4dE5vZGUuZGF0YSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGZvcmNlUmVmcmVzaChlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBoYXNEb21EYXRhRXhwYW5kb1Byb3BlcnR5ID0gU3ltYm9sKCdLbm9ja291dCBzZWxlY3RFeHRlbnNpb25zIGhhc0RvbURhdGFQcm9wZXJ0eScpO1xuXG4gIC8vIE5vcm1hbGx5LCBTRUxFQ1QgZWxlbWVudHMgYW5kIHRoZWlyIE9QVElPTnMgY2FuIG9ubHkgdGFrZSB2YWx1ZSBvZiB0eXBlICdzdHJpbmcnIChiZWNhdXNlIHRoZSB2YWx1ZXNcbiAgLy8gYXJlIHN0b3JlZCBvbiBET00gYXR0cmlidXRlcykuIGtvLnNlbGVjdEV4dGVuc2lvbnMgcHJvdmlkZXMgYSB3YXkgZm9yIFNFTEVDVHMvT1BUSU9OcyB0byBoYXZlIHZhbHVlc1xuICAvLyB0aGF0IGFyZSBhcmJpdHJhcnkgb2JqZWN0cy4gVGhpcyBpcyB2ZXJ5IGNvbnZlbmllbnQgd2hlbiBpbXBsZW1lbnRpbmcgdGhpbmdzIGxpa2UgY2FzY2FkaW5nIGRyb3Bkb3ducy5cbiAgLy9cbiAgdmFyIHNlbGVjdEV4dGVuc2lvbnMgPSB7XG4gICAgb3B0aW9uVmFsdWVEb21EYXRhS2V5OiBuZXh0S2V5KCksXG5cbiAgICByZWFkVmFsdWU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBzd2l0Y2ggKHRhZ05hbWVMb3dlcihlbGVtZW50KSkge1xuICAgICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICAgIGlmIChlbGVtZW50W2hhc0RvbURhdGFFeHBhbmRvUHJvcGVydHldID09PSB0cnVlKSB7IHJldHVybiBnZXQoZWxlbWVudCwgc2VsZWN0RXh0ZW5zaW9ucy5vcHRpb25WYWx1ZURvbURhdGFLZXkpIH1cbiAgICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZVxuICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgIHJldHVybiBlbGVtZW50LnNlbGVjdGVkSW5kZXggPj0gMCA/IHNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKGVsZW1lbnQub3B0aW9uc1tlbGVtZW50LnNlbGVjdGVkSW5kZXhdKSA6IHVuZGVmaW5lZFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBlbGVtZW50LnZhbHVlXG4gICAgICB9XG4gICAgfSxcblxuICAgIHdyaXRlVmFsdWU6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZSwgYWxsb3dVbnNldCkge1xuICAgICAgc3dpdGNoICh0YWdOYW1lTG93ZXIoZWxlbWVudCkpIHtcbiAgICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2V0KGVsZW1lbnQsIHNlbGVjdEV4dGVuc2lvbnMub3B0aW9uVmFsdWVEb21EYXRhS2V5LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgaWYgKGhhc0RvbURhdGFFeHBhbmRvUHJvcGVydHkgaW4gZWxlbWVudCkgeyAvLyBJRSA8PSA4IHRocm93cyBlcnJvcnMgaWYgeW91IGRlbGV0ZSBub24tZXhpc3RlbnQgcHJvcGVydGllcyBmcm9tIGEgRE9NIG5vZGVcbiAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRbaGFzRG9tRGF0YUV4cGFuZG9Qcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgYXJiaXRyYXJ5IG9iamVjdCB1c2luZyBEb21EYXRhXG4gICAgICAgICAgICBzZXQoZWxlbWVudCwgc2VsZWN0RXh0ZW5zaW9ucy5vcHRpb25WYWx1ZURvbURhdGFLZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGVsZW1lbnRbaGFzRG9tRGF0YUV4cGFuZG9Qcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIHRyZWF0bWVudCBvZiBudW1iZXJzIGlzIGp1c3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIEtPIDEuMi4xIHdyb3RlIG51bWVyaWNhbCB2YWx1ZXMgdG8gZWxlbWVudC52YWx1ZS5cbiAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEEgYmxhbmsgc3RyaW5nIG9yIG51bGwgdmFsdWUgd2lsbCBzZWxlY3QgdGhlIGNhcHRpb25cbiAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gLTE7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBlbGVtZW50Lm9wdGlvbnMubGVuZ3RoLCBvcHRpb25WYWx1ZTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgb3B0aW9uVmFsdWUgPSBzZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZShlbGVtZW50Lm9wdGlvbnNbaV0pO1xuICAgICAgICAgICAgLy8gSW5jbHVkZSBzcGVjaWFsIGNoZWNrIHRvIGhhbmRsZSBzZWxlY3RpbmcgYSBjYXB0aW9uIHdpdGggYSBibGFuayBzdHJpbmcgdmFsdWVcbiAgICAgICAgICAgIGlmIChvcHRpb25WYWx1ZSA9PT0gdmFsdWUgfHwgKG9wdGlvblZhbHVlID09PSAnJyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBpO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWxsb3dVbnNldCB8fCBzZWxlY3Rpb24gPj0gMCB8fCAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtZW50LnNpemUgPiAxKSkge1xuICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKGllVmVyc2lvbiA9PT0gNikge1xuICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBJRTYgYnVnOiBJdCB3b24ndCByZWxpYWJseSBhcHBseSB2YWx1ZXMgdG8gU0VMRUNUIG5vZGVzIGR1cmluZyB0aGUgc2FtZSBleGVjdXRpb24gdGhyZWFkXG4gICAgICAgICAgICAgIC8vIHJpZ2h0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBzZXQgb2YgT1BUSU9OIG5vZGVzIG9uIGl0LiBTbyBmb3IgdGhhdCBub2RlIHR5cGUsIHdlJ2xsIHNjaGVkdWxlIGEgc2Vjb25kIHRocmVhZFxuICAgICAgICAgICAgICAvLyB0byBhcHBseSB0aGUgdmFsdWUgYXMgd2VsbC5cbiAgICAgICAgICAgICAgc2FmZVNldFRpbWVvdXQoKCkgPT4geyBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSBzZWxlY3Rpb247IH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICgodmFsdWUgPT09IG51bGwpIHx8ICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSkgeyB2YWx1ZSA9ICcnOyB9XG4gICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vXG5cbiAgdmFyIG1lbW9zID0ge307XG5cbiAgZnVuY3Rpb24gcmFuZG9tTWF4OEhleENoYXJzICgpIHtcbiAgICByZXR1cm4gKCgoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMDAwMDApIHwgMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JZCAoKSB7XG4gICAgcmV0dXJuIHJhbmRvbU1heDhIZXhDaGFycygpICsgcmFuZG9tTWF4OEhleENoYXJzKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRNZW1vTm9kZXMgKHJvb3ROb2RlLCBhcHBlbmRUb0FycmF5KSB7XG4gICAgaWYgKCFyb290Tm9kZSkgeyByZXR1cm4gfVxuICAgIGlmIChyb290Tm9kZS5ub2RlVHlwZSA9PSA4KSB7XG4gICAgICB2YXIgbWVtb0lkID0gcGFyc2VNZW1vVGV4dChyb290Tm9kZS5ub2RlVmFsdWUpO1xuICAgICAgaWYgKG1lbW9JZCAhPSBudWxsKSB7IGFwcGVuZFRvQXJyYXkucHVzaCh7IGRvbU5vZGU6IHJvb3ROb2RlLCBtZW1vSWQ6IG1lbW9JZCB9KTsgfVxuICAgIH0gZWxzZSBpZiAocm9vdE5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGNoaWxkTm9kZXMgPSByb290Tm9kZS5jaGlsZE5vZGVzLCBqID0gY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHsgZmluZE1lbW9Ob2RlcyhjaGlsZE5vZGVzW2ldLCBhcHBlbmRUb0FycmF5KTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lbW9pemUgKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgeyB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW4gb25seSBwYXNzIGEgZnVuY3Rpb24gdG8gbWVtb2l6YXRpb24ubWVtb2l6ZSgpJykgfVxuICAgIHZhciBtZW1vSWQgPSBnZW5lcmF0ZVJhbmRvbUlkKCk7XG4gICAgbWVtb3NbbWVtb0lkXSA9IGNhbGxiYWNrO1xuICAgIHJldHVybiAnPCEtLVtrb19tZW1vOicgKyBtZW1vSWQgKyAnXS0tPidcbiAgfVxuXG4gIGZ1bmN0aW9uIHVubWVtb2l6ZSAobWVtb0lkLCBjYWxsYmFja1BhcmFtcykge1xuICAgIHZhciBjYWxsYmFjayA9IG1lbW9zW21lbW9JZF07XG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhbnkgbWVtbyB3aXRoIElEIFwiICsgbWVtb0lkICsgXCIuIFBlcmhhcHMgaXQncyBhbHJlYWR5IGJlZW4gdW5tZW1vaXplZC5cIikgfVxuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja1BhcmFtcyB8fCBbXSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZmluYWxseSB7IGRlbGV0ZSBtZW1vc1ttZW1vSWRdOyB9XG4gIH1cblxuICBmdW5jdGlvbiB1bm1lbW9pemVEb21Ob2RlQW5kRGVzY2VuZGFudHMgKGRvbU5vZGUsIGV4dHJhQ2FsbGJhY2tQYXJhbXNBcnJheSkge1xuICAgIHZhciBtZW1vcyA9IFtdO1xuICAgIGZpbmRNZW1vTm9kZXMoZG9tTm9kZSwgbWVtb3MpO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gbWVtb3MubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG1lbW9zW2ldLmRvbU5vZGU7XG4gICAgICB2YXIgY29tYmluZWRQYXJhbXMgPSBbbm9kZV07XG4gICAgICBpZiAoZXh0cmFDYWxsYmFja1BhcmFtc0FycmF5KSB7IGFycmF5UHVzaEFsbChjb21iaW5lZFBhcmFtcywgZXh0cmFDYWxsYmFja1BhcmFtc0FycmF5KTsgfVxuICAgICAgdW5tZW1vaXplKG1lbW9zW2ldLm1lbW9JZCwgY29tYmluZWRQYXJhbXMpO1xuICAgICAgbm9kZS5ub2RlVmFsdWUgPSAnJzsgLy8gTmV1dGVyIHRoaXMgbm9kZSBzbyB3ZSBkb24ndCB0cnkgdG8gdW5tZW1vaXplIGl0IGFnYWluXG4gICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7IG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTsgfSAvLyBJZiBwb3NzaWJsZSwgZXJhc2UgaXQgdG90YWxseSAobm90IGFsd2F5cyBwb3NzaWJsZSAtIHNvbWVvbmUgZWxzZSBtaWdodCBqdXN0IGhvbGQgYSByZWZlcmVuY2UgdG8gaXQgdGhlbiBjYWxsIHVubWVtb2l6ZURvbU5vZGVBbmREZXNjZW5kYW50cyBhZ2FpbilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1lbW9UZXh0IChtZW1vVGV4dCkge1xuICAgIHZhciBtYXRjaCA9IG1lbW9UZXh0Lm1hdGNoKC9eXFxba29fbWVtb1xcOiguKj8pXFxdJC8pO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogbnVsbFxuICB9XG5cbiAgdmFyIG1lbW9pemF0aW9uID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIG1lbW9pemU6IG1lbW9pemUsXG4gICAgdW5tZW1vaXplOiB1bm1lbW9pemUsXG4gICAgdW5tZW1vaXplRG9tTm9kZUFuZERlc2NlbmRhbnRzOiB1bm1lbW9pemVEb21Ob2RlQW5kRGVzY2VuZGFudHMsXG4gICAgcGFyc2VNZW1vVGV4dDogcGFyc2VNZW1vVGV4dFxuICB9KTtcblxuICAvL1xuXG4gIHZhciB0YXNrUXVldWUgPSBbXSxcbiAgICB0YXNrUXVldWVMZW5ndGggPSAwLFxuICAgIG5leHRIYW5kbGUgPSAxLFxuICAgIG5leHRJbmRleFRvUHJvY2VzcyA9IDAsXG4gICAgdyA9IG9wdGlvbnMuZ2xvYmFsO1xuXG4gIGlmICh3ICYmIHcuTXV0YXRpb25PYnNlcnZlciAmJiAhKHcubmF2aWdhdG9yICYmIHcubmF2aWdhdG9yLnN0YW5kYWxvbmUpKSB7XG4gICAgICAvLyBDaHJvbWUgMjcrLCBGaXJlZm94IDE0KywgSUUgMTErLCBPcGVyYSAxNSssIFNhZmFyaSA2LjErLCBub2RlXG4gICAgICAvLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQgKiBDb3B5cmlnaHQgKGMpIDIwMTQgUGV0a2EgQW50b25vdiAqIExpY2Vuc2U6IE1JVFxuICAgIG9wdGlvbnMudGFza1NjaGVkdWxlciA9IChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBkaXYgPSB3LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbmV3IHcuTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykub2JzZXJ2ZShkaXYsIHthdHRyaWJ1dGVzOiB0cnVlfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBkaXYuY2xhc3NMaXN0LnRvZ2dsZSgnZm9vJyk7IH1cbiAgICB9KShzY2hlZHVsZWRQcm9jZXNzKTtcbiAgfSBlbHNlIGlmICh3ICYmIHcuZG9jdW1lbnQgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgICAgLy8gSUUgNi0xMFxuICAgICAgLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vWXV6dUpTL3NldEltbWVkaWF0ZSAqIENvcHlyaWdodCAoYykgMjAxMiBCYXJuZXNhbmRub2JsZS5jb20sIGxsYywgRG9uYXZvbiBXZXN0LCBhbmQgRG9tZW5pYyBEZW5pY29sYSAqIExpY2Vuc2U6IE1JVFxuICAgIG9wdGlvbnMudGFza1NjaGVkdWxlciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfTtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy50YXNrU2NoZWR1bGVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1Rhc2tzICgpIHtcbiAgICBpZiAodGFza1F1ZXVlTGVuZ3RoKSB7XG4gICAgICAgICAgLy8gRWFjaCBtYXJrIHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhIGxvZ2ljYWwgZ3JvdXAgb2YgdGFza3MgYW5kIHRoZSBudW1iZXIgb2YgdGhlc2UgZ3JvdXBzIGlzXG4gICAgICAgICAgLy8gbGltaXRlZCB0byBwcmV2ZW50IHVuY2hlY2tlZCByZWN1cnNpb24uXG4gICAgICB2YXIgbWFyayA9IHRhc2tRdWV1ZUxlbmd0aCwgY291bnRNYXJrcyA9IDA7XG5cbiAgICAgICAgICAvLyBuZXh0SW5kZXhUb1Byb2Nlc3Mga2VlcHMgdHJhY2sgb2Ygd2hlcmUgd2UgYXJlIGluIHRoZSBxdWV1ZTsgcHJvY2Vzc1Rhc2tzIGNhbiBiZSBjYWxsZWQgcmVjdXJzaXZlbHkgd2l0aG91dCBpc3N1ZVxuICAgICAgZm9yICh2YXIgdGFzazsgbmV4dEluZGV4VG9Qcm9jZXNzIDwgdGFza1F1ZXVlTGVuZ3RoOykge1xuICAgICAgICBpZiAodGFzayA9IHRhc2tRdWV1ZVtuZXh0SW5kZXhUb1Byb2Nlc3MrK10pIHtcbiAgICAgICAgICBpZiAobmV4dEluZGV4VG9Qcm9jZXNzID4gbWFyaykge1xuICAgICAgICAgICAgaWYgKCsrY291bnRNYXJrcyA+PSA1MDAwKSB7XG4gICAgICAgICAgICAgIG5leHRJbmRleFRvUHJvY2VzcyA9IHRhc2tRdWV1ZUxlbmd0aDsgICAvLyBza2lwIGFsbCB0YXNrcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlIHNpbmNlIGFueSBvZiB0aGVtIGNvdWxkIGJlIGNhdXNpbmcgdGhlIHJlY3Vyc2lvblxuICAgICAgICAgICAgICBkZWZlckVycm9yKEVycm9yKFwiJ1RvbyBtdWNoIHJlY3Vyc2lvbicgYWZ0ZXIgcHJvY2Vzc2luZyBcIiArIGNvdW50TWFya3MgKyAnIHRhc2sgZ3JvdXBzLicpKTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcmsgPSB0YXNrUXVldWVMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YXNrKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGRlZmVyRXJyb3IoZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlZFByb2Nlc3MgKCkge1xuICAgIHByb2Nlc3NUYXNrcygpO1xuXG4gICAgICAvLyBSZXNldCB0aGUgcXVldWVcbiAgICBuZXh0SW5kZXhUb1Byb2Nlc3MgPSB0YXNrUXVldWVMZW5ndGggPSB0YXNrUXVldWUubGVuZ3RoID0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlVGFza1Byb2Nlc3NpbmcgKCkge1xuICAgIG9wdGlvbnMudGFza1NjaGVkdWxlcihzY2hlZHVsZWRQcm9jZXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlIChmdW5jKSB7XG4gICAgaWYgKCF0YXNrUXVldWVMZW5ndGgpIHtcbiAgICAgIHNjaGVkdWxlVGFza1Byb2Nlc3NpbmcoKTtcbiAgICB9XG5cbiAgICB0YXNrUXVldWVbdGFza1F1ZXVlTGVuZ3RoKytdID0gZnVuYztcbiAgICByZXR1cm4gbmV4dEhhbmRsZSsrXG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwgKGhhbmRsZSkge1xuICAgIHZhciBpbmRleCA9IGhhbmRsZSAtIChuZXh0SGFuZGxlIC0gdGFza1F1ZXVlTGVuZ3RoKTtcbiAgICBpZiAoaW5kZXggPj0gbmV4dEluZGV4VG9Qcm9jZXNzICYmIGluZGV4IDwgdGFza1F1ZXVlTGVuZ3RoKSB7XG4gICAgICB0YXNrUXVldWVbaW5kZXhdID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBGb3IgdGVzdGluZyBvbmx5OiByZXNldCB0aGUgcXVldWUgYW5kIHJldHVybiB0aGUgcHJldmlvdXMgcXVldWUgbGVuZ3RoXG4gIGZ1bmN0aW9uIHJlc2V0Rm9yVGVzdGluZyAoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRhc2tRdWV1ZUxlbmd0aCAtIG5leHRJbmRleFRvUHJvY2VzcztcbiAgICBuZXh0SW5kZXhUb1Byb2Nlc3MgPSB0YXNrUXVldWVMZW5ndGggPSB0YXNrUXVldWUubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICB2YXIgdGFza3MgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgc2NoZWR1bGU6IHNjaGVkdWxlLFxuICAgIGNhbmNlbDogY2FuY2VsLFxuICAgIHJlc2V0Rm9yVGVzdGluZzogcmVzZXRGb3JUZXN0aW5nLFxuICAgIHJ1bkVhcmx5OiBwcm9jZXNzVGFza3NcbiAgfSk7XG5cbiAgLypcbiAgICB0a28udXRpbFxuICAgID09PVxuXG4gICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN1YnNjcmliYWJsZSBzeW1ib2wgdGhhdCdzIHVzZWQgdG8gaWRlbnRpZnkgc3Vic2NyaWJhYmxlcy5cbiAgICovXG4gIGNvbnN0IFNVQlNDUklCQUJMRV9TWU0gPSBTeW1ib2woJ0tub2Nrb3V0IFN1YnNjcmliYWJsZScpO1xuXG4gIGZ1bmN0aW9uIGlzU3Vic2NyaWJhYmxlIChpbnN0YW5jZSkge1xuICAgIHJldHVybiAoaW5zdGFuY2UgJiYgaW5zdGFuY2VbU1VCU0NSSUJBQkxFX1NZTV0pIHx8IGZhbHNlXG4gIH1cblxuICAvL1xuXG4gIGNvbnN0IG91dGVyRnJhbWVzID0gW107XG4gIGxldCBjdXJyZW50RnJhbWU7XG4gIGxldCBsYXN0SWQgPSAwO1xuXG4gIC8vIFJldHVybiBhIHVuaXF1ZSBJRCB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byBhbiBvYnNlcnZhYmxlIGZvciBkZXBlbmRlbmN5IHRyYWNraW5nLlxuICAvLyBUaGVvcmV0aWNhbGx5LCB5b3UgY291bGQgZXZlbnR1YWxseSBvdmVyZmxvdyB0aGUgbnVtYmVyIHN0b3JhZ2Ugc2l6ZSwgcmVzdWx0aW5nXG4gIC8vIGluIGR1cGxpY2F0ZSBJRHMuIEJ1dCBpbiBKYXZhU2NyaXB0LCB0aGUgbGFyZ2VzdCBleGFjdCBpbnRlZ3JhbCB2YWx1ZSBpcyAyXjUzXG4gIC8vIG9yIDksMDA3LDE5OSwyNTQsNzQwLDk5Mi4gSWYgeW91IGNyZWF0ZWQgMSwwMDAsMDAwIElEcyBwZXIgc2Vjb25kLCBpdCB3b3VsZFxuICAvLyB0YWtlIG92ZXIgMjg1IHllYXJzIHRvIHJlYWNoIHRoYXQgbnVtYmVyLlxuICAvLyBSZWZlcmVuY2UgaHR0cDovL2Jsb2cudmpldXguY29tLzIwMTAvamF2YXNjcmlwdC9qYXZhc2NyaXB0LW1heF9pbnQtbnVtYmVyLWxpbWl0cy5odG1sXG4gIGZ1bmN0aW9uIGdldElkICgpIHtcbiAgICByZXR1cm4gKytsYXN0SWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luIChvcHRpb25zKSB7XG4gICAgb3V0ZXJGcmFtZXMucHVzaChjdXJyZW50RnJhbWUpO1xuICAgIGN1cnJlbnRGcmFtZSA9IG9wdGlvbnM7XG4gIH1cblxuICBmdW5jdGlvbiBlbmQgKCkge1xuICAgIGN1cnJlbnRGcmFtZSA9IG91dGVyRnJhbWVzLnBvcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJEZXBlbmRlbmN5IChzdWJzY3JpYmFibGUpIHtcbiAgICBpZiAoY3VycmVudEZyYW1lKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJhYmxlKHN1YnNjcmliYWJsZSkpIHsgdGhyb3cgbmV3IEVycm9yKCdPbmx5IHN1YnNjcmliYWJsZSB0aGluZ3MgY2FuIGFjdCBhcyBkZXBlbmRlbmNpZXMnKSB9XG4gICAgICBjdXJyZW50RnJhbWUuY2FsbGJhY2suY2FsbChjdXJyZW50RnJhbWUuY2FsbGJhY2tUYXJnZXQsIHN1YnNjcmliYWJsZSwgc3Vic2NyaWJhYmxlLl9pZCB8fCAoc3Vic2NyaWJhYmxlLl9pZCA9IGdldElkKCkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpZ25vcmUgKGNhbGxiYWNrLCBjYWxsYmFja1RhcmdldCwgY2FsbGJhY2tBcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJlZ2luKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2tUYXJnZXQsIGNhbGxiYWNrQXJncyB8fCBbXSlcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzQ291bnQgKCkge1xuICAgIGlmIChjdXJyZW50RnJhbWUpIHsgcmV0dXJuIGN1cnJlbnRGcmFtZS5jb21wdXRlZC5nZXREZXBlbmRlbmNpZXNDb3VudCgpIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlcGVuZGVuY2llcyAoKSB7XG4gICAgaWYgKGN1cnJlbnRGcmFtZSkgeyByZXR1cm4gY3VycmVudEZyYW1lLmNvbXB1dGVkLmdldERlcGVuZGVuY2llcygpIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5pdGlhbCAoKSB7XG4gICAgaWYgKGN1cnJlbnRGcmFtZSkgeyByZXR1cm4gY3VycmVudEZyYW1lLmlzSW5pdGlhbCB9XG4gIH1cblxuICB2YXIgZGVwZW5kZW5jeURldGVjdGlvbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBiZWdpbjogYmVnaW4sXG4gICAgZW5kOiBlbmQsXG4gICAgcmVnaXN0ZXJEZXBlbmRlbmN5OiByZWdpc3RlckRlcGVuZGVuY3ksXG4gICAgaWdub3JlOiBpZ25vcmUsXG4gICAgZ2V0RGVwZW5kZW5jaWVzQ291bnQ6IGdldERlcGVuZGVuY2llc0NvdW50LFxuICAgIGdldERlcGVuZGVuY2llczogZ2V0RGVwZW5kZW5jaWVzLFxuICAgIGlzSW5pdGlhbDogaXNJbml0aWFsLFxuICAgIGlnbm9yZURlcGVuZGVuY2llczogaWdub3JlXG4gIH0pO1xuXG4gIC8vXG5cbiAgZnVuY3Rpb24gZGVmZXJVcGRhdGVzICh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Ll9kZWZlclVwZGF0ZXMpIHsgcmV0dXJuIH1cbiAgICB0YXJnZXQuX2RlZmVyVXBkYXRlcyA9IHRydWU7XG4gICAgdGFyZ2V0LmxpbWl0KGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgbGV0IGhhbmRsZTtcbiAgICAgIGxldCBpZ25vcmVVcGRhdGVzID0gZmFsc2U7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlnbm9yZVVwZGF0ZXMpIHtcbiAgICAgICAgICBjYW5jZWwoaGFuZGxlKTtcbiAgICAgICAgICBoYW5kbGUgPSBzY2hlZHVsZShjYWxsYmFjayk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlnbm9yZVVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgdGFyZ2V0Lm5vdGlmeVN1YnNjcmliZXJzKHVuZGVmaW5lZCwgJ2RpcnR5Jyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlnbm9yZVVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNsYXNzIFN1YnNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IgKHRhcmdldCwgb2JzZXJ2ZXIsIGRpc3Bvc2VDYWxsYmFjaykge1xuICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSBvYnNlcnZlci5uZXh0O1xuICAgICAgdGhpcy5fZGlzcG9zZUNhbGxiYWNrID0gZGlzcG9zZUNhbGxiYWNrO1xuICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fZG9tTm9kZURpc3Bvc2FsQ2FsbGJhY2sgPSBudWxsO1xuICAgIH1cblxuICAgIGRpc3Bvc2UgKCkge1xuICAgICAgaWYgKHRoaXMuX2RvbU5vZGVEaXNwb3NhbENhbGxiYWNrKSB7XG4gICAgICAgIHJlbW92ZURpc3Bvc2VDYWxsYmFjayh0aGlzLl9ub2RlLCB0aGlzLl9kb21Ob2RlRGlzcG9zYWxDYWxsYmFjayk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2Rpc3Bvc2VDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCAobm9kZSkge1xuICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgICBhZGREaXNwb3NlQ2FsbGJhY2sobm9kZSwgdGhpcy5fZG9tTm9kZURpc3Bvc2FsQ2FsbGJhY2sgPSB0aGlzLmRpc3Bvc2UuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gVEMzOSBPYnNlcnZhYmxlIEFQSVxuICAgIHVuc3Vic2NyaWJlICgpIHsgdGhpcy5kaXNwb3NlKCk7IH1cbiAgICBnZXQgY2xvc2VkICgpIHsgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQgfVxuICB9XG5cbiAgLy9cblxuICB2YXIgcHJpbWl0aXZlVHlwZXMgPSB7XG4gICAgJ3VuZGVmaW5lZCc6IDEsICdib29sZWFuJzogMSwgJ251bWJlcic6IDEsICdzdHJpbmcnOiAxXG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzQXJlUHJpbWl0aXZlQW5kRXF1YWwgKGEsIGIpIHtcbiAgICB2YXIgb2xkVmFsdWVJc1ByaW1pdGl2ZSA9IChhID09PSBudWxsKSB8fCAodHlwZW9mIChhKSBpbiBwcmltaXRpdmVUeXBlcyk7XG4gICAgcmV0dXJuIG9sZFZhbHVlSXNQcmltaXRpdmUgPyAoYSA9PT0gYikgOiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlFeHRlbmRlcnMgKHJlcXVlc3RlZEV4dGVuZGVycykge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmIChyZXF1ZXN0ZWRFeHRlbmRlcnMpIHtcbiAgICAgIG9iamVjdEZvckVhY2gocmVxdWVzdGVkRXh0ZW5kZXJzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZXh0ZW5kZXJIYW5kbGVyID0gZXh0ZW5kZXJzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgZXh0ZW5kZXJIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gZXh0ZW5kZXJIYW5kbGVyKHRhcmdldCwgdmFsdWUpIHx8IHRhcmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLm9uRXJyb3IobmV3IEVycm9yKCdFeHRlbmRlciBub3QgZm91bmQ6ICcgKyBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIC8qXG4gICAgICAgICAgICAgICAgICAtLS0gREVGQVVMVCBFWFRFTkRFUlMgLS0tXG4gICAqL1xuXG4gIC8vIENoYW5nZSB3aGVuIG5vdGlmaWNhdGlvbnMgYXJlIHB1Ymxpc2hlZC5cbiAgZnVuY3Rpb24gbm90aWZ5ICh0YXJnZXQsIG5vdGlmeVdoZW4pIHtcbiAgICB0YXJnZXQuZXF1YWxpdHlDb21wYXJlciA9IG5vdGlmeVdoZW4gPT0gJ2Fsd2F5cydcbiAgICAgICAgICA/IG51bGwgIC8vIG51bGwgZXF1YWxpdHlDb21wYXJlciBtZWFucyB0byBhbHdheXMgbm90aWZ5XG4gICAgICAgICAgOiB2YWx1ZXNBcmVQcmltaXRpdmVBbmRFcXVhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkICh0YXJnZXQsIG9wdGlvbikge1xuICAgIGlmIChvcHRpb24gIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFxcJ2RlZmVycmVkXFwnIGV4dGVuZGVyIG9ubHkgYWNjZXB0cyB0aGUgdmFsdWUgXFwndHJ1ZVxcJywgYmVjYXVzZSBpdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHR1cm4gZGVmZXJyYWwgb2ZmIG9uY2UgZW5hYmxlZC4nKVxuICAgIH1cbiAgICBkZWZlclVwZGF0ZXModGFyZ2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhdGVMaW1pdCAodGFyZ2V0LCBvcHRpb25zJCQxKSB7XG4gICAgdmFyIHRpbWVvdXQsIG1ldGhvZCwgbGltaXRGdW5jdGlvbjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyQkMSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRpbWVvdXQgPSBvcHRpb25zJCQxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gb3B0aW9ucyQkMS50aW1lb3V0O1xuICAgICAgbWV0aG9kID0gb3B0aW9ucyQkMS5tZXRob2Q7XG4gICAgfVxuXG4gICAgICAvLyByYXRlTGltaXQgc3VwZXJzZWRlcyBkZWZlcnJlZCB1cGRhdGVzXG4gICAgdGFyZ2V0Ll9kZWZlclVwZGF0ZXMgPSBmYWxzZTtcblxuICAgIGxpbWl0RnVuY3Rpb24gPSBtZXRob2QgPT09ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnID8gZGVib3VuY2UgOiB0aHJvdHRsZTtcblxuICAgIHRhcmdldC5saW1pdChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBsaW1pdEZ1bmN0aW9uKGNhbGxiYWNrLCB0aW1lb3V0KVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGV4dGVuZGVycyA9IHtcbiAgICBub3RpZnk6IG5vdGlmeSxcbiAgICBkZWZlcnJlZDogZGVmZXJyZWQsXG4gICAgcmF0ZUxpbWl0OiByYXRlTGltaXRcbiAgfTtcblxuICAvKiBlc2xpbnQgbm8tY29uZC1hc3NpZ246IDAgKi9cblxuICAvLyBEZXNjZW5kYW50cyBtYXkgaGF2ZSBhIExBVEVTVF9WQUxVRSwgd2hpY2ggaWYgcHJlc2VudFxuICAvLyBjYXVzZXMgVEMzOSBzdWJzY3JpcHRpb25zIHRvIGVtaXQgdGhlIGxhdGVzdCB2YWx1ZSB3aGVuXG4gIC8vIHN1YnNjcmliZWQuXG4gIGNvbnN0IExBVEVTVF9WQUxVRSA9IFN5bWJvbCgnS25vY2tvdXQgbGF0ZXN0IHZhbHVlJyk7XG5cbiAgZnVuY3Rpb24gc3Vic2NyaWJhYmxlICgpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywga29fc3Vic2NyaWJhYmxlX2ZuKTtcbiAgICBrb19zdWJzY3JpYmFibGVfZm4uaW5pdCh0aGlzKTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0RXZlbnQgPSAnY2hhbmdlJztcblxuICB2YXIga29fc3Vic2NyaWJhYmxlX2ZuID0ge1xuICAgIFtTVUJTQ1JJQkFCTEVfU1lNXTogdHJ1ZSxcbiAgICBbU3ltYm9sLm9ic2VydmFibGVdICgpIHsgcmV0dXJuIHRoaXMgfSxcblxuICAgIGluaXQgKGluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS5fc3Vic2NyaXB0aW9ucyA9IHsgY2hhbmdlOiBbXSB9O1xuICAgICAgaW5zdGFuY2UuX3ZlcnNpb25OdW1iZXIgPSAxO1xuICAgIH0sXG5cbiAgICBzdWJzY3JpYmUgKGNhbGxiYWNrLCBjYWxsYmFja1RhcmdldCwgZXZlbnQpIHtcbiAgICAgIC8vIFRDMzkgcHJvcG9zZWQgc3RhbmRhcmQgT2JzZXJ2YWJsZSB7IG5leHQ6ICgpID0+IC4uLiB9XG4gICAgICBjb25zdCBpc1RDMzlDYWxsYmFjayA9IHR5cGVvZiBjYWxsYmFjayA9PT0gJ29iamVjdCcgJiYgY2FsbGJhY2submV4dDtcblxuICAgICAgZXZlbnQgPSBldmVudCB8fCBkZWZhdWx0RXZlbnQ7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IGlzVEMzOUNhbGxiYWNrID8gY2FsbGJhY2sgOiB7XG4gICAgICAgIG5leHQ6IGNhbGxiYWNrVGFyZ2V0ID8gY2FsbGJhY2suYmluZChjYWxsYmFja1RhcmdldCkgOiBjYWxsYmFja1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uSW5zdGFuY2UgPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMsIG9ic2VydmVyLCAoKSA9PiB7XG4gICAgICAgIGFycmF5UmVtb3ZlSXRlbSh0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50XSwgc3Vic2NyaXB0aW9uSW5zdGFuY2UpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclN1YnNjcmlwdGlvblJlbW92ZSkge1xuICAgICAgICAgIHRoaXMuYWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmUoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuYmVmb3JlU3Vic2NyaXB0aW9uQWRkKSB7XG4gICAgICAgIHRoaXMuYmVmb3JlU3Vic2NyaXB0aW9uQWRkKGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50XSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50XSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc1tldmVudF0ucHVzaChzdWJzY3JpcHRpb25JbnN0YW5jZSk7XG5cbiAgICAgIC8vIEhhdmUgVEMzOSBgc3Vic2NyaWJlYCBpbW1lZGlhdGVseSBlbWl0LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZS9pc3N1ZXMvMTkwXG5cbiAgICAgIGlmIChpc1RDMzlDYWxsYmFjayAmJiBMQVRFU1RfVkFMVUUgaW4gdGhpcykge1xuICAgICAgICBvYnNlcnZlci5uZXh0KHRoaXNbTEFURVNUX1ZBTFVFXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdWJzY3JpcHRpb25JbnN0YW5jZVxuICAgIH0sXG5cbiAgICBub3RpZnlTdWJzY3JpYmVycyAodmFsdWVUb05vdGlmeSwgZXZlbnQpIHtcbiAgICAgIGV2ZW50ID0gZXZlbnQgfHwgZGVmYXVsdEV2ZW50O1xuICAgICAgaWYgKGV2ZW50ID09PSBkZWZhdWx0RXZlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWZXJzaW9uKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNTdWJzY3JpcHRpb25zRm9yRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIGNvbnN0IHN1YnMgPSBldmVudCA9PT0gZGVmYXVsdEV2ZW50ICYmIHRoaXMuX2NoYW5nZVN1YnNjcmlwdGlvbnNcbiAgICAgICAgICB8fCBbLi4udGhpcy5fc3Vic2NyaXB0aW9uc1tldmVudF1dO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYmVnaW4oKTsgLy8gQmVnaW4gc3VwcHJlc3NpbmcgZGVwZW5kZW5jeSBkZXRlY3Rpb24gKGJ5IHNldHRpbmcgdGhlIHRvcCBmcmFtZSB0byB1bmRlZmluZWQpXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHN1YnNjcmlwdGlvbkluc3RhbmNlOyBzdWJzY3JpcHRpb25JbnN0YW5jZSA9IHN1YnNbaV07ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgYSBzdWJzY3JpcHRpb24gd2FzIGRpc3Bvc2VkIGR1cmluZyB0aGUgYXJyYXlGb3JFYWNoIGN5Y2xlLCBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBpc0Rpc3Bvc2VkIG9uIGVhY2ggc3Vic2NyaXB0aW9uIGJlZm9yZSBpbnZva2luZyBpdHMgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uSW5zdGFuY2UuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uSW5zdGFuY2UuX2NhbGxiYWNrKHZhbHVlVG9Ob3RpZnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBlbmQoKTsgLy8gRW5kIHN1cHByZXNzaW5nIGRlcGVuZGVuY3kgZGV0ZWN0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VmVyc2lvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbk51bWJlclxuICAgIH0sXG5cbiAgICBoYXNDaGFuZ2VkICh2ZXJzaW9uVG9DaGVjaykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmVyc2lvbigpICE9PSB2ZXJzaW9uVG9DaGVja1xuICAgIH0sXG5cbiAgICB1cGRhdGVWZXJzaW9uICgpIHtcbiAgICAgICsrdGhpcy5fdmVyc2lvbk51bWJlcjtcbiAgICB9LFxuXG4gICAgaGFzU3Vic2NyaXB0aW9uc0ZvckV2ZW50IChldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnRdICYmIHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnRdLmxlbmd0aFxuICAgIH0sXG5cbiAgICBnZXRTdWJzY3JpcHRpb25zQ291bnQgKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnRdICYmIHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnRdLmxlbmd0aCB8fCAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgICBvYmplY3RGb3JFYWNoKHRoaXMuX3N1YnNjcmlwdGlvbnMsIGZ1bmN0aW9uIChldmVudE5hbWUsIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICBpZiAoZXZlbnROYW1lICE9PSAnZGlydHknKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBzdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG90YWxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnQgKG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgcmV0dXJuICF0aGlzLmVxdWFsaXR5Q29tcGFyZXIgfHxcbiAgICAgICAgICAgICAgICAgIXRoaXMuZXF1YWxpdHlDb21wYXJlcihvbGRWYWx1ZSwgbmV3VmFsdWUpXG4gICAgfSxcblxuICAgIG9uY2UgKGNiKSB7XG4gICAgICBjb25zdCBzdWJzID0gdGhpcy5zdWJzY3JpYmUoKG52KSA9PiB7XG4gICAgICAgIHN1YnMuZGlzcG9zZSgpO1xuICAgICAgICBjYihudik7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgd2hlbiAodGVzdCwgcmV0dXJuVmFsdWUpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGNvbnN0IGdpdmVuUnYgPSBhcmd1bWVudHMubGVuZ3RoID4gMTtcbiAgICAgIGNvbnN0IHRlc3RGbiA9IHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nID8gdGVzdCA6IHYgPT4gdiA9PT0gdGVzdDtcbiAgICAgIGlmICh0ZXN0Rm4oY3VycmVudCkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuUHJvbWlzZS5yZXNvbHZlKGdpdmVuUnYgPyByZXR1cm5WYWx1ZSA6IGN1cnJlbnQpXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IG9wdGlvbnMuUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnMgPSB0aGlzLnN1YnNjcmliZShuZXdWYWx1ZSA9PiB7XG4gICAgICAgICAgaWYgKHRlc3RGbihuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHN1YnMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZShnaXZlblJ2ID8gcmV0dXJuVmFsdWUgOiBuZXdWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIHlldCAodGVzdCwgLi4uYXJncykge1xuICAgICAgY29uc3QgdGVzdEZuID0gdHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbicgPyB0ZXN0IDogdiA9PiB2ID09PSB0ZXN0O1xuICAgICAgY29uc3QgbmVnYXRlZCA9IHYgPT4gIXRlc3RGbih2KTtcbiAgICAgIHJldHVybiB0aGlzLndoZW4obmVnYXRlZCwgLi4uYXJncylcbiAgICB9LFxuXG4gICAgbmV4dCAoKSB7IHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHRoaXMub25jZShyZXNvbHZlKSkgfSxcblxuICAgIHRvU3RyaW5nICgpIHsgcmV0dXJuICdbb2JqZWN0IE9iamVjdF0nIH0sXG5cbiAgICBleHRlbmQ6IGFwcGx5RXh0ZW5kZXJzXG4gIH07XG5cbiAgLy8gRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBwcm90byBhc3NpZ25tZW50LCB3ZSBvdmVyd3JpdGUgdGhlIHByb3RvdHlwZSBvZiBlYWNoXG4gIC8vIG9ic2VydmFibGUgaW5zdGFuY2UuIFNpbmNlIG9ic2VydmFibGVzIGFyZSBmdW5jdGlvbnMsIHdlIG5lZWQgRnVuY3Rpb24ucHJvdG90eXBlXG4gIC8vIHRvIHN0aWxsIGJlIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihrb19zdWJzY3JpYmFibGVfZm4sIEZ1bmN0aW9uLnByb3RvdHlwZSk7XG5cbiAgc3Vic2NyaWJhYmxlLmZuID0ga29fc3Vic2NyaWJhYmxlX2ZuO1xuXG4gIC8vXG5cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSAoaW5pdGlhbFZhbHVlKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZSAoKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gV3JpdGVcbiAgICAgICAgICAgICAgLy8gSWdub3JlIHdyaXRlcyBpZiB0aGUgdmFsdWUgaGFzbid0IGNoYW5nZWRcbiAgICAgICAgaWYgKE9ic2VydmFibGUuaXNEaWZmZXJlbnQoT2JzZXJ2YWJsZVtMQVRFU1RfVkFMVUVdLCBhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgT2JzZXJ2YWJsZS52YWx1ZVdpbGxNdXRhdGUoKTtcbiAgICAgICAgICBPYnNlcnZhYmxlW0xBVEVTVF9WQUxVRV0gPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgT2JzZXJ2YWJsZS52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcyAvLyBQZXJtaXRzIGNoYWluZWQgYXNzaWdubWVudHNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlYWRcbiAgICAgICAgcmVnaXN0ZXJEZXBlbmRlbmN5KE9ic2VydmFibGUpOyAvLyBUaGUgY2FsbGVyIG9ubHkgbmVlZHMgdG8gYmUgbm90aWZpZWQgb2YgY2hhbmdlcyBpZiB0aGV5IGRpZCBhIFwicmVhZFwiIG9wZXJhdGlvblxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZVtMQVRFU1RfVkFMVUVdXG4gICAgICB9XG4gICAgfVxuXG4gICAgb3ZlcndyaXRlTGVuZ3RoUHJvcGVydHlJZlN1cHBvcnRlZChPYnNlcnZhYmxlLCB7IHZhbHVlOiB1bmRlZmluZWQgfSk7XG5cbiAgICBPYnNlcnZhYmxlW0xBVEVTVF9WQUxVRV0gPSBpbml0aWFsVmFsdWU7XG5cbiAgICBzdWJzY3JpYmFibGUuZm4uaW5pdChPYnNlcnZhYmxlKTtcblxuICAgICAgLy8gSW5oZXJpdCBmcm9tICdvYnNlcnZhYmxlJ1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihPYnNlcnZhYmxlLCBvYnNlcnZhYmxlLmZuKTtcblxuICAgIGlmIChvcHRpb25zLmRlZmVyVXBkYXRlcykge1xuICAgICAgZGVmZXJVcGRhdGVzKE9ic2VydmFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiBPYnNlcnZhYmxlXG4gIH1cblxuICAvLyBEZWZpbmUgcHJvdG90eXBlIGZvciBvYnNlcnZhYmxlc1xuICBvYnNlcnZhYmxlLmZuID0ge1xuICAgIGVxdWFsaXR5Q29tcGFyZXI6IHZhbHVlc0FyZVByaW1pdGl2ZUFuZEVxdWFsLFxuICAgIHBlZWsgKCkgeyByZXR1cm4gdGhpc1tMQVRFU1RfVkFMVUVdIH0sXG4gICAgdmFsdWVIYXNNdXRhdGVkICgpIHtcbiAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnModGhpc1tMQVRFU1RfVkFMVUVdLCAnc3BlY3RhdGUnKTtcbiAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnModGhpc1tMQVRFU1RfVkFMVUVdKTtcbiAgICB9LFxuICAgIHZhbHVlV2lsbE11dGF0ZSAoKSB7XG4gICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHRoaXNbTEFURVNUX1ZBTFVFXSwgJ2JlZm9yZUNoYW5nZScpO1xuICAgIH0sXG5cbiAgICBtb2RpZnkgKGZuLCBwZWVrID0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMoZm4ocGVlayA/IHRoaXMucGVlaygpIDogdGhpcygpKSlcbiAgICB9LFxuXG4gICAgLy8gU29tZSBvYnNlcnZhYmxlcyBtYXkgbm90IGFsd2F5cyBiZSB3cml0ZWFibGUsIG5vdGFibHkgY29tcHV0ZWRzLlxuICAgIGlzV3JpdGVhYmxlOiB0cnVlXG4gIH07XG5cbiAgLy8gTW92ZWQgb3V0IG9mIFwibGltaXRcIiB0byBhdm9pZCB0aGUgZXh0cmEgY2xvc3VyZVxuICBmdW5jdGlvbiBsaW1pdE5vdGlmeVN1YnNjcmliZXJzICh2YWx1ZSwgZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50IHx8IGV2ZW50ID09PSBkZWZhdWx0RXZlbnQpIHtcbiAgICAgIHRoaXMuX2xpbWl0Q2hhbmdlKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSAnYmVmb3JlQ2hhbmdlJykge1xuICAgICAgdGhpcy5fbGltaXRCZWZvcmVDaGFuZ2UodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcmlnTm90aWZ5U3Vic2NyaWJlcnModmFsdWUsIGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYGxpbWl0YCBmdW5jdGlvbiB0byB0aGUgc3Vic2NyaWJhYmxlIHByb3RvdHlwZVxuICBzdWJzY3JpYmFibGUuZm4ubGltaXQgPSBmdW5jdGlvbiBsaW1pdCAobGltaXRGdW5jdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc2VsZklzT2JzZXJ2YWJsZSA9IGlzT2JzZXJ2YWJsZShzZWxmKTtcbiAgICB2YXIgYmVmb3JlQ2hhbmdlID0gJ2JlZm9yZUNoYW5nZSc7XG4gICAgdmFyIGlnbm9yZUJlZm9yZUNoYW5nZSwgbm90aWZ5TmV4dENoYW5nZSwgcHJldmlvdXNWYWx1ZSwgcGVuZGluZ1ZhbHVlLCBkaWRVcGRhdGU7XG5cbiAgICBpZiAoIXNlbGYuX29yaWdOb3RpZnlTdWJzY3JpYmVycykge1xuICAgICAgc2VsZi5fb3JpZ05vdGlmeVN1YnNjcmliZXJzID0gc2VsZi5ub3RpZnlTdWJzY3JpYmVycztcbiAgICAgIHNlbGYubm90aWZ5U3Vic2NyaWJlcnMgPSBsaW1pdE5vdGlmeVN1YnNjcmliZXJzO1xuICAgIH1cblxuICAgIHZhciBmaW5pc2ggPSBsaW1pdEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX25vdGlmaWNhdGlvbklzUGVuZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBJZiBhbiBvYnNlcnZhYmxlIHByb3ZpZGVkIGEgcmVmZXJlbmNlIHRvIGl0c2VsZiwgYWNjZXNzIGl0IHRvIGdldCB0aGUgbGF0ZXN0IHZhbHVlLlxuICAgICAgLy8gVGhpcyBhbGxvd3MgY29tcHV0ZWQgb2JzZXJ2YWJsZXMgdG8gZGVsYXkgY2FsY3VsYXRpbmcgdGhlaXIgdmFsdWUgdW50aWwgbmVlZGVkLlxuICAgICAgaWYgKHNlbGZJc09ic2VydmFibGUgJiYgcGVuZGluZ1ZhbHVlID09PSBzZWxmKSB7XG4gICAgICAgIHBlbmRpbmdWYWx1ZSA9IHNlbGYuX2V2YWxJZkNoYW5nZWQgPyBzZWxmLl9ldmFsSWZDaGFuZ2VkKCkgOiBzZWxmKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaG91bGROb3RpZnkgPSBub3RpZnlOZXh0Q2hhbmdlIHx8IChcbiAgICAgICAgZGlkVXBkYXRlICYmIHNlbGYuaXNEaWZmZXJlbnQocHJldmlvdXNWYWx1ZSwgcGVuZGluZ1ZhbHVlKVxuICAgICAgKTtcbiAgICAgIHNlbGYuX25vdGlmeU5leHRDaGFuZ2UgPSBkaWRVcGRhdGUgPSBpZ25vcmVCZWZvcmVDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgICAgc2VsZi5fb3JpZ05vdGlmeVN1YnNjcmliZXJzKHByZXZpb3VzVmFsdWUgPSBwZW5kaW5nVmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmFzc2lnbihzZWxmLCB7XG4gICAgICBfbGltaXRDaGFuZ2UgICh2YWx1ZSwgaXNEaXJ0eSkge1xuICAgICAgICBpZiAoIWlzRGlydHkgfHwgIXNlbGYuX25vdGlmaWNhdGlvbklzUGVuZGluZykge1xuICAgICAgICAgIGRpZFVwZGF0ZSA9ICFpc0RpcnR5O1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX2NoYW5nZVN1YnNjcmlwdGlvbnMgPSBbLi4uc2VsZi5fc3Vic2NyaXB0aW9uc1tkZWZhdWx0RXZlbnRdXTtcbiAgICAgICAgc2VsZi5fbm90aWZpY2F0aW9uSXNQZW5kaW5nID0gaWdub3JlQmVmb3JlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgcGVuZGluZ1ZhbHVlID0gdmFsdWU7XG4gICAgICAgIGZpbmlzaCgpO1xuICAgICAgfSxcblxuICAgICAgX2xpbWl0QmVmb3JlQ2hhbmdlICh2YWx1ZSkge1xuICAgICAgICBpZiAoIWlnbm9yZUJlZm9yZUNoYW5nZSkge1xuICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBzZWxmLl9vcmlnTm90aWZ5U3Vic2NyaWJlcnModmFsdWUsIGJlZm9yZUNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9ub3RpZnlOZXh0Q2hhbmdlSWZWYWx1ZUlzRGlmZmVyZW50ICgpIHtcbiAgICAgICAgaWYgKHNlbGYuaXNEaWZmZXJlbnQocHJldmlvdXNWYWx1ZSwgc2VsZi5wZWVrKHRydWUgLyogZXZhbHVhdGUgKi8pKSkge1xuICAgICAgICAgIG5vdGlmeU5leHRDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcmVjb3JkVXBkYXRlICgpIHtcbiAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JzZXJ2YWJsZS5mbiwgc3Vic2NyaWJhYmxlLmZuKTtcblxuICB2YXIgcHJvdG9Qcm9wZXJ0eSA9IG9ic2VydmFibGUucHJvdG9Qcm9wZXJ0eSA9IG9wdGlvbnMucHJvdG9Qcm9wZXJ0eTtcbiAgb2JzZXJ2YWJsZS5mbltwcm90b1Byb3BlcnR5XSA9IG9ic2VydmFibGU7XG5cbiAgLy8gU3ViY2xhc3NlcyBjYW4gYWRkIHRoZW1zZWx2ZXMgdG8gb2JzZXJ2YWJsZVByb3BlcnRpZXMgc28gdGhhdFxuICAvLyBpc09ic2VydmFibGUgd2lsbCBiZSBgdHJ1ZWAuXG4gIG9ic2VydmFibGUub2JzZXJ2YWJsZVByb3RvdHlwZXMgPSBuZXcgU2V0KFtvYnNlcnZhYmxlXSk7XG5cbiAgZnVuY3Rpb24gaXNPYnNlcnZhYmxlIChpbnN0YW5jZSkge1xuICAgIGNvbnN0IHByb3RvID0gdHlwZW9mIGluc3RhbmNlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlW3Byb3RvUHJvcGVydHldO1xuICAgIGlmIChwcm90byAmJiAhb2JzZXJ2YWJsZS5vYnNlcnZhYmxlUHJvdG90eXBlcy5oYXMocHJvdG8pKSB7XG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBvYmplY3QgdGhhdCBsb29rcyBsaWtlIGFuIG9ic2VydmFibGU7IHBvc3NpYmx5IGZyb20gYW5vdGhlciBLbm9ja291dCBpbnN0YW5jZScpXG4gICAgfVxuICAgIHJldHVybiAhIXByb3RvXG4gIH1cblxuICBmdW5jdGlvbiB1bndyYXAgKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JzZXJ2YWJsZSh2YWx1ZSkgPyB2YWx1ZSgpIDogdmFsdWVcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZWsgKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JzZXJ2YWJsZSh2YWx1ZSkgPyB2YWx1ZS5wZWVrKCkgOiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gaXNXcml0ZWFibGVPYnNlcnZhYmxlIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpc09ic2VydmFibGUoaW5zdGFuY2UpICYmIGluc3RhbmNlLmlzV3JpdGVhYmxlXG4gIH1cblxuICAvL1xuXG4gIHZhciBhcnJheUNoYW5nZUV2ZW50TmFtZSA9ICdhcnJheUNoYW5nZSc7XG5cbiAgZnVuY3Rpb24gdHJhY2tBcnJheUNoYW5nZXMgKHRhcmdldCwgb3B0aW9ucyQkMSkge1xuICAgICAgLy8gVXNlIHRoZSBwcm92aWRlZCBvcHRpb25zLS1lYWNoIGNhbGwgdG8gdHJhY2tBcnJheUNoYW5nZXMgb3ZlcndyaXRlcyB0aGUgcHJldmlvdXNseSBzZXQgb3B0aW9uc1xuICAgIHRhcmdldC5jb21wYXJlQXJyYXlPcHRpb25zID0ge307XG4gICAgaWYgKG9wdGlvbnMkJDEgJiYgdHlwZW9mIG9wdGlvbnMkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgICBleHRlbmQodGFyZ2V0LmNvbXBhcmVBcnJheU9wdGlvbnMsIG9wdGlvbnMkJDEpO1xuICAgIH1cbiAgICB0YXJnZXQuY29tcGFyZUFycmF5T3B0aW9ucy5zcGFyc2UgPSB0cnVlO1xuXG4gICAgICAvLyBPbmx5IG1vZGlmeSB0aGUgdGFyZ2V0IG9ic2VydmFibGUgb25jZVxuICAgIGlmICh0YXJnZXQuY2FjaGVEaWZmRm9yS25vd25PcGVyYXRpb24pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBsZXQgdHJhY2tpbmdDaGFuZ2VzID0gZmFsc2U7XG4gICAgbGV0IGNhY2hlZERpZmYgPSBudWxsO1xuICAgIGxldCBhcnJheUNoYW5nZVN1YnNjcmlwdGlvbjtcbiAgICBsZXQgcGVuZGluZ05vdGlmaWNhdGlvbnMgPSAwO1xuICAgIGxldCB1bmRlcmx5aW5nTm90aWZ5U3Vic2NyaWJlcnNGdW5jdGlvbjtcbiAgICBsZXQgdW5kZXJseWluZ0JlZm9yZVN1YnNjcmlwdGlvbkFkZEZ1bmN0aW9uID0gdGFyZ2V0LmJlZm9yZVN1YnNjcmlwdGlvbkFkZDtcbiAgICBsZXQgdW5kZXJseWluZ0FmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlRnVuY3Rpb24gPSB0YXJnZXQuYWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmU7XG5cbiAgICAgIC8vIFdhdGNoIFwic3Vic2NyaWJlXCIgY2FsbHMsIGFuZCBmb3IgYXJyYXkgY2hhbmdlIGV2ZW50cywgZW5zdXJlIGNoYW5nZSB0cmFja2luZyBpcyBlbmFibGVkXG4gICAgdGFyZ2V0LmJlZm9yZVN1YnNjcmlwdGlvbkFkZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKHVuZGVybHlpbmdCZWZvcmVTdWJzY3JpcHRpb25BZGRGdW5jdGlvbikge1xuICAgICAgICB1bmRlcmx5aW5nQmVmb3JlU3Vic2NyaXB0aW9uQWRkRnVuY3Rpb24uY2FsbCh0YXJnZXQsIGV2ZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudCA9PT0gYXJyYXlDaGFuZ2VFdmVudE5hbWUpIHtcbiAgICAgICAgdHJhY2tDaGFuZ2VzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgICAgLy8gV2F0Y2ggXCJkaXNwb3NlXCIgY2FsbHMsIGFuZCBmb3IgYXJyYXkgY2hhbmdlIGV2ZW50cywgZW5zdXJlIGNoYW5nZSB0cmFja2luZyBpcyBkaXNhYmxlZCB3aGVuIGFsbCBhcmUgZGlzcG9zZWRcbiAgICB0YXJnZXQuYWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICh1bmRlcmx5aW5nQWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmVGdW5jdGlvbikge1xuICAgICAgICB1bmRlcmx5aW5nQWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmVGdW5jdGlvbi5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50ID09PSBhcnJheUNoYW5nZUV2ZW50TmFtZSAmJiAhdGFyZ2V0Lmhhc1N1YnNjcmlwdGlvbnNGb3JFdmVudChhcnJheUNoYW5nZUV2ZW50TmFtZSkpIHtcbiAgICAgICAgaWYgKHVuZGVybHlpbmdOb3RpZnlTdWJzY3JpYmVyc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgdGFyZ2V0Lm5vdGlmeVN1YnNjcmliZXJzID0gdW5kZXJseWluZ05vdGlmeVN1YnNjcmliZXJzRnVuY3Rpb247XG4gICAgICAgICAgdW5kZXJseWluZ05vdGlmeVN1YnNjcmliZXJzRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5Q2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgYXJyYXlDaGFuZ2VTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5Q2hhbmdlU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdHJhY2tpbmdDaGFuZ2VzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRyYWNrQ2hhbmdlcyAoKSB7XG4gICAgICAgICAgLy8gQ2FsbGluZyAndHJhY2tDaGFuZ2VzJyBtdWx0aXBsZSB0aW1lcyBpcyB0aGUgc2FtZSBhcyBjYWxsaW5nIGl0IG9uY2VcbiAgICAgIGlmICh0cmFja2luZ0NoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRyYWNraW5nQ2hhbmdlcyA9IHRydWU7XG5cbiAgICAgICAgICAvLyBJbnRlcmNlcHQgXCJub3RpZnlTdWJzY3JpYmVyc1wiIHRvIHRyYWNrIGhvdyBtYW55IHRpbWVzIGl0IHdhcyBjYWxsZWQuXG4gICAgICB1bmRlcmx5aW5nTm90aWZ5U3Vic2NyaWJlcnNGdW5jdGlvbiA9IHRhcmdldFsnbm90aWZ5U3Vic2NyaWJlcnMnXTtcbiAgICAgIHRhcmdldC5ub3RpZnlTdWJzY3JpYmVycyA9IGZ1bmN0aW9uICh2YWx1ZVRvTm90aWZ5LCBldmVudCkge1xuICAgICAgICBpZiAoIWV2ZW50IHx8IGV2ZW50ID09PSBkZWZhdWx0RXZlbnQpIHtcbiAgICAgICAgICArK3BlbmRpbmdOb3RpZmljYXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nTm90aWZ5U3Vic2NyaWJlcnNGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9O1xuXG4gICAgICAgICAgLy8gRWFjaCB0aW1lIHRoZSBhcnJheSBjaGFuZ2VzIHZhbHVlLCBjYXB0dXJlIGEgY2xvbmUgc28gdGhhdCBvbiB0aGUgbmV4dFxuICAgICAgICAgIC8vIGNoYW5nZSBpdCdzIHBvc3NpYmxlIHRvIHByb2R1Y2UgYSBkaWZmXG4gICAgICB2YXIgcHJldmlvdXNDb250ZW50cyA9IFtdLmNvbmNhdCh0YXJnZXQucGVlaygpID09PSB1bmRlZmluZWQgPyBbXSA6IHRhcmdldC5wZWVrKCkpO1xuICAgICAgY2FjaGVkRGlmZiA9IG51bGw7XG4gICAgICBhcnJheUNoYW5nZVN1YnNjcmlwdGlvbiA9IHRhcmdldC5zdWJzY3JpYmUoZnVuY3Rpb24gKGN1cnJlbnRDb250ZW50cykge1xuICAgICAgICBsZXQgY2hhbmdlcztcbiAgICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgY29udGVudHMgYW5kIGVuc3VyZSBpdCdzIGFuIGFycmF5XG4gICAgICAgIGN1cnJlbnRDb250ZW50cyA9IFtdLmNvbmNhdChjdXJyZW50Q29udGVudHMgfHwgW10pO1xuXG4gICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGRpZmYgYW5kIGlzc3VlIG5vdGlmaWNhdGlvbnMsIGJ1dCBvbmx5IGlmIHNvbWVvbmUgaXMgbGlzdGVuaW5nXG4gICAgICAgIGlmICh0YXJnZXQuaGFzU3Vic2NyaXB0aW9uc0ZvckV2ZW50KGFycmF5Q2hhbmdlRXZlbnROYW1lKSkge1xuICAgICAgICAgIGNoYW5nZXMgPSBnZXRDaGFuZ2VzKHByZXZpb3VzQ29udGVudHMsIGN1cnJlbnRDb250ZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBFbGltaW5hdGUgcmVmZXJlbmNlcyB0byB0aGUgb2xkLCByZW1vdmVkIGl0ZW1zLCBzbyB0aGV5IGNhbiBiZSBHQ2VkXG4gICAgICAgIHByZXZpb3VzQ29udGVudHMgPSBjdXJyZW50Q29udGVudHM7XG4gICAgICAgIGNhY2hlZERpZmYgPSBudWxsO1xuICAgICAgICBwZW5kaW5nTm90aWZpY2F0aW9ucyA9IDA7XG5cbiAgICAgICAgaWYgKGNoYW5nZXMgJiYgY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0YXJnZXQubm90aWZ5U3Vic2NyaWJlcnMoY2hhbmdlcywgYXJyYXlDaGFuZ2VFdmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDaGFuZ2VzIChwcmV2aW91c0NvbnRlbnRzLCBjdXJyZW50Q29udGVudHMpIHtcbiAgICAgICAgICAvLyBXZSB0cnkgdG8gcmUtdXNlIGNhY2hlZCBkaWZmcy5cbiAgICAgICAgICAvLyBUaGUgc2NlbmFyaW9zIHdoZXJlIHBlbmRpbmdOb3RpZmljYXRpb25zID4gMSBhcmUgd2hlbiB1c2luZyByYXRlLWxpbWl0aW5nIG9yIHRoZSBEZWZlcnJlZCBVcGRhdGVzXG4gICAgICAgICAgLy8gcGx1Z2luLCB3aGljaCB3aXRob3V0IHRoaXMgY2hlY2sgd291bGQgbm90IGJlIGNvbXBhdGlibGUgd2l0aCBhcnJheUNoYW5nZSBub3RpZmljYXRpb25zLiBOb3JtYWxseSxcbiAgICAgICAgICAvLyBub3RpZmljYXRpb25zIGFyZSBpc3N1ZWQgaW1tZWRpYXRlbHkgc28gd2Ugd291bGRuJ3QgYmUgcXVldWVpbmcgdXAgbW9yZSB0aGFuIG9uZS5cbiAgICAgIGlmICghY2FjaGVkRGlmZiB8fCBwZW5kaW5nTm90aWZpY2F0aW9ucyA+IDEpIHtcbiAgICAgICAgY2FjaGVkRGlmZiA9IHRyYWNrQXJyYXlDaGFuZ2VzLmNvbXBhcmVBcnJheXMocHJldmlvdXNDb250ZW50cywgY3VycmVudENvbnRlbnRzLCB0YXJnZXQuY29tcGFyZUFycmF5T3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZWREaWZmXG4gICAgfVxuXG4gICAgdGFyZ2V0LmNhY2hlRGlmZkZvcktub3duT3BlcmF0aW9uID0gZnVuY3Rpb24gKHJhd0FycmF5LCBvcGVyYXRpb25OYW1lLCBhcmdzKSB7XG4gICAgICAgIC8vIE9ubHkgcnVuIGlmIHdlJ3JlIGN1cnJlbnRseSB0cmFja2luZyBjaGFuZ2VzIGZvciB0aGlzIG9ic2VydmFibGUgYXJyYXlcbiAgICAgICAgLy8gYW5kIHRoZXJlIGFyZW4ndCBhbnkgcGVuZGluZyBkZWZlcnJlZCBub3RpZmljYXRpb25zLlxuICAgICAgaWYgKCF0cmFja2luZ0NoYW5nZXMgfHwgcGVuZGluZ05vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgZGlmZiA9IFtdLFxuICAgICAgICBhcnJheUxlbmd0aCA9IHJhd0FycmF5Lmxlbmd0aCxcbiAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSAwO1xuXG4gICAgICBmdW5jdGlvbiBwdXNoRGlmZiAoc3RhdHVzLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGRpZmZbZGlmZi5sZW5ndGhdID0geyAnc3RhdHVzJzogc3RhdHVzLCAndmFsdWUnOiB2YWx1ZSwgJ2luZGV4JzogaW5kZXggfVxuICAgICAgfVxuICAgICAgc3dpdGNoIChvcGVyYXRpb25OYW1lKSB7XG4gICAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICAgIG9mZnNldCA9IGFycmF5TGVuZ3RoO1xuICAgICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJnc0xlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgcHVzaERpZmYoJ2FkZGVkJywgYXJnc1tpbmRleF0sIG9mZnNldCArIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdwb3AnOlxuICAgICAgICAgIG9mZnNldCA9IGFycmF5TGVuZ3RoIC0gMTtcbiAgICAgICAgY2FzZSAnc2hpZnQnOlxuICAgICAgICAgIGlmIChhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgcHVzaERpZmYoJ2RlbGV0ZWQnLCByYXdBcnJheVtvZmZzZXRdLCBvZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgICAgICAgIC8vIE5lZ2F0aXZlIHN0YXJ0IGluZGV4IG1lYW5zICdmcm9tIGVuZCBvZiBhcnJheScuIEFmdGVyIHRoYXQgd2UgY2xhbXAgdG8gWzAuLi5hcnJheUxlbmd0aF0uXG4gICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zcGxpY2VcbiAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IE1hdGgubWluKE1hdGgubWF4KDAsIGFyZ3NbMF0gPCAwID8gYXJyYXlMZW5ndGggKyBhcmdzWzBdIDogYXJnc1swXSksIGFycmF5TGVuZ3RoKSxcbiAgICAgICAgICAgIGVuZERlbGV0ZUluZGV4ID0gYXJnc0xlbmd0aCA9PT0gMSA/IGFycmF5TGVuZ3RoIDogTWF0aC5taW4oc3RhcnRJbmRleCArIChhcmdzWzFdIHx8IDApLCBhcnJheUxlbmd0aCksXG4gICAgICAgICAgICBlbmRBZGRJbmRleCA9IHN0YXJ0SW5kZXggKyBhcmdzTGVuZ3RoIC0gMixcbiAgICAgICAgICAgIGVuZEluZGV4ID0gTWF0aC5tYXgoZW5kRGVsZXRlSW5kZXgsIGVuZEFkZEluZGV4KSxcbiAgICAgICAgICAgIGFkZGl0aW9ucyA9IFtdLCBkZWxldGlvbnMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0SW5kZXgsIGFyZ3NJbmRleCA9IDI7IGluZGV4IDwgZW5kSW5kZXg7ICsraW5kZXgsICsrYXJnc0luZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBlbmREZWxldGVJbmRleCkgeyBkZWxldGlvbnMucHVzaChwdXNoRGlmZignZGVsZXRlZCcsIHJhd0FycmF5W2luZGV4XSwgaW5kZXgpKTsgfVxuICAgICAgICAgICAgaWYgKGluZGV4IDwgZW5kQWRkSW5kZXgpIHsgYWRkaXRpb25zLnB1c2gocHVzaERpZmYoJ2FkZGVkJywgYXJnc1thcmdzSW5kZXhdLCBpbmRleCkpOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmRNb3Zlc0luQXJyYXlDb21wYXJpc29uKGRlbGV0aW9ucywgYWRkaXRpb25zKTtcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjYWNoZWREaWZmID0gZGlmZjtcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3NlIGNvbXBhcmVBcnJheXMgZm9yIHRlc3RpbmcuXG4gIHRyYWNrQXJyYXlDaGFuZ2VzLmNvbXBhcmVBcnJheXMgPSBjb21wYXJlQXJyYXlzO1xuXG4gIC8vIEFkZCB0aGUgdHJhY2tBcnJheUNoYW5nZXMgZXh0ZW5kZXIgc28gd2UgY2FuIHVzZVxuICAvLyBvYnMuZXh0ZW5kKHsgdHJhY2tBcnJheUNoYW5nZXM6IHRydWUgfSlcbiAgZXh0ZW5kZXJzLnRyYWNrQXJyYXlDaGFuZ2VzID0gdHJhY2tBcnJheUNoYW5nZXM7XG5cbiAgLy9cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlQXJyYXkgKGluaXRpYWxWYWx1ZXMpIHtcbiAgICBpbml0aWFsVmFsdWVzID0gaW5pdGlhbFZhbHVlcyB8fCBbXTtcblxuICAgIGlmICh0eXBlb2YgaW5pdGlhbFZhbHVlcyAhPT0gJ29iamVjdCcgfHwgISgnbGVuZ3RoJyBpbiBpbml0aWFsVmFsdWVzKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhcmd1bWVudCBwYXNzZWQgd2hlbiBpbml0aWFsaXppbmcgYW4gb2JzZXJ2YWJsZSBhcnJheSBtdXN0IGJlIGFuIGFycmF5LCBvciBudWxsLCBvciB1bmRlZmluZWQuJykgfVxuXG4gICAgdmFyIHJlc3VsdCA9IG9ic2VydmFibGUoaW5pdGlhbFZhbHVlcyk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHJlc3VsdCwgb2JzZXJ2YWJsZUFycmF5LmZuKTtcbiAgICB0cmFja0FycmF5Q2hhbmdlcyhyZXN1bHQpO1xuICAgICAgICAgIC8vIF49PSByZXN1bHQuZXh0ZW5kKHsgdHJhY2tBcnJheUNoYW5nZXM6IHRydWUgfSlcbiAgICBvdmVyd3JpdGVMZW5ndGhQcm9wZXJ0eUlmU3VwcG9ydGVkKHJlc3VsdCwgeyBnZXQ6ICgpID0+IHJlc3VsdCgpLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBpc09ic2VydmFibGVBcnJheSAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaXNPYnNlcnZhYmxlKGluc3RhbmNlKSAmJiB0eXBlb2YgaW5zdGFuY2UucmVtb3ZlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5wdXNoID09PSAnZnVuY3Rpb24nXG4gIH1cblxuICBvYnNlcnZhYmxlQXJyYXkuZm4gPSB7XG4gICAgcmVtb3ZlICh2YWx1ZU9yUHJlZGljYXRlKSB7XG4gICAgICB2YXIgdW5kZXJseWluZ0FycmF5ID0gdGhpcy5wZWVrKCk7XG4gICAgICB2YXIgcmVtb3ZlZFZhbHVlcyA9IFtdO1xuICAgICAgdmFyIHByZWRpY2F0ZSA9IHR5cGVvZiB2YWx1ZU9yUHJlZGljYXRlID09PSAnZnVuY3Rpb24nICYmICFpc09ic2VydmFibGUodmFsdWVPclByZWRpY2F0ZSkgPyB2YWx1ZU9yUHJlZGljYXRlIDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA9PT0gdmFsdWVPclByZWRpY2F0ZSB9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmRlcmx5aW5nQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdW5kZXJseWluZ0FycmF5W2ldO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChyZW1vdmVkVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVdpbGxNdXRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVuZGVybHlpbmdBcnJheVtpXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQXJyYXkgbW9kaWZpZWQgZHVyaW5nIHJlbW92ZTsgY2Fubm90IHJlbW92ZSBpdGVtXCIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbW92ZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgdW5kZXJseWluZ0FycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmVkVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnZhbHVlSGFzTXV0YXRlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZWRWYWx1ZXNcbiAgICB9LFxuXG4gICAgcmVtb3ZlQWxsIChhcnJheU9mVmFsdWVzKSB7XG4gICAgICAgICAgLy8gSWYgeW91IHBhc3NlZCB6ZXJvIGFyZ3MsIHdlIHJlbW92ZSBldmVyeXRoaW5nXG4gICAgICBpZiAoYXJyYXlPZlZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB1bmRlcmx5aW5nQXJyYXkgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdmFyIGFsbFZhbHVlcyA9IHVuZGVybHlpbmdBcnJheS5zbGljZSgwKTtcbiAgICAgICAgdGhpcy52YWx1ZVdpbGxNdXRhdGUoKTtcbiAgICAgICAgdW5kZXJseWluZ0FycmF5LnNwbGljZSgwLCB1bmRlcmx5aW5nQXJyYXkubGVuZ3RoKTtcbiAgICAgICAgdGhpcy52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGFsbFZhbHVlc1xuICAgICAgfVxuICAgICAgICAgIC8vIElmIHlvdSBwYXNzZWQgYW4gYXJnLCB3ZSBpbnRlcnByZXQgaXQgYXMgYW4gYXJyYXkgb2YgZW50cmllcyB0byByZW1vdmVcbiAgICAgIGlmICghYXJyYXlPZlZhbHVlcykge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzWydyZW1vdmUnXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZihhcnJheU9mVmFsdWVzLCB2YWx1ZSkgPj0gMFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgZGVzdHJveSAodmFsdWVPclByZWRpY2F0ZSkge1xuICAgICAgdmFyIHVuZGVybHlpbmdBcnJheSA9IHRoaXMucGVlaygpO1xuICAgICAgdmFyIHByZWRpY2F0ZSA9IHR5cGVvZiB2YWx1ZU9yUHJlZGljYXRlID09PSAnZnVuY3Rpb24nICYmICFpc09ic2VydmFibGUodmFsdWVPclByZWRpY2F0ZSkgPyB2YWx1ZU9yUHJlZGljYXRlIDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA9PT0gdmFsdWVPclByZWRpY2F0ZSB9O1xuICAgICAgdGhpcy52YWx1ZVdpbGxNdXRhdGUoKTtcbiAgICAgIGZvciAodmFyIGkgPSB1bmRlcmx5aW5nQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdW5kZXJseWluZ0FycmF5W2ldO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlWydfZGVzdHJveSddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICB9LFxuXG4gICAgZGVzdHJveUFsbCAoYXJyYXlPZlZhbHVlcykge1xuICAgICAgICAgIC8vIElmIHlvdSBwYXNzZWQgemVybyBhcmdzLCB3ZSBkZXN0cm95IGV2ZXJ5dGhpbmdcbiAgICAgIGlmIChhcnJheU9mVmFsdWVzID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHRoaXMuZGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH0pIH1cblxuICAgICAgICAgIC8vIElmIHlvdSBwYXNzZWQgYW4gYXJnLCB3ZSBpbnRlcnByZXQgaXQgYXMgYW4gYXJyYXkgb2YgZW50cmllcyB0byBkZXN0cm95XG4gICAgICBpZiAoIWFycmF5T2ZWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5kZXN0cm95KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGFycmF5T2ZWYWx1ZXMsIHZhbHVlKSA+PSAwXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBpbmRleE9mIChpdGVtKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMoKSwgaXRlbSlcbiAgICB9LFxuXG4gICAgcmVwbGFjZSAob2xkSXRlbSwgbmV3SXRlbSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKG9sZEl0ZW0pO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdGhpcy52YWx1ZVdpbGxNdXRhdGUoKTtcbiAgICAgICAgdGhpcy5wZWVrKClbaW5kZXhdID0gbmV3SXRlbTtcbiAgICAgICAgdGhpcy52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc29ydGVkIChjb21wYXJlRm4pIHtcbiAgICAgIHJldHVybiBbLi4udGhpcygpXS5zb3J0KGNvbXBhcmVGbilcbiAgICB9LFxuXG4gICAgcmV2ZXJzZWQgKCkge1xuICAgICAgcmV0dXJuIFsuLi50aGlzKCldLnJldmVyc2UoKVxuICAgIH0sXG5cbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogZnVuY3Rpb24gKiAoKSB7XG4gICAgICB5aWVsZCAqIHRoaXMoKTtcbiAgICB9XG4gIH07XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG9ic2VydmFibGVBcnJheS5mbiwgb2JzZXJ2YWJsZS5mbik7XG5cbiAgLy8gUG9wdWxhdGUga28ub2JzZXJ2YWJsZUFycmF5LmZuIHdpdGggcmVhZC93cml0ZSBmdW5jdGlvbnMgZnJvbSBuYXRpdmUgYXJyYXlzXG4gIC8vIEltcG9ydGFudDogRG8gbm90IGFkZCBhbnkgYWRkaXRpb25hbCBmdW5jdGlvbnMgaGVyZSB0aGF0IG1heSByZWFzb25hYmx5IGJlIHVzZWQgdG8gKnJlYWQqIGRhdGEgZnJvbSB0aGUgYXJyYXlcbiAgLy8gYmVjYXVzZSB3ZSdsbCBldmFsIHRoZW0gd2l0aG91dCBjYXVzaW5nIHN1YnNjcmlwdGlvbnMsIHNvIGtvLmNvbXB1dGVkIG91dHB1dCBjb3VsZCBlbmQgdXAgZ2V0dGluZyBzdGFsZVxuICBhcnJheUZvckVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICBvYnNlcnZhYmxlQXJyYXkuZm5bbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gVXNlIFwicGVla1wiIHRvIGF2b2lkIGNyZWF0aW5nIGEgc3Vic2NyaXB0aW9uIGluIGFueSBjb21wdXRlZCB0aGF0IHdlJ3JlIGV4ZWN1dGluZyBpbiB0aGUgY29udGV4dCBvZlxuICAgICAgICAgIC8vIChmb3IgY29uc2lzdGVuY3kgd2l0aCBtdXRhdGluZyByZWd1bGFyIG9ic2VydmFibGVzKVxuICAgICAgdmFyIHVuZGVybHlpbmdBcnJheSA9IHRoaXMucGVlaygpO1xuICAgICAgdGhpcy52YWx1ZVdpbGxNdXRhdGUoKTtcbiAgICAgIHRoaXMuY2FjaGVEaWZmRm9yS25vd25PcGVyYXRpb24odW5kZXJseWluZ0FycmF5LCBtZXRob2ROYW1lLCBhcmd1bWVudHMpO1xuICAgICAgdmFyIG1ldGhvZENhbGxSZXN1bHQgPSB1bmRlcmx5aW5nQXJyYXlbbWV0aG9kTmFtZV0uYXBwbHkodW5kZXJseWluZ0FycmF5LCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgICAgICAvLyBUaGUgbmF0aXZlIHNvcnQgYW5kIHJldmVyc2UgbWV0aG9kcyByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGFycmF5LCBidXQgaXQgbWFrZXMgbW9yZSBzZW5zZSB0byByZXR1cm4gdGhlIG9ic2VydmFibGUgYXJyYXkgaW5zdGVhZC5cbiAgICAgIHJldHVybiBtZXRob2RDYWxsUmVzdWx0ID09PSB1bmRlcmx5aW5nQXJyYXkgPyB0aGlzIDogbWV0aG9kQ2FsbFJlc3VsdFxuICAgIH07XG4gIH0pO1xuXG4gIC8vIFBvcHVsYXRlIGtvLm9ic2VydmFibGVBcnJheS5mbiB3aXRoIHJlYWQtb25seSBmdW5jdGlvbnMgZnJvbSBuYXRpdmUgYXJyYXlzXG4gIGFycmF5Rm9yRWFjaChbJ3NsaWNlJ10sIGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgb2JzZXJ2YWJsZUFycmF5LmZuW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHVuZGVybHlpbmdBcnJheSA9IHRoaXMoKTtcbiAgICAgIHJldHVybiB1bmRlcmx5aW5nQXJyYXlbbWV0aG9kTmFtZV0uYXBwbHkodW5kZXJseWluZ0FycmF5LCBhcmd1bWVudHMpXG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRXhwb3NlIGZvciB0ZXN0aW5nLlxuICBvYnNlcnZhYmxlQXJyYXkudHJhY2tBcnJheUNoYW5nZXMgPSB0cmFja0FycmF5Q2hhbmdlcztcblxuICAvL1xuXG4gIHZhciBtYXhOZXN0ZWRPYnNlcnZhYmxlRGVwdGggPSAxMDsgLy8gRXNjYXBlIHRoZSAodW5saWtlbHkpIHBhdGhvbG9naWNhbCBjYXNlIHdoZXJlIGFuIG9ic2VydmFibGUncyBjdXJyZW50IHZhbHVlIGlzIGl0c2VsZiAob3Igc2ltaWxhciByZWZlcmVuY2UgY3ljbGUpXG5cbiAgZnVuY3Rpb24gdG9KUyAocm9vdE9iamVjdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGNhbGxpbmcga28udG9KUywgcGFzcyB0aGUgb2JqZWN0IHlvdSB3YW50IHRvIGNvbnZlcnQuJykgfVxuXG4gICAgICAvLyBXZSBqdXN0IHVud3JhcCBldmVyeXRoaW5nIGF0IGV2ZXJ5IGxldmVsIGluIHRoZSBvYmplY3QgZ3JhcGhcbiAgICByZXR1cm4gbWFwSnNPYmplY3RHcmFwaChyb290T2JqZWN0LCBmdW5jdGlvbiAodmFsdWVUb01hcCkge1xuICAgICAgICAgIC8vIExvb3AgYmVjYXVzZSBhbiBvYnNlcnZhYmxlJ3MgdmFsdWUgbWlnaHQgaW4gdHVybiBiZSBhbm90aGVyIG9ic2VydmFibGUgd3JhcHBlclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGlzT2JzZXJ2YWJsZSh2YWx1ZVRvTWFwKSAmJiAoaSA8IG1heE5lc3RlZE9ic2VydmFibGVEZXB0aCk7IGkrKykgeyB2YWx1ZVRvTWFwID0gdmFsdWVUb01hcCgpOyB9XG4gICAgICByZXR1cm4gdmFsdWVUb01hcFxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiB0b0pTT04gKHJvb3RPYmplY3QsIHJlcGxhY2VyLCBzcGFjZSkgeyAgICAgLy8gcmVwbGFjZXIgYW5kIHNwYWNlIGFyZSBvcHRpb25hbFxuICAgIHZhciBwbGFpbkphdmFTY3JpcHRPYmplY3QgPSB0b0pTKHJvb3RPYmplY3QpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwbGFpbkphdmFTY3JpcHRPYmplY3QsIHJlcGxhY2VyLCBzcGFjZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcEpzT2JqZWN0R3JhcGggKHJvb3RPYmplY3QsIG1hcElucHV0Q2FsbGJhY2ssIHZpc2l0ZWRPYmplY3RzKSB7XG4gICAgdmlzaXRlZE9iamVjdHMgPSB2aXNpdGVkT2JqZWN0cyB8fCBuZXcgb2JqZWN0TG9va3VwKCk7XG5cbiAgICByb290T2JqZWN0ID0gbWFwSW5wdXRDYWxsYmFjayhyb290T2JqZWN0KTtcbiAgICB2YXIgY2FuSGF2ZVByb3BlcnRpZXMgPSAodHlwZW9mIHJvb3RPYmplY3QgPT09ICdvYmplY3QnKSAmJiAocm9vdE9iamVjdCAhPT0gbnVsbCkgJiYgKHJvb3RPYmplY3QgIT09IHVuZGVmaW5lZCkgJiYgKCEocm9vdE9iamVjdCBpbnN0YW5jZW9mIFJlZ0V4cCkpICYmICghKHJvb3RPYmplY3QgaW5zdGFuY2VvZiBEYXRlKSkgJiYgKCEocm9vdE9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykpICYmICghKHJvb3RPYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpKSAmJiAoIShyb290T2JqZWN0IGluc3RhbmNlb2YgQm9vbGVhbikpO1xuICAgIGlmICghY2FuSGF2ZVByb3BlcnRpZXMpIHsgcmV0dXJuIHJvb3RPYmplY3QgfVxuXG4gICAgdmFyIG91dHB1dFByb3BlcnRpZXMgPSByb290T2JqZWN0IGluc3RhbmNlb2YgQXJyYXkgPyBbXSA6IHt9O1xuICAgIHZpc2l0ZWRPYmplY3RzLnNhdmUocm9vdE9iamVjdCwgb3V0cHV0UHJvcGVydGllcyk7XG5cbiAgICB2aXNpdFByb3BlcnRpZXNPckFycmF5RW50cmllcyhyb290T2JqZWN0LCBmdW5jdGlvbiAoaW5kZXhlcikge1xuICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBtYXBJbnB1dENhbGxiYWNrKHJvb3RPYmplY3RbaW5kZXhlcl0pO1xuXG4gICAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgb3V0cHV0UHJvcGVydGllc1tpbmRleGVyXSA9IHByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICB2YXIgcHJldmlvdXNseU1hcHBlZFZhbHVlID0gdmlzaXRlZE9iamVjdHMuZ2V0KHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgIG91dHB1dFByb3BlcnRpZXNbaW5kZXhlcl0gPSAocHJldmlvdXNseU1hcHBlZFZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICA/IHByZXZpb3VzbHlNYXBwZWRWYWx1ZVxuICAgICAgICAgICAgICAgICAgOiBtYXBKc09iamVjdEdyYXBoKHByb3BlcnR5VmFsdWUsIG1hcElucHV0Q2FsbGJhY2ssIHZpc2l0ZWRPYmplY3RzKTtcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG91dHB1dFByb3BlcnRpZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2l0UHJvcGVydGllc09yQXJyYXlFbnRyaWVzIChyb290T2JqZWN0LCB2aXNpdG9yQ2FsbGJhY2spIHtcbiAgICBpZiAocm9vdE9iamVjdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3RPYmplY3QubGVuZ3RoOyBpKyspIHsgdmlzaXRvckNhbGxiYWNrKGkpOyB9XG5cbiAgICAgICAgICAvLyBGb3IgYXJyYXlzLCBhbHNvIHJlc3BlY3QgdG9KU09OIHByb3BlcnR5IGZvciBjdXN0b20gbWFwcGluZ3MgKGZpeGVzICMyNzgpXG4gICAgICBpZiAodHlwZW9mIHJvb3RPYmplY3RbJ3RvSlNPTiddID09PSAnZnVuY3Rpb24nKSB7IHZpc2l0b3JDYWxsYmFjaygndG9KU09OJyk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHJvb3RPYmplY3QpIHtcbiAgICAgICAgdmlzaXRvckNhbGxiYWNrKHByb3BlcnR5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb2JqZWN0TG9va3VwICgpIHtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICB9XG5cbiAgb2JqZWN0TG9va3VwLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3Rvcjogb2JqZWN0TG9va3VwLFxuICAgIHNhdmU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZXhpc3RpbmdJbmRleCA9IGFycmF5SW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG4gICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7IHRoaXMudmFsdWVzW2V4aXN0aW5nSW5kZXhdID0gdmFsdWU7IH0gZWxzZSB7XG4gICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHRoaXMudmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgZXhpc3RpbmdJbmRleCA9IGFycmF5SW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG4gICAgICByZXR1cm4gKGV4aXN0aW5nSW5kZXggPj0gMCkgPyB0aGlzLnZhbHVlc1tleGlzdGluZ0luZGV4XSA6IHVuZGVmaW5lZFxuICAgIH1cbiAgfTtcblxuICAvL1xuXG4gIGZ1bmN0aW9uIExBTUJEQSAoKSB7fVxuXG4gIC8qKlxuICAgKiBAIG9wZXJhdG9yIC0gcmVjdXJzaXZlbHkgY2FsbCB0aGUgaWRlbnRpZmllciBpZiBpdCdzIGEgZnVuY3Rpb25cbiAgICogQHBhcmFtICB7b3BlcmFuZH0gYSBpZ25vcmVkXG4gICAqIEBwYXJhbSAge29wZXJhbmR9IGIgVGhlIHZhcmlhYmxlIHRvIGJlIGNhbGxlZCAoaWYgYSBmdW5jdGlvbikgYW5kIHVud3JhcHBlZFxuICAgKiBAcmV0dXJuIHt2YWx1ZX0gICBUaGUgcmVzdWx0LlxuICAgKi9cbiAgZnVuY3Rpb24gdW53cmFwT3JDYWxsIChhLCBiKSB7XG4gICAgd2hpbGUgKHR5cGVvZiBiID09PSAnZnVuY3Rpb24nKSB7IGIgPSBiKCk7IH1cbiAgICByZXR1cm4gYlxuICB9XG5cbiAgY29uc3Qgb3BlcmF0b3JzID0ge1xuICAgIC8vIHVuYXJ5XG4gICAgJ0AnOiB1bndyYXBPckNhbGwsXG4gICAgJyMnOiAoYSwgYikgPT4gKCkgPT4gdW53cmFwKGIpLCAvLyBDb252ZXJ0IHRvIHJlYWQtb25seS5cbiAgICAnPT4nOiBMQU1CREEsXG4gICAgJyEnOiBmdW5jdGlvbiBub3QgKGEsIGIpIHsgcmV0dXJuICFiIH0sXG4gICAgJyEhJzogZnVuY3Rpb24gbm90bm90IChhLCBiKSB7IHJldHVybiAhIWIgfSxcbiAgICAnKysnOiBmdW5jdGlvbiBwcmVpbmMgKGEsIGIpIHsgcmV0dXJuICsrYiB9LFxuICAgICctLSc6IGZ1bmN0aW9uIHByZWluYyAoYSwgYikgeyByZXR1cm4gLS1iIH0sXG4gICAgLy8gbXVsL2RpdlxuICAgICcqJzogZnVuY3Rpb24gbXVsIChhLCBiKSB7IHJldHVybiBhICogYiB9LFxuICAgICcvJzogZnVuY3Rpb24gZGl2IChhLCBiKSB7IHJldHVybiBhIC8gYiB9LFxuICAgICclJzogZnVuY3Rpb24gbW9kIChhLCBiKSB7IHJldHVybiBhICUgYiB9LFxuICAgIC8vIHN1Yi9hZGRcbiAgICAnKyc6IGZ1bmN0aW9uIGFkZCAoYSwgYikgeyByZXR1cm4gYSArIGIgfSxcbiAgICAnLSc6IGZ1bmN0aW9uIHN1YiAoYSwgYikgeyByZXR1cm4gKGEgfHwgMCkgLSAoYiB8fCAwKSB9LFxuICAgICcmLSc6IGZ1bmN0aW9uIG5lZyAoYSwgYikgeyByZXR1cm4gLTEgKiBiIH0sXG4gICAgLy8gcmVsYXRpb25hbFxuICAgICc8JzogZnVuY3Rpb24gbHQgKGEsIGIpIHsgcmV0dXJuIGEgPCBiIH0sXG4gICAgJzw9JzogZnVuY3Rpb24gbGUgKGEsIGIpIHsgcmV0dXJuIGEgPD0gYiB9LFxuICAgICc+JzogZnVuY3Rpb24gZ3QgKGEsIGIpIHsgcmV0dXJuIGEgPiBiIH0sXG4gICAgJz49JzogZnVuY3Rpb24gZ2UgKGEsIGIpIHsgcmV0dXJuIGEgPj0gYiB9LFxuICAgIC8vICAgIFRPRE86ICdpbic6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIGluIGI7IH0sXG4gICAgLy8gICAgVE9ETzogJ2luc3RhbmNlb2YnOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSBpbnN0YW5jZW9mIGI7IH0sXG4gICAgLy8gZXF1YWxpdHlcbiAgICAnPT0nOiBmdW5jdGlvbiBlcXVhbCAoYSwgYikgeyByZXR1cm4gYSA9PT0gYiB9LFxuICAgICchPSc6IGZ1bmN0aW9uIG5lIChhLCBiKSB7IHJldHVybiBhICE9PSBiIH0sXG4gICAgJz09PSc6IGZ1bmN0aW9uIHNlcXVhbCAoYSwgYikgeyByZXR1cm4gYSA9PT0gYiB9LFxuICAgICchPT0nOiBmdW5jdGlvbiBzbmUgKGEsIGIpIHsgcmV0dXJuIGEgIT09IGIgfSxcbiAgICAvLyBiaXR3aXNlXG4gICAgJyYnOiBmdW5jdGlvbiBiaXRBbmQgKGEsIGIpIHsgcmV0dXJuIGEgJiBiIH0sXG4gICAgJ14nOiBmdW5jdGlvbiB4b3IgKGEsIGIpIHsgcmV0dXJuIGEgXiBiIH0sXG4gICAgJ3wnOiBmdW5jdGlvbiBiaXRPciAoYSwgYikgeyByZXR1cm4gYSB8IGIgfSxcbiAgICAvLyBsb2dpY1xuICAgICcmJic6IGZ1bmN0aW9uIGxvZ2ljQW5kIChhLCBiKSB7IHJldHVybiBhICYmIGIgfSxcbiAgICAnfHwnOiBmdW5jdGlvbiBsb2dpY09yIChhLCBiKSB7IHJldHVybiBhIHx8IGIgfSxcbiAgICAvLyBBY2Nlc3NcbiAgICAnLic6IGZ1bmN0aW9uIG1lbWJlciAoYSwgYikgeyByZXR1cm4gYVtiXSB9LFxuICAgICdbJzogZnVuY3Rpb24gbWVtYmVyIChhLCBiKSB7IHJldHVybiBhW2JdIH0sXG4gICAgLy8gY29uZGl0aW9uYWwvdGVybmFyeVxuICAgIC8vICc/JzogdGVybmFyeSBTZWUgTm9kZS5qc1xuICAgIC8vIEZ1bmN0aW9uLUNhbGxcbiAgICAnY2FsbCc6IGZ1bmN0aW9uIGNhbGxPcCAoYSwgYikgeyByZXR1cm4gYS5hcHBseShudWxsLCBiKSB9XG4gIH07XG5cbiAgLyogT3JkZXIgb2YgcHJlY2VkZW5jZSBmcm9tOlxuICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvT3BlcmF0b3JfUHJlY2VkZW5jZSNUYWJsZVxuICAqL1xuXG4gICAgLy8gT3VyIG9wZXJhdG9yIC0gdW53cmFwL2NhbGxcbiAgb3BlcmF0b3JzWydAJ10ucHJlY2VkZW5jZSA9IDIxO1xuICBvcGVyYXRvcnNbJyMnXS5wcmVjZWRlbmNlID0gMjE7XG5cbiAgICAvLyBsYW1iZGFcbiAgb3BlcmF0b3JzWyc9PiddLnByZWNlZGVuY2UgPSAyMDtcblxuICAgIC8vIE1lbWJlclxuICBvcGVyYXRvcnNbJy4nXS5wcmVjZWRlbmNlID0gMTk7XG4gIG9wZXJhdG9yc1snWyddLnByZWNlZGVuY2UgPSAxOTtcblxuICAgIC8vIExvZ2ljYWwgbm90XG4gIG9wZXJhdG9yc1snISddLnByZWNlZGVuY2UgPSAxNjtcbiAgb3BlcmF0b3JzWychISddLnByZWNlZGVuY2UgPSAxNjsgLy8gZXhwbGljaXQgZG91YmxlLW5lZ2F0aXZlXG5cbiAgICAvLyBQcmVmaXggaW5jL2RlY1xuICBvcGVyYXRvcnNbJysrJ10ucHJlY2VkZW5jZSA9IDE2O1xuICBvcGVyYXRvcnNbJy0tJ10ucHJlY2VkZW5jZSA9IDE2O1xuICBvcGVyYXRvcnNbJyYtJ10ucHJlY2VkZW5jZSA9IDE2O1xuXG4gICAgLy8gbXVsL2Rpdi9yZW1haW5kZXJcbiAgb3BlcmF0b3JzWyclJ10ucHJlY2VkZW5jZSA9IDE0O1xuICBvcGVyYXRvcnNbJyonXS5wcmVjZWRlbmNlID0gMTQ7XG4gIG9wZXJhdG9yc1snLyddLnByZWNlZGVuY2UgPSAxNDtcblxuICAgIC8vIGFkZC9zdWJcbiAgb3BlcmF0b3JzWycrJ10ucHJlY2VkZW5jZSA9IDEzO1xuICBvcGVyYXRvcnNbJy0nXS5wcmVjZWRlbmNlID0gMTM7XG5cbiAgICAvLyBiaXR3aXNlXG4gIG9wZXJhdG9yc1snfCddLnByZWNlZGVuY2UgPSAxMjtcbiAgb3BlcmF0b3JzWydeJ10ucHJlY2VkZW5jZSA9IDExO1xuICBvcGVyYXRvcnNbJyYnXS5wcmVjZWRlbmNlID0gMTA7XG5cbiAgICAvLyBjb21wYXJpc29uXG4gIG9wZXJhdG9yc1snPCddLnByZWNlZGVuY2UgPSAxMTtcbiAgb3BlcmF0b3JzWyc8PSddLnByZWNlZGVuY2UgPSAxMTtcbiAgb3BlcmF0b3JzWyc+J10ucHJlY2VkZW5jZSA9IDExO1xuICBvcGVyYXRvcnNbJz49J10ucHJlY2VkZW5jZSA9IDExO1xuXG4gICAgLy8gb3BlcmF0b3JzWydpbiddLnByZWNlZGVuY2UgPSA4O1xuICAgIC8vIG9wZXJhdG9yc1snaW5zdGFuY2VvZiddLnByZWNlZGVuY2UgPSA4O1xuICAgIC8vIGVxdWFsaXR5XG4gIG9wZXJhdG9yc1snPT0nXS5wcmVjZWRlbmNlID0gMTA7XG4gIG9wZXJhdG9yc1snIT0nXS5wcmVjZWRlbmNlID0gMTA7XG4gIG9wZXJhdG9yc1snPT09J10ucHJlY2VkZW5jZSA9IDEwO1xuICBvcGVyYXRvcnNbJyE9PSddLnByZWNlZGVuY2UgPSAxMDtcblxuICAgIC8vIGxvZ2ljXG4gIG9wZXJhdG9yc1snJiYnXS5wcmVjZWRlbmNlID0gNjtcbiAgb3BlcmF0b3JzWyd8fCddLnByZWNlZGVuY2UgPSA1O1xuXG4gIG9wZXJhdG9yc1snJiYnXS5lYXJseU91dCA9IChhKSA9PiAhYTtcbiAgb3BlcmF0b3JzWyd8fCddLmVhcmx5T3V0ID0gKGEpID0+IGE7XG5cbiAgICAvLyBDYWxsIGEgZnVuY3Rpb25cbiAgb3BlcmF0b3JzWydjYWxsJ10ucHJlY2VkZW5jZSA9IDE7XG5cbiAgY29uc3QgSVNfRVhQUl9PUl9JREVOVCA9IFN5bWJvbCgnTm9kZSAtIElzIEV4cHJlc3Npb24gT3IgSWRlbnRpZmllcicpO1xuXG4gIGNsYXNzIE5vZGUkMSB7XG4gICAgY29uc3RydWN0b3IgKGxocywgb3AsIHJocykge1xuICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgICB0aGlzLm9wID0gb3A7XG4gICAgICB0aGlzLnJocyA9IHJocztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9wZXJhdG9ycyAoKSB7IHJldHVybiBvcGVyYXRvcnMgfVxuXG4gICAgZ2V0X2xlYWZfdmFsdWUgKGxlYWYsIGNvbnRleHQsIGdsb2JhbHMsIG5vZGUpIHtcbiAgICAgIGlmICh0eXBlb2YgbGVhZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFeHByZXNzaW9ucyBvbiBvYnNlcnZhYmxlcyBhcmUgbm9uc2Vuc2ljYWwsIHNvIHdlIHVud3JhcCBhbnlcbiAgICAgICAgLy8gZnVuY3Rpb24gdmFsdWVzIChlLmcuIGlkZW50aWZpZXJzKS5cbiAgICAgICAgcmV0dXJuIHVud3JhcChsZWFmKCkpXG4gICAgICB9XG5cbiAgICAgIC8vIHByaW1pdGl2ZXNcbiAgICAgIGlmICh0eXBlb2YgbGVhZiAhPT0gJ29iamVjdCcgfHwgbGVhZiA9PT0gbnVsbCkgeyByZXR1cm4gbGVhZiB9XG5cbiAgICAgIC8vIElkZW50aWZpZXJzIGFuZCBFeHByZXNzaW9uc1xuICAgICAgaWYgKGxlYWZbTm9kZSQxLmlzRXhwcmVzc2lvbk9ySWRlbnRpZmllclN5bWJvbF0pIHtcbiAgICAgICAgLy8gbGhzIGlzIHBhc3NlZCBpbiBhcyB0aGUgcGFyZW50IG9mIHRoZSBsZWFmLiBJdCB3aWxsIGJlIGRlZmluZWQgaW5cbiAgICAgICAgLy8gY2FzZXMgbGlrZSBhLmIuYyBhcyAnYScgZm9yICdiJyB0aGVuIGFzICdiJyBmb3IgJ2MnLlxuICAgICAgICByZXR1cm4gdW53cmFwKGxlYWYuZ2V0X3ZhbHVlKHVuZGVmaW5lZCwgY29udGV4dCwgZ2xvYmFscywgbm9kZSkpXG4gICAgICB9XG5cbiAgICAgIC8vIFBsYWluIG9iamVjdC9jbGFzcy5cbiAgICAgIHJldHVybiBsZWFmXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYWxjdWxhdGVzIGFuZCByZXR1cm5zIGFuIGV4cHJlc3Npb24ncyB2YWx1ZVxuICAgICAqIHdoZW4gY2FsbGVkLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBvcHMgIFRoZSBvcGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gICBUaGUgZnVuY3Rpb24gdGhhdCBjYWxjdWxhdGVzIHRoZSBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGZvciBhIGxhbWJkYSwgd2UgZG8gbm90IGV2YWx1YXRlIHRoZSBSSFMgZXhwcmVzc2lvbiB1bnRpbFxuICAgICAqIHRoZSBsYW1iZGEgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIGdldF92YWx1ZSAobm90dXNlZCwgY29udGV4dCwgZ2xvYmFscywgbm9kZSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzO1xuXG4gICAgICBpZiAobm9kZS5vcCA9PT0gTEFNQkRBKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBub2RlLmdldF9sZWFmX3ZhbHVlKG5vZGUucmhzLCBjb250ZXh0LCBnbG9iYWxzLCBub2RlKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBsaHYgPSBub2RlLmdldF9sZWFmX3ZhbHVlKG5vZGUubGhzLCBjb250ZXh0LCBnbG9iYWxzLCBub2RlKTtcbiAgICAgIGNvbnN0IGVhcmx5T3V0ID0gbm9kZS5vcC5lYXJseU91dDtcblxuICAgICAgaWYgKGVhcmx5T3V0ICYmIGVhcmx5T3V0KGxodikpIHsgcmV0dXJuIGxodiB9XG4gICAgICBjb25zdCByaHYgPSBub2RlLmdldF9sZWFmX3ZhbHVlKG5vZGUucmhzLCBjb250ZXh0LCBnbG9iYWxzLCBub2RlKTtcblxuICAgICAgcmV0dXJuIG5vZGUub3AobGh2LCByaHYsIGNvbnRleHQsIGdsb2JhbHMpXG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBDbGFzcyB2YXJpYWJsZXMuXG4gICAgLy9cbiAgICBzdGF0aWMgZ2V0IGlzRXhwcmVzc2lvbk9ySWRlbnRpZmllclN5bWJvbCAoKSB7IHJldHVybiBJU19FWFBSX09SX0lERU5UIH1cbiAgICBnZXQgW0lTX0VYUFJfT1JfSURFTlRdICgpIHsgcmV0dXJuIHRydWUgfVxuXG4gICAgc3RhdGljIHZhbHVlX29mIChpdGVtLCBjb250ZXh0LCBnbG9iYWxzLCBub2RlKSB7XG4gICAgICBpZiAoaXRlbSAmJiBpdGVtW05vZGUkMS5pc0V4cHJlc3Npb25PcklkZW50aWZpZXJTeW1ib2xdKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmdldF92YWx1ZShpdGVtLCBjb250ZXh0LCBnbG9iYWxzLCBub2RlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqICBDb252ZXJ0IGFuIGFycmF5IG9mIG5vZGVzIHRvIGFuIGV4ZWN1dGFibGUgdHJlZS5cbiAgICAqICBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgYGxoc2AsIGByaHNgIGFuZCBgb3BgIGtleSwgY29ycmVzcG9uZGluZ1xuICAgICogICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIGxlZnQgaGFuZCBzaWRlLCByaWdodCBoYW5kIHNpZGUsIGFuZFxuICAgICogICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZV9yb290IChub2Rlcykge1xuICAgICAgdmFyIHJvb3QsIGxlYWYsIG9wLCB2YWx1ZTtcblxuICAgICAgLy8gUHJpbWUgdGhlIGxlYWYgPSByb290IG5vZGUuXG4gICAgICBsZWFmID0gcm9vdCA9IG5ldyBOb2RlJDEobm9kZXMuc2hpZnQoKSwgbm9kZXMuc2hpZnQoKSwgbm9kZXMuc2hpZnQoKSk7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIG9wID0gbm9kZXMuc2hpZnQoKTtcbiAgICAgICAgdmFsdWUgPSBub2Rlcy5zaGlmdCgpO1xuICAgICAgICBpZiAoIW9wKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3AucHJlY2VkZW5jZSA8IHJvb3Qub3AucHJlY2VkZW5jZSkge1xuICAgICAgICAgIC8vIHJlYmFzZVxuICAgICAgICAgIHJvb3QgPSBuZXcgTm9kZSQxKHJvb3QsIG9wLCB2YWx1ZSk7XG4gICAgICAgICAgbGVhZiA9IHJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVhZi5yaHMgPSBuZXcgTm9kZSQxKGxlYWYucmhzLCBvcCwgdmFsdWUpO1xuICAgICAgICAgIGxlYWYgPSBsZWFmLnJocztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coJ3RyZWUnLCByb290KVxuICAgICAgcmV0dXJuIHJvb3RcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQmVjYXVzZSBvZiBjeWNsaWNhbCBkZXBlbmRlbmNpZXMgb24gb3BlcmF0b3JzIDwtPiBOb2RlIDwtPiB2YWx1ZV9vZixcbiAgICogd2UgbmVlZCB0byBwYXRjaCB0aGlzIGluIGhlcmUuXG4gICAqL1xuICBvcGVyYXRvcnNbJz8nXSA9IGZ1bmN0aW9uIHRlcm5hcnkgKGEsIGIsIGNvbnRleHQsIGdsb2JhbHMsIG5vZGUpIHtcbiAgICByZXR1cm4gTm9kZSQxLnZhbHVlX29mKGEgPyBiLnllcyA6IGIubm8sIGNvbnRleHQsIGdsb2JhbHMsIG5vZGUpXG4gIH07XG4gIG9wZXJhdG9yc1snPyddLnByZWNlZGVuY2UgPSA0O1xuXG4gIGNsYXNzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yIChub2Rlcykge1xuICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgdGhpcy5yb290ID0gTm9kZSQxLmNyZWF0ZV9yb290KG5vZGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIGB0aGlzYCBFeHByZXNzaW9uIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldF92YWx1ZSAocGFyZW50LCBjb250ZXh0LCBnbG9iYWxzLCBub2RlKSB7XG4gICAgICBpZiAoIXRoaXMucm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSBOb2RlJDEuY3JlYXRlX3Jvb3QodGhpcy5ub2Rlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yb290LmdldF92YWx1ZShwYXJlbnQsIGNvbnRleHQsIGdsb2JhbHMsIG5vZGUpXG4gICAgfVxuICB9XG5cbiAgRXhwcmVzc2lvbi5wcm90b3R5cGVbTm9kZSQxLmlzRXhwcmVzc2lvbk9ySWRlbnRpZmllclN5bWJvbF0gPSB0cnVlO1xuXG4gIGNsYXNzIEFyZ3VtZW50cyB7XG4gICAgY29uc3RydWN0b3IgKHBhcnNlciwgYXJncykge1xuICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cblxuICAgIGdldF92YWx1ZSAocGFyZW50LCBjb250ZXh0LCBnbG9iYWxzLCBub2RlKSB7XG4gICAgICB2YXIgZGVSZWZmZWRBcmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuYXJncy5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgZGVSZWZmZWRBcmdzLnB1c2goTm9kZSQxLnZhbHVlX29mKHRoaXMuYXJnc1tpXSwgY29udGV4dCwgZ2xvYmFscywgbm9kZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlUmVmZmVkQXJnc1xuICAgIH07XG5cbiAgICBnZXQgW05vZGUkMS5pc0V4cHJlc3Npb25PcklkZW50aWZpZXJTeW1ib2xdICgpIHsgcmV0dXJuIHRydWUgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBmb2xsb3dpbmcgcmVndWxhciBleHByZXNzaW9ucyB3ZXJlIGdlbmVyYXRlZCBieVxuICAgKiAgaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vamF2YXNjcmlwdC1pZGVudGlmaWVyLXJlZ2V4XG4gICAqL1xuICB2YXIgSURTdGFydCA9IC9bXFwkQS1aX2EtelxceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10vO1xuXG4gIHZhciBJRENvbnRpbnVlID0gL1tcXCQwLTlBLVpfYS16XFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEI0XFx1MDhFMy1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEFGOVxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNTgtXFx1MEM1QVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENUYtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOUQ5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5QVxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNFxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10vO1xuXG4gIGNsYXNzIElkZW50aWZpZXIge1xuICAgIGNvbnN0cnVjdG9yIChwYXJzZXIsIHRva2VuLCBkZXJlZmVyZW5jZXMpIHtcbiAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgIHRoaXMuZGVyZWZlcmVuY2VzID0gZGVyZWZlcmVuY2VzO1xuICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgYWxsICgpIGFuZCBbXSBmdW5jdGlvbnMgb24gdGhlIGlkZW50aWZpZXIgdG8gdGhlIGxocyB2YWx1ZSBlLmcuXG4gICAgICogYSgpWzNdIGhhcyBkZXJlZiBmdW5jdGlvbnMgdGhhdCBhcmUgZXNzZW50aWFsbHkgdGhpczpcbiAgICAgKiAgICAgW19kZXJlZl9jYWxsLCBfZGVyZWZfdGhpcyB3aGVyZSB0aGlzPTNdXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gdmFsdWUgIFNob3VsZCBiZSBhbiBvYmplY3QuXG4gICAgICogQHJldHVybiB7bWl4ZWR9ICAgICAgICBUaGUgZGVyZWZlcmVuY2VkIHZhbHVlLlxuICAgICAqXG4gICAgICogWzFdIFdlIHdhbnQgdG8gYmluZCBhbnkgZnVuY3Rpb24gdGhhdCBpcyBhIG1ldGhvZCBvZiBhbiBvYmplY3QsIGJ1dCBub3RcbiAgICAgKiAgICAgY29ycnVwdCBhbnkgdmFsdWVzIChlLmcuIGNvbXB1dGVkKClzKS4gICBlLmcuIFJ1bm5pbmcgeC5iaW5kKG9iaikgd2hlcmVcbiAgICAgKiAgICAgd2UncmUgZ2l2ZW4gYGRhdGEtYmluZD0nYmluZGluZzogb2JqLngnYCBhbmQgeCBpcyBhIGNvbXB1dGVkIHdpbGxcbiAgICAgKiAgICAgYnJlYWsgdGhlIGNvbXB1dGVkJ3MgYHRoaXNgIGFuZCBpdCB3aWxsIHN0b3Agd29ya2luZyBhcyBleHBlY3RlZC5cbiAgICAgKlxuICAgICAqICAgICBUaGUgdGVzdCBgIWxhc3RfdmFsdWUuaGFzT3duUHJvcGVydHkobWVtYmVyKWBcbiAgICAgKiAgICAgZGlzdGluZ3Vpc2hlcyBiZXR3ZWVuIGZ1bmN0aW9ucyBvbiB0aGUgcHJvdG90eXBlIGNoYWluIChwcm90b3R5cGFsXG4gICAgICogICAgIG1lbWJlcnMpIGFuZCB2YWx1ZS1tZW1iZXJzIGFkZGVkIGRpcmVjdGx5IHRvIHRoZSBvYmplY3QuICBUaGlzIG1heVxuICAgICAqICAgICBub3QgYmUgdGhlIGNhbm9uaWNhbCB0ZXN0IGZvciB0aGlzIHJlbGF0aW9uc2hpcCwgYnV0IGl0IHN1Y2NlZWRzXG4gICAgICogICAgIGluIHRoZSBrbm93biB0ZXN0IGNhc2VzLlxuICAgICAqXG4gICAgICogICAgIFNlZTogYHRoaXNgIHRlc3RzIG9mIG91ciBkZXJlZmVyZW5jZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBkZXJlZmVyZW5jZSAodmFsdWUsICRjb250ZXh0LCBnbG9iYWxzLCBub2RlKSB7XG4gICAgICBsZXQgbWVtYmVyO1xuICAgICAgbGV0IHJlZnMgPSB0aGlzLmRlcmVmZXJlbmNlcyB8fCBbXTtcbiAgICAgIGNvbnN0ICRkYXRhID0gJGNvbnRleHQuJGRhdGEgfHwge307XG4gICAgICBsZXQgbGFzdFZhbHVlOyAgLy8gYmVjb21lcyBgdGhpc2AgaW4gZnVuY3Rpb24gY2FsbHMgdG8gb2JqZWN0IHByb3BlcnRpZXMuXG4gICAgICBsZXQgaSwgbjtcblxuICAgICAgZm9yIChpID0gMCwgbiA9IHJlZnMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG1lbWJlciA9IE5vZGUkMS52YWx1ZV9vZihyZWZzW2ldLCAkY29udGV4dCwgZ2xvYmFscywgbm9kZSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiByZWZzW2ldIGluc3RhbmNlb2YgQXJndW1lbnRzKSB7XG4gICAgICAgICAgLy8gZm4oYXJncylcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmFwcGx5KGxhc3RWYWx1ZSB8fCAkZGF0YSwgbWVtYmVyKTtcbiAgICAgICAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvYmpbeF0gb3Igb2JqLnggZGVyZWZlcmVuY2UuICBOb3RlIHRoYXQgb2JqIG1heSBiZSBhIGZ1bmN0aW9uLlxuICAgICAgICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlID0gTm9kZSQxLnZhbHVlX29mKHZhbHVlW21lbWJlcl0sICRjb250ZXh0LCBnbG9iYWxzLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBbMV0gU2VlIG5vdGUgYWJvdmUuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIG4gPiAwICYmIGxhc3RWYWx1ZSAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAhaGFzT3duUHJvcGVydHkobGFzdFZhbHVlLCBtZW1iZXIpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5iaW5kKGxhc3RWYWx1ZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgYXMgb25lIHdvdWxkIGdldCBpdCBmcm9tIHRoZSB0b3AtbGV2ZWwgaS5lLlxuICAgICAqICRkYXRhLnRva2VuLyRjb250ZXh0LnRva2VuL2dsb2JhbHMudG9rZW47IHRoaXMgZG9lcyBub3QgcmV0dXJuIGludGVybWVkaWF0ZVxuICAgICAqIHZhbHVlcyBvbiBhIGNoYWluIG9mIG1lbWJlcnMgaS5lLiAkZGF0YS5oZWxsby50aGVyZSAtLSByZXF1ZXN0aW5nIHRoZVxuICAgICAqIElkZW50aWZpZXIoJ3RoZXJlJykudmFsdWUgd2lsbCByZXR1cm4gJGRhdGEvJGNvbnRleHQvZ2xvYmFscy50aGVyZS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBkZXJlZmVyZW5jZSB1c2luZyAoKSBvciBbYXJnXSBtZW1iZXIuXG4gICAgICogQHBhcmFtICB7b2JqZWN0IHwgSWRlbnRpZmllciB8IEV4cHJlc3Npb259IHBhcmVudFxuICAgICAqIEByZXR1cm4ge21peGVkfSAgUmV0dXJuIHRoZSBwcmltaXRpdmUgb3IgYW4gYWNjZXNzb3IuXG4gICAgICovXG4gICAgZ2V0X3ZhbHVlIChwYXJlbnQsIGNvbnRleHQsIGdsb2JhbHMsIG5vZGUpIHtcbiAgICAgIGNvbnN0IGludGVybWVkaWF0ZSA9IHBhcmVudCAmJiAhKHBhcmVudCBpbnN0YW5jZW9mIElkZW50aWZpZXIpXG4gICAgICAgID8gTm9kZSQxLnZhbHVlX29mKHBhcmVudCwgY29udGV4dCwgZ2xvYmFscywgbm9kZSlbdGhpcy50b2tlbl1cbiAgICAgICAgOiBjb250ZXh0Lmxvb2t1cCh0aGlzLnRva2VuLCBnbG9iYWxzLCBub2RlKTtcbiAgICAgIHJldHVybiB0aGlzLmRlcmVmZXJlbmNlKGludGVybWVkaWF0ZSwgY29udGV4dCwgZ2xvYmFscywgbm9kZSlcbiAgICB9XG5cbiAgICBhc3NpZ24gKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICBpZiAoaXNXcml0ZWFibGVPYnNlcnZhYmxlKG9iamVjdFtwcm9wZXJ0eV0pKSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0odmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNPYnNlcnZhYmxlKG9iamVjdFtwcm9wZXJ0eV0pKSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgSWRlbnRpZmllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IG5ld192YWx1ZSBUaGUgdmFsdWUgdGhhdCBJZGVudGlmaWVyIGlzIHRvIGJlIHNldCB0by5cbiAgICAgKi9cbiAgICBzZXRfdmFsdWUgKG5ld192YWx1ZSwgJGNvbnRleHQsIGdsb2JhbHMpIHtcbiAgICAgIGNvbnN0ICRkYXRhID0gJGNvbnRleHQuJGRhdGEgfHwge307XG4gICAgICBjb25zdCByZWZzID0gdGhpcy5kZXJlZmVyZW5jZXMgfHwgW107XG4gICAgICBsZXQgbGVhZiA9IHRoaXMudG9rZW47XG4gICAgICBsZXQgaSwgbiwgcm9vdDtcblxuICAgICAgaWYgKGhhc093blByb3BlcnR5KCRkYXRhLCBsZWFmKSkge1xuICAgICAgICByb290ID0gJGRhdGE7XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KCRjb250ZXh0LCBsZWFmKSkge1xuICAgICAgICByb290ID0gJGNvbnRleHQ7XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGdsb2JhbHMsIGxlYWYpKSB7XG4gICAgICAgIHJvb3QgPSBnbG9iYWxzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZGVudGlmaWVyOjpzZXRfdmFsdWUgLS0gJyArXG4gICAgICAgICAgXCJUaGUgcHJvcGVydHkgJ1wiICsgbGVhZiArIFwiJyBkb2VzIG5vdCBleGlzdCBcIiArXG4gICAgICAgICAgJ29uIHRoZSAkZGF0YSwgJGNvbnRleHQsIG9yIGdsb2JhbHMuJylcbiAgICAgIH1cblxuICAgICAgLy8gRGVnZW5lcmF0ZSBjYXNlLiB7JGRhdGF8JGNvbnRleHR8Z2xvYmFsfVtsZWFmXSA9IHNvbWV0aGluZztcbiAgICAgIG4gPSByZWZzLmxlbmd0aDtcbiAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzaWduKHJvb3QsIGxlYWYsIG5ld192YWx1ZSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCBkZXJlZmVyZW5jZSBpcyB7JGRhdGF8JGNvbnRleHR8Z2xvYmFsfVt0b2tlbl0uXG4gICAgICByb290ID0gcm9vdFtsZWFmXTtcblxuICAgICAgLy8gV2UgY2Fubm90IHVzZSB0aGlzLmRlcmVmZXJlbmNlIGJlY2F1c2UgdGhhdCBnaXZlcyB0aGUgbGVhZjsgdG8gZXZva2VcbiAgICAgIC8vIHRoZSBFUzUgc2V0dGVyIHdlIGhhdmUgdG8gY2FsbCBgb2JqW2xlYWZdID0gbmV3X3ZhbHVlYFxuICAgICAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyArK2kpIHtcbiAgICAgICAgbGVhZiA9IHJlZnNbaV07XG4gICAgICAgIGlmIChsZWFmIGluc3RhbmNlb2YgQXJndW1lbnRzKSB7XG4gICAgICAgICAgcm9vdCA9IHJvb3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290ID0gcm9vdFtOb2RlJDEudmFsdWVfb2YobGVhZildO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGluZGljYXRlIHRoYXQgYSBkZXJlZmVyZW5jZSBpcyBhIGZ1bmN0aW9uIHdoZW4gaXQgaXMgYHRydWVgLlxuICAgICAgaWYgKHJlZnNbaV0gPT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIGEgdmFsdWUgdG8gYSBmdW5jdGlvbi4nKVxuICAgICAgfVxuXG4gICAgICAvLyBDYWxsIHRoZSBzZXR0ZXIgZm9yIHRoZSBsZWFmLlxuICAgICAgaWYgKHJlZnNbaV0pIHtcbiAgICAgICAgdGhpcy5hc3NpZ24ocm9vdCwgTm9kZSQxLnZhbHVlX29mKHJlZnNbaV0pLCBuZXdfdmFsdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgYSBjaGFyYWN0ZXIgaXMgYSB2YWxpZCBpdGVtIGluIGFuIGlkZW50aWZpZXIuXG4gICAgICogTm90ZSB0aGF0IHdlIGRvIG5vdCBjaGVjayB3aGV0aGVyIHRoZSBmaXJzdCBpdGVtIGlzIGEgbnVtYmVyLCBub3IgZG8gd2VcbiAgICAgKiBzdXBwb3J0IHVuaWNvZGUgaWRlbnRpZmllcnMgaGVyZS5cbiAgICAgKlxuICAgICAqIEZyb206ICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85MzM3MDQ3XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgY2ggIFRoZSBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZSBpZiB0aGlzIGlzIGEgdmFsaWQgaWRlbnRpZmllclxuICAgICAqL1xuICAgIC8vIGZ1bmN0aW9uIGlzX2lkZW50aWZpZXJfY2hhcihjaCkge1xuICAgIC8vICAgcmV0dXJuIChjaCA+PSAnQScgJiYgY2ggPD0gJ1onKSB8fFxuICAgIC8vICAgICAgICAgIChjaCA+PSAnYScgJiYgY2ggPD0gJ3onKSB8fFxuICAgIC8vICAgICAgICAgIChjaCA+PSAnMCcgJiYgY2ggPD0gOSkgfHxcbiAgICAvLyAgICAgICAgICAgY2ggPT09ICdfJyB8fCBjaCA9PT0gJyQnO1xuICAgIC8vIH1cbiAgICBzdGF0aWMgaXNfdmFsaWRfc3RhcnRfY2hhciAoY2gpIHtcbiAgICAgIHJldHVybiBJRFN0YXJ0LnRlc3QoY2gpXG4gICAgfVxuXG4gICAgc3RhdGljIGlzX3ZhbGlkX2NvbnRpbnVlX2NoYXIgKGNoKSB7XG4gICAgICByZXR1cm4gSURDb250aW51ZS50ZXN0KGNoKVxuICAgIH1cblxuICAgIGdldCBbTm9kZSQxLmlzRXhwcmVzc2lvbk9ySWRlbnRpZmllclN5bWJvbF0gKCkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cblxuICBjbGFzcyBUZXJuYXJ5IHtcbiAgICBjb25zdHJ1Y3RvciAoeWVzLCBubykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7eWVzLCBub30pO1xuICAgIH1cblxuICAgIGdldF92YWx1ZSAoKSB7IHJldHVybiB0aGlzIH1cblxuICAgIGdldCBbTm9kZSQxLmlzRXhwcmVzc2lvbk9ySWRlbnRpZmllclN5bWJvbF0gKCkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cblxuICAvKipcbiAgICogT3JpZ2luYWxseSBiYXNlZCBvbiAocHVibGljIGRvbWFpbik6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanMvYmxvYi9tYXN0ZXIvanNvbl9wYXJzZS5qc1xuICAgKi9cblxuICBjb25zdCBlc2NhcGVlID0ge1xuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXCInOiAnXCInLFxuICAgICdgJzogJ2AnLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICcvJzogJy8nLFxuICAgICckJzogJyQnLFxuICAgIGI6ICdcXGInLFxuICAgIGY6ICdcXGYnLFxuICAgIG46ICdcXG4nLFxuICAgIHI6ICdcXHInLFxuICAgIHQ6ICdcXHQnXG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBQYXJzZXIgaW5zdGFuY2Ugd2l0aCBuZXcgUGFyc2VyKG5vZGUsIGNvbnRleHQpXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgICBUaGUgRE9NIGVsZW1lbnQgZnJvbSB3aGljaCB3ZSBwYXJzZWQgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IFRoZSBLbm9ja291dCBjb250ZXh0LlxuICAgKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFscyBBbiBvYmplY3QgY29udGFpbmluZyBhbnkgZGVzaXJlZCBnbG9iYWxzLlxuICAgKi9cbiAgY2xhc3MgUGFyc2VyIHtcbiAgICB3aGl0ZSAoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmNoO1xuICAgICAgd2hpbGUgKGNoICYmIGNoIDw9ICcgJykge1xuICAgICAgICBjaCA9IHRoaXMubmV4dCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29tbWVudChjaClcbiAgICB9XG5cbiAgLyoqXG4gICAqIFNsdXJwIGFueSBDIG9yIEMrKyBzdHlsZSBjb21tZW50c1xuICAgKi9cbiAgICBjb21tZW50IChjaCkge1xuICAgICAgaWYgKGNoICE9PSAnLycpIHsgcmV0dXJuIGNoIH1cbiAgICAgIHZhciBwID0gdGhpcy5hdDtcbiAgICAgIHZhciBzZWNvbmQgPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgaWYgKHNlY29uZCA9PT0gJy8nKSB7XG4gICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgIGNoID0gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgaWYgKGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xccicpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGNoID0gdGhpcy5uZXh0KCk7XG4gICAgICB9IGVsc2UgaWYgKHNlY29uZCA9PT0gJyonKSB7XG4gICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgIGNoID0gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgaWYgKGNoID09PSAnKicgJiYgdGhpcy5sb29rYWhlYWQoKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2gpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKCdVbmNsb3NlZCBjb21tZW50LCBzdGFydGluZyBhdCBjaGFyYWN0ZXIgJyArIHApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy53aGl0ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2hcbiAgICB9O1xuXG4gICAgbmV4dCAoYykge1xuICAgICAgaWYgKGMgJiYgYyAhPT0gdGhpcy5jaCkge1xuICAgICAgICB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgYyArIFwiJyBidXQgZ290ICdcIiArIHRoaXMuY2ggKyBcIidcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmNoID0gdGhpcy50ZXh0LmNoYXJBdCh0aGlzLmF0KTtcbiAgICAgIHRoaXMuYXQgKz0gMTtcbiAgICAgIHJldHVybiB0aGlzLmNoXG4gICAgfVxuXG4gICAgbG9va2FoZWFkICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHRbdGhpcy5hdF1cbiAgICB9XG5cbiAgICBlcnJvciAobSkge1xuICAgICAgaWYgKG0gaW5zdGFuY2VvZiBFcnJvcikgeyB0aHJvdyBtIH1cbiAgICAgIGxldCBbbmFtZSwgbXNnXSA9IG0ubmFtZSA/IFttLm5hbWUsIG0ubWVzc2FnZV0gOiBbbSwgJyddO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBcXG4ke25hbWV9ICR7bXNnfSBvZlxuICAgICR7dGhpcy50ZXh0fVxcbmAgKyBBcnJheSh0aGlzLmF0KS5qb2luKCcgJykgKyAnXy8g8J+UpSBcXFxcX1xcbic7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG5cbiAgICBuYW1lICgpIHtcbiAgICAvLyBBIG5hbWUgb2YgYSBiaW5kaW5nXG4gICAgICB2YXIgbmFtZSA9ICcnO1xuICAgICAgdmFyIGVuY2xvc2VkQnk7XG4gICAgICB0aGlzLndoaXRlKCk7XG5cbiAgICAgIHZhciBjaCA9IHRoaXMuY2g7XG5cbiAgICAgIGlmIChjaCA9PT0gXCInXCIgfHwgY2ggPT09ICdcIicpIHtcbiAgICAgICAgZW5jbG9zZWRCeSA9IGNoO1xuICAgICAgICBjaCA9IHRoaXMubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgaWYgKGVuY2xvc2VkQnkgJiYgY2ggPT09IGVuY2xvc2VkQnkpIHtcbiAgICAgICAgICB0aGlzLndoaXRlKCk7XG4gICAgICAgICAgY2ggPSB0aGlzLm5leHQoKTtcbiAgICAgICAgICBpZiAoY2ggIT09ICc6JyAmJiBjaCAhPT0gJywnKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFxuICAgICAgICAgICAgJ09iamVjdCBuYW1lOiAnICsgbmFtZSArICcgbWlzc2luZyBjbG9zaW5nICcgKyBlbmNsb3NlZEJ5XG4gICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5hbWVcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJzonIHx8IGNoIDw9ICcgJyB8fCBjaCA9PT0gJywnIHx8IGNoID09PSAnfCcpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZVxuICAgICAgICB9XG4gICAgICAgIG5hbWUgKz0gY2g7XG4gICAgICAgIGNoID0gdGhpcy5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuXG4gICAgbnVtYmVyICgpIHtcbiAgICAgIGxldCBudW1iZXI7XG4gICAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgICBsZXQgY2ggPSB0aGlzLmNoO1xuXG4gICAgICBpZiAoY2ggPT09ICctJykge1xuICAgICAgICBzdHJpbmcgPSAnLSc7XG4gICAgICAgIGNoID0gdGhpcy5uZXh0KCctJyk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgIGNoID0gdGhpcy5uZXh0KCk7XG4gICAgICB9XG4gICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICBzdHJpbmcgKz0gJy4nO1xuICAgICAgICBjaCA9IHRoaXMubmV4dCgpO1xuICAgICAgICB3aGlsZSAoY2ggJiYgY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICBjaCA9IHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgY2ggPSB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICBjaCA9IHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgIGNoID0gdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgb3B0aW9ucy5vbkVycm9yKG5ldyBFcnJvcignQmFkIG51bWJlcjogJyArIG51bWJlciArICcgaW4gJyArIHN0cmluZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bWJlclxuICAgICAgfVxuICAgIH1cblxuICAvKipcbiAgICogQWRkIGEgcHJvcGVydHkgdG8gJ29iamVjdCcgdGhhdCBlcXVhbHMgdGhlIGdpdmVuIHZhbHVlLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGFkZCB0aGUgdmFsdWUgdG8uXG4gICAqIEBwYXJhbSAge1N0cmluZ30ga2V5ICAgIG9iamVjdFtrZXldIGlzIHNldCB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqIEBwYXJhbSAge21peGVkfSAgdmFsdWUgIFRoZSB2YWx1ZSwgbWF5IGJlIGEgcHJpbWl0aXZlIG9yIGEgZnVuY3Rpb24uIElmIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXQgaXMgdW53cmFwcGVkIGFzIGEgcHJvcGVydHkuXG4gICAqL1xuICAgIG9iamVjdEFkZFZhbHVlIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZVtOb2RlJDEuaXNFeHByZXNzaW9uT3JJZGVudGlmaWVyU3ltYm9sXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IE5vZGUkMS52YWx1ZV9vZih2YWx1ZSwgLi4udGhpcy5jdXJyZW50Q29udGV4dEdsb2JhbHMpLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgIGdldDogKCkgPT4gdmFsdWUubWFwKHYgPT4gTm9kZSQxLnZhbHVlX29mKHYsIC4uLnRoaXMuY3VycmVudENvbnRleHRHbG9iYWxzKSksXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBwcmltaXRpdmVzXG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2JqZWN0ICgpIHtcbiAgICAgIGxldCBrZXk7XG4gICAgICBsZXQgb2JqZWN0ID0ge307XG4gICAgICBsZXQgY2ggPSB0aGlzLmNoO1xuXG4gICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICB0aGlzLm5leHQoJ3snKTtcbiAgICAgICAgY2ggPSB0aGlzLndoaXRlKCk7XG4gICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgY2ggPSB0aGlzLm5leHQoJ30nKTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgaWYgKGNoID09PSAnXCInIHx8IGNoID09PSBcIidcIiB8fCBjaCA9PT0gJ2AnKSB7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLnN0cmluZygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLm5hbWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcignRHVwbGljYXRlIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMud2hpdGUoKSA9PT0gJzonKSB7XG4gICAgICAgICAgICBjaCA9IHRoaXMubmV4dCgnOicpO1xuICAgICAgICAgICAgdGhpcy5vYmplY3RBZGRWYWx1ZShvYmplY3QsIGtleSwgdGhpcy5leHByZXNzaW9uKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RLZXlJc1ZhbHVlID0gbmV3IElkZW50aWZpZXIodGhpcywga2V5LCBbXSk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdEFkZFZhbHVlKG9iamVjdCwga2V5LCBvYmplY3RLZXlJc1ZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaCA9IHRoaXMud2hpdGUoKTtcbiAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgY2ggPSB0aGlzLm5leHQoJ30nKTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm5leHQoJywnKTtcbiAgICAgICAgICBjaCA9IHRoaXMud2hpdGUoKTtcbiAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgY2ggPSB0aGlzLm5leHQoJ30nKTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZXJyb3IoJ0JhZCBvYmplY3QnKTtcbiAgICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdXAgdG8gZGVsaW0gYW5kIHJldHVybiB0aGUgc3RyaW5nXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZGVsaW0gVGhlIGRlbGltaXRlciwgZWl0aGVyICcgb3IgXCJcbiAgICogQHJldHVybiB7c3RyaW5nfSAgICAgICBUaGUgc3RyaW5nIHJlYWQuXG4gICAqL1xuICAgIHJlYWRTdHJpbmcgKGRlbGltKSB7XG4gICAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgICBsZXQgbm9kZXMgPSBbJyddO1xuICAgICAgbGV0IHBsdXNPcCA9IG9wZXJhdG9yc1snKyddO1xuICAgICAgbGV0IGhleDtcbiAgICAgIGxldCBpO1xuICAgICAgbGV0IHVmZmZmO1xuICAgICAgbGV0IGludGVycG9sYXRlID0gZGVsaW0gPT09ICdgJztcbiAgICAgIGxldCBjaCA9IHRoaXMubmV4dCgpO1xuXG4gICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgaWYgKGNoID09PSBkZWxpbSkge1xuICAgICAgICAgIGNoID0gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgaWYgKGludGVycG9sYXRlKSB7IG5vZGVzLnB1c2gocGx1c09wKTsgfVxuICAgICAgICAgIG5vZGVzLnB1c2goc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gbm9kZXNcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgIGNoID0gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgIHVmZmZmID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQoY2ggPSB0aGlzLm5leHQoKSwgMTYpO1xuICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGhleCkpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVmZmZmID0gdWZmZmYgKiAxNiArIGhleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVmZmZmKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBlc2NhcGVlW2NoXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUgJiYgY2ggPT09ICckJykge1xuICAgICAgICAgIGNoID0gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgneycpO1xuICAgICAgICAgICAgbm9kZXMucHVzaChwbHVzT3ApO1xuICAgICAgICAgICAgbm9kZXMucHVzaChzdHJpbmcpO1xuICAgICAgICAgICAgbm9kZXMucHVzaChwbHVzT3ApO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh0aGlzLmV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICBzdHJpbmcgPSAnJztcbiAgICAgICAgICAvLyB0aGlzLm5leHQoJ30nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaW5nICs9ICckJyArIGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgIH1cbiAgICAgICAgY2ggPSB0aGlzLm5leHQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lcnJvcignQmFkIHN0cmluZycpO1xuICAgIH1cblxuICAgIHN0cmluZyAoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmNoO1xuICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoJ1wiJykuam9pbignJylcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiJ1wiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoXCInXCIpLmpvaW4oJycpXG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAnYCcpIHtcbiAgICAgICAgcmV0dXJuIE5vZGUkMS5jcmVhdGVfcm9vdCh0aGlzLnJlYWRTdHJpbmcoJ2AnKSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5lcnJvcignQmFkIHN0cmluZycpO1xuICAgIH1cblxuICAgIGFycmF5ICgpIHtcbiAgICAgIGxldCBhcnJheSA9IFtdO1xuICAgICAgbGV0IGNoID0gdGhpcy5jaDtcblxuICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgY2ggPSB0aGlzLm5leHQoJ1snKTtcbiAgICAgICAgdGhpcy53aGl0ZSgpO1xuICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgIGNoID0gdGhpcy5uZXh0KCddJyk7XG4gICAgICAgICAgcmV0dXJuIGFycmF5XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgYXJyYXkucHVzaCh0aGlzLmV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgY2ggPSB0aGlzLndoaXRlKCk7XG4gICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgIGNoID0gdGhpcy5uZXh0KCddJyk7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0KCcsJyk7XG4gICAgICAgICAgY2ggPSB0aGlzLndoaXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZXJyb3IoJ0JhZCBhcnJheScpO1xuICAgIH1cblxuICAgIHZhbHVlICgpIHtcbiAgICAgIHZhciBjaDtcbiAgICAgIHRoaXMud2hpdGUoKTtcbiAgICAgIGNoID0gdGhpcy5jaDtcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAneyc6IHJldHVybiB0aGlzLm9iamVjdCgpXG4gICAgICAgIGNhc2UgJ1snOiByZXR1cm4gdGhpcy5hcnJheSgpXG4gICAgICAgIGNhc2UgJ1wiJzogY2FzZSBcIidcIjogY2FzZSAnYCc6IHJldHVybiB0aGlzLnN0cmluZygpXG4gICAgICAgIGNhc2UgJy0nOiByZXR1cm4gdGhpcy5udW1iZXIoKVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gdGhpcy5udW1iZXIoKSA6IHRoaXMuaWRlbnRpZmllcigpXG4gICAgICB9XG4gICAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gb3BlcmF0b3IuXG4gICAqIEEgYC5wcmVjZWRlbmNlYCB2YWx1ZSBpcyBhZGRlZCB0byB0aGUgZnVuY3Rpb24sIHdpdGggaW5jcmVhc2luZ1xuICAgKiBwcmVjZWRlbmNlIGhhdmluZyBhIGhpZ2hlciBudW1iZXIuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGUgaW5maXggb3BlcmF0aW9uXG4gICAqL1xuICAgIG9wZXJhdG9yIChvcHRzKSB7XG4gICAgICBsZXQgb3AgPSAnJztcbiAgICAgIGxldCBvcEZuO1xuICAgICAgbGV0IGNoID0gdGhpcy53aGl0ZSgpO1xuICAgICAgbGV0IGlzSWRlbnRpZmllckNoYXIgPSBJZGVudGlmaWVyLmlzX3ZhbGlkX3N0YXJ0X2NoYXI7XG5cbiAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCkgfHwgY2ggPD0gJyAnIHx8IGNoID09PSAnJyB8fFxuICAgICAgICAgIGNoID09PSAnXCInIHx8IGNoID09PSBcIidcIiB8fCBjaCA9PT0gJ3snIHx8IGNoID09PSAnKCcgfHxcbiAgICAgICAgICBjaCA9PT0gJ2AnIHx8IGNoID09PSAnKScgfHwgKGNoIDw9ICc5JyAmJiBjaCA+PSAnMCcpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0cy5ub3RfYW5fYXJyYXkgJiYgY2ggPT09ICdbJykge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBvcCArPSBjaDtcbiAgICAgICAgY2ggPSB0aGlzLm5leHQoKTtcblxuICAgICAgLy8gQW4gaW5maXggZm9sbG93ZWQgYnkgdGhlIHByZWZpeCBlLmcuIGEgKyBAYlxuICAgICAgLy8gVE9ETzogb3RoZXIgcHJlZml4IHVuYXJ5IG9wZXJhdG9yc1xuICAgICAgICBpZiAoY2ggPT09ICdAJykge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBpc0lkZW50aWZpZXJDaGFyID0gSWRlbnRpZmllci5pc192YWxpZF9jb250aW51ZV9jaGFyO1xuICAgICAgfVxuXG4gICAgICBpZiAob3AgIT09ICcnKSB7XG4gICAgICAgIGlmIChvcHRzLnByZWZpeCAmJiBvcCA9PT0gJy0nKSB7IG9wID0gJyYtJzsgfVxuICAgICAgICBvcEZuID0gb3BlcmF0b3JzW29wXTtcblxuICAgICAgICBpZiAoIW9wRm4pIHtcbiAgICAgICAgICB0aGlzLmVycm9yKFwiQmFkIG9wZXJhdG9yOiAnXCIgKyBvcCArIFwiJy5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wRm5cbiAgICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlcnNcbiAgICogUmV0dXJucyB3aGF0IHRoZSBOb2RlIGludGVycHJldHMgYXMgYW4gXCJvcGVyYXRvclwiLlxuICAgKiBlLmcuXG4gICAqICAgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogbmFtZSB8IGZpdDoyMCB8IHVwcGVyY2FzZVwiPjwvc3Bhbj5cbiAgICovXG4gICAgZmlsdGVyICgpIHtcbiAgICAgIGxldCBjaCA9IHRoaXMubmV4dCgpO1xuICAgICAgbGV0IGFyZ3MgPSBbXTtcbiAgICAgIGxldCBuZXh0RmlsdGVyID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgfTtcbiAgICAgIGxldCBuYW1lID0gdGhpcy5uYW1lKCk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5maWx0ZXJzW25hbWVdKSB7XG4gICAgICAgIG9wdGlvbnMub25FcnJvcignQ2Fubm90IGZpbmQgZmlsdGVyIGJ5IHRoZSBuYW1lIG9mOiAnICsgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGNoID0gdGhpcy53aGl0ZSgpO1xuXG4gICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgaWYgKGNoID09PSAnOicpIHtcbiAgICAgICAgICBjaCA9IHRoaXMubmV4dCgpO1xuICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLmV4cHJlc3Npb24oJ3wnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICd8Jykge1xuICAgICAgICAgIG5leHRGaWx0ZXIgPSB0aGlzLmZpbHRlcigpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICcsJykgeyBicmVhayB9XG5cbiAgICAgICAgY2ggPSB0aGlzLndoaXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKHZhbHVlLCBpZ25vcmVkLCBjb250ZXh0LCBnbG9iYWxzLCBub2RlKSB7XG4gICAgICAgIHZhciBhcmdWYWx1ZXMgPSBbdmFsdWVdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJncy5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgICBhcmdWYWx1ZXMucHVzaChOb2RlJDEudmFsdWVfb2YoYXJnc1tpXSwgY29udGV4dCwgZ2xvYmFscywgbm9kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHRGaWx0ZXIob3B0aW9ucy5maWx0ZXJzW25hbWVdLmFwcGx5KG51bGwsIGFyZ1ZhbHVlcykpXG4gICAgICB9O1xuXG4gICAgLy8gTG93ZXN0IHByZWNlZGVuY2UuXG4gICAgICBmaWx0ZXIucHJlY2VkZW5jZSA9IDE7XG4gICAgICByZXR1cm4gZmlsdGVyXG4gICAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBleHByZXNzaW9uIOKAkyBidWlsZHMgYW4gb3BlcmF0b3IgdHJlZSwgaW4gc29tZXRoaW5nIGxpa2VcbiAgICogU2h1bnRpbmctWWFyZC5cbiAgICogICBTZWU6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2h1bnRpbmcteWFyZF9hbGdvcml0aG1cbiAgICpcbiAgICogQHJldHVybiB7ZnVuY3Rpb259ICAgQSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZSB2YWx1ZSBvZiB0aGUgZXhwcmVzc2lvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICB3aGVuIGNhbGxlZCBvciBhIHByaW1pdGl2ZS5cbiAgICovXG4gICAgZXhwcmVzc2lvbiAoZmlsdGVyYWJsZSkge1xuICAgICAgbGV0IG9wO1xuICAgICAgbGV0IG5vZGVzID0gW107XG4gICAgICBsZXQgY2ggPSB0aGlzLndoaXRlKCk7XG5cbiAgICAgIHdoaWxlIChjaCkge1xuICAgICAgLy8gdW5hcnkgcHJlZml4IG9wZXJhdG9yc1xuICAgICAgICBvcCA9IHRoaXMub3BlcmF0b3IoeyBwcmVmaXg6IHRydWUgfSk7XG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIG5vZGVzLnB1c2godW5kZWZpbmVkKTsgIC8vIExIUyBUcmVlIG5vZGUuXG4gICAgICAgICAgbm9kZXMucHVzaChvcCk7XG4gICAgICAgICAgY2ggPSB0aGlzLndoaXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICcoJykge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGVzLnB1c2godGhpcy5leHByZXNzaW9uKCkpO1xuICAgICAgICAgIHRoaXMubmV4dCgnKScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVzLnB1c2godGhpcy52YWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjaCA9IHRoaXMud2hpdGUoKTtcblxuICAgICAgICBpZiAoY2ggPT09ICc6JyB8fCBjaCA9PT0gJ30nIHx8IGNoID09PSAnLCcgfHwgY2ggPT09ICddJyB8fFxuICAgICAgICAgIGNoID09PSAnKScgfHwgY2ggPT09ICcnIHx8IGNoID09PSAnYCcgfHwgKGNoID09PSAnfCcgJiYgZmlsdGVyYWJsZSA9PT0gJ3wnKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgLy8gZmlsdGVyc1xuICAgICAgICBpZiAoY2ggPT09ICd8JyAmJiB0aGlzLmxvb2thaGVhZCgpICE9PSAnfCcgJiYgZmlsdGVyYWJsZSkge1xuICAgICAgICAgIG5vZGVzLnB1c2godGhpcy5maWx0ZXIoKSk7XG4gICAgICAgICAgbm9kZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgLy8gaW5maXggb3IgcG9zdGZpeCBvcGVyYXRvcnNcbiAgICAgICAgb3AgPSB0aGlzLm9wZXJhdG9yKHsgbm90X2FuX2FycmF5OiB0cnVlIH0pO1xuXG4gICAgICAgIGlmIChvcCA9PT0gb3BlcmF0b3JzWyc/J10pIHtcbiAgICAgICAgICB0aGlzLnRlcm5hcnkobm9kZXMpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAob3AgPT09IG9wZXJhdG9yc1snLiddKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChvcCk7XG4gICAgICAgICAgbm9kZXMucHVzaCh0aGlzLm1lbWJlcigpKTtcbiAgICAgICAgICBvcCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAob3AgPT09IG9wZXJhdG9yc1snWyddKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChvcCk7XG4gICAgICAgICAgbm9kZXMucHVzaCh0aGlzLmV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgY2ggPSB0aGlzLm5leHQoJ10nKTtcbiAgICAgICAgICBvcCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAob3ApIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKG9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoID0gdGhpcy53aGl0ZSgpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ10nIHx8ICghb3AgJiYgY2ggPT09ICcoJykpIHsgYnJlYWsgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgdmFyIGRlcmVmZXJlbmNlcyA9IHRoaXMuZGVyZWZlcmVuY2VzKCk7XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDEgJiYgIWRlcmVmZXJlbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzWzBdXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gZGVyZWZlcmVuY2VzLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgICB2YXIgZGVyZWYgPSBkZXJlZmVyZW5jZXNbaV07XG4gICAgICAgIGlmIChkZXJlZi5jb25zdHJ1Y3RvciA9PT0gQXJndW1lbnRzKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChvcGVyYXRvcnMuY2FsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZXMucHVzaChvcGVyYXRvcnNbJy4nXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZXMucHVzaChkZXJlZik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbihub2RlcylcbiAgICB9XG5cbiAgICB0ZXJuYXJ5IChub2Rlcykge1xuICAgICAgdmFyIHRlcm5hcnkgPSBuZXcgVGVybmFyeSgpO1xuICAgICAgdGVybmFyeS55ZXMgPSB0aGlzLmV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMubmV4dCgnOicpO1xuICAgICAgdGVybmFyeS5ubyA9IHRoaXMuZXhwcmVzc2lvbigpO1xuICAgICAgbm9kZXMucHVzaChvcGVyYXRvcnNbJz8nXSk7XG4gICAgICBub2Rlcy5wdXNoKHRlcm5hcnkpO1xuICAgIH1cblxuICAvKipcbiAgICogUGFyc2UgdGhlIGFyZ3VtZW50cyB0byBhIGZ1bmN0aW9uLCByZXR1cm5pbmcgYW4gQXJyYXkuXG4gICAqXG4gICAqL1xuICAgIGZ1bmNBcmd1bWVudHMgKCkge1xuICAgICAgbGV0IGFyZ3MgPSBbXTtcbiAgICAgIGxldCBjaCA9IHRoaXMubmV4dCgnKCcpO1xuXG4gICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgY2ggPSB0aGlzLndoaXRlKCk7XG4gICAgICAgIGlmIChjaCA9PT0gJyknKSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCcpJyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBcmd1bWVudHModGhpcywgYXJncylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmdzLnB1c2godGhpcy5leHByZXNzaW9uKCkpO1xuICAgICAgICAgIGNoID0gdGhpcy53aGl0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCAhPT0gJyknKSB7IHRoaXMubmV4dCgnLCcpOyB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXJyb3IoJ0JhZCBhcmd1bWVudHMgdG8gZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsaXRlcmFsIHN0cmluZyByZWZlcmVuY2UgYGFiY2AgaW4gYW4gYHguYWJjYCBleHByZXNzaW9uLlxuICAgKi9cbiAgICBtZW1iZXIgKCkge1xuICAgICAgbGV0IG1lbWJlciA9ICcnO1xuICAgICAgbGV0IGNoID0gdGhpcy53aGl0ZSgpO1xuICAgICAgbGV0IGlzSWRlbnRpZmllckNoYXIgPSBJZGVudGlmaWVyLmlzX3ZhbGlkX3N0YXJ0X2NoYXI7XG5cbiAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllckNoYXIoY2gpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBtZW1iZXIgKz0gY2g7XG4gICAgICAgIGNoID0gdGhpcy5uZXh0KCk7XG4gICAgICAgIGlzSWRlbnRpZmllckNoYXIgPSBJZGVudGlmaWVyLmlzX3ZhbGlkX2NvbnRpbnVlX2NoYXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtYmVyXG4gICAgfVxuXG4gIC8qKlxuICAgKiBBIGRlcmVmZXJlbmNlIGFwcGxpZXMgdG8gYW4gaWRlbnRpZmVyLCBiZWluZyBlaXRoZXIgYSBmdW5jdGlvblxuICAgKiBjYWxsIFwiKClcIiBvciBhIG1lbWJlcnNoaXAgbG9va3VwIHdpdGggc3F1YXJlIGJyYWNrZXRzIFwiW21lbWJlcl1cIi5cbiAgICogQHJldHVybiB7Zm4gb3IgdW5kZWZpbmVkfSAgRGVyZWZlcmVuY2UgZnVuY3Rpb24gdG8gYmUgYXBwbGllZCB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSWRlbnRpZmllclxuICAgKi9cbiAgICBkZXJlZmVyZW5jZSAoKSB7XG4gICAgICBsZXQgbWVtYmVyO1xuICAgICAgbGV0IGNoID0gdGhpcy53aGl0ZSgpO1xuXG4gICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgLy8gYSguLi4pIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jQXJndW1lbnRzKClcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgIC8vIGFbeF0gbWVtYmVyc2hpcFxuICAgICAgICAgIHRoaXMubmV4dCgnWycpO1xuICAgICAgICAgIG1lbWJlciA9IHRoaXMuZXhwcmVzc2lvbigpO1xuICAgICAgICAgIHRoaXMud2hpdGUoKTtcbiAgICAgICAgICB0aGlzLm5leHQoJ10nKTtcblxuICAgICAgICAgIHJldHVybiBtZW1iZXJcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgIC8vIGEueCBtZW1iZXJzaGlwXG4gICAgICAgICAgdGhpcy5uZXh0KCcuJyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVyKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVyZWZlcmVuY2VzICgpIHtcbiAgICAgIGxldCBjaCA9IHRoaXMud2hpdGUoKTtcbiAgICAgIGxldCBkZXJlZmVyZW5jZXMgPSBbXTtcbiAgICAgIGxldCBkZXJlZjtcblxuICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgIGRlcmVmID0gdGhpcy5kZXJlZmVyZW5jZSgpO1xuICAgICAgICBpZiAoZGVyZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlcmVmZXJlbmNlcy5wdXNoKGRlcmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVyZWZlcmVuY2VzXG4gICAgfVxuXG4gICAgaWRlbnRpZmllciAoKSB7XG4gICAgICBsZXQgdG9rZW4gPSAnJztcbiAgICAgIGxldCBpc0lkZW50aWZpZXJDaGFyID0gSWRlbnRpZmllci5pc192YWxpZF9zdGFydF9jaGFyO1xuICAgICAgbGV0IGNoID0gdGhpcy53aGl0ZSgpO1xuXG4gICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJDaGFyKGNoKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gKz0gY2g7XG4gICAgICAgIGNoID0gdGhpcy5uZXh0KCk7XG4gICAgICAgIGlzSWRlbnRpZmllckNoYXIgPSBJZGVudGlmaWVyLmlzX3ZhbGlkX2NvbnRpbnVlX2NoYXI7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ3RydWUnOiByZXR1cm4gdHJ1ZVxuICAgICAgICBjYXNlICdmYWxzZSc6IHJldHVybiBmYWxzZVxuICAgICAgICBjYXNlICdudWxsJzogcmV0dXJuIG51bGxcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzogcmV0dXJuIHZvaWQgMFxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLbm9ja291dDogQW5vbnltb3VzIGZ1bmN0aW9ucyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgYnV0IGA9PmAgbGFtYmRhcyBhcmUuJylcbiAgICAgIC8vIHJldHVybiB0aGlzLmFub255bW91c19mbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBJZGVudGlmaWVyKHRoaXMsIHRva2VuLCB0aGlzLmRlcmVmZXJlbmNlcygpKVxuICAgIH1cblxuICAgIHJlYWRCaW5kaW5ncyAoKSB7XG4gICAgICBsZXQga2V5O1xuICAgICAgbGV0IGJpbmRpbmdzID0ge307XG4gICAgICBsZXQgc2VwO1xuICAgICAgbGV0IGV4cHI7XG4gICAgICBsZXQgY2ggPSB0aGlzLmNoO1xuXG4gICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAga2V5ID0gdGhpcy5uYW1lKCk7XG4gICAgICAgIHNlcCA9IHRoaXMud2hpdGUoKTtcblxuICAgICAgICBpZiAoIXNlcCB8fCBzZXAgPT09ICcsJykge1xuICAgICAgICAgIGlmIChzZXApIHtcbiAgICAgICAgICAgIGNoID0gdGhpcy5uZXh0KCcsJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAvLyBBIFwiYmFyZVwiIGJpbmRpbmcgZS5nLiBcInRleHRcIjsgc3Vic3RpdHV0ZSB2YWx1ZSBvZiAnbnVsbCdcbiAgICAgICAgLy8gc28gaXQgYmVjb21lcyBcInRleHQ6IG51bGxcIi5cbiAgICAgICAgICBiaW5kaW5nc1trZXldID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBOYW1lc3BhY2VkIOKAkyBpLmUuXG4gICAgICAgICAgLy8gICAgYGF0dHIuY3NzOiB4YCBiZWNvbWVzIGBhdHRyOiB7IGNzczogeCB9YFxuICAgICAgICAgIC8vICAgICBeXl4gLSBrZXlcbiAgICAgICAgICAgIGtleSA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgYmluZGluZ3Nba2V5WzBdXSA9IGJpbmRpbmdzW2tleVswXV0gfHwge307XG5cbiAgICAgICAgICAgIGlmIChrZXkubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvcignQmluZGluZyAnICsga2V5ICsgJyBzaG91bGQgaGF2ZSB0d28gcGFydHMgKGEuYikuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJpbmRpbmdzW2tleVswXV0uY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IoJ0JpbmRpbmcgJyArIGtleVswXSArICcuJyArIGtleVsxXSArICcgcGFpcmVkIHdpdGggYSBub24tb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaCA9IHRoaXMubmV4dCgnOicpO1xuICAgICAgICAgICAgdGhpcy5vYmplY3RBZGRWYWx1ZShiaW5kaW5nc1trZXlbMF1dLCBrZXlbMV0sIHRoaXMuZXhwcmVzc2lvbih0cnVlKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoID0gdGhpcy5uZXh0KCc6Jyk7XG4gICAgICAgICAgICBpZiAoYmluZGluZ3Nba2V5XSAmJiB0eXBlb2YgYmluZGluZ3Nba2V5XSA9PT0gJ29iamVjdCcgJiYgYmluZGluZ3Nba2V5XS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBFeHRlbmQgYSBuYW1lc3BhY2VkIGJpbmRpbmdzIGUuZy4gd2UndmUgcHJldmlvdXNseSBzZWVuXG4gICAgICAgICAgICAvLyBvbi54LCBub3cgd2UncmUgc2VlaW5nIG9uOiB7ICdhYmMnIH0uXG4gICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwciAhPT0gJ29iamVjdCcgfHwgZXhwci5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yKCdFeHBlY3RlZCBwbGFpbiBvYmplY3QgZm9yICcgKyBrZXkgKyAnIHZhbHVlLicpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dGVuZChiaW5kaW5nc1trZXldLCBleHByKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmluZGluZ3Nba2V5XSA9IHRoaXMuZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLndoaXRlKCk7XG4gICAgICAgICAgaWYgKHRoaXMuY2gpIHtcbiAgICAgICAgICAgIGNoID0gdGhpcy5uZXh0KCcsJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmluZGluZ3NcbiAgICB9XG5cbiAgICB2YWx1ZUFzQWNjZXNzb3IgKHZhbHVlLCBjb250ZXh0LCBnbG9iYWxzLCBub2RlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7IHJldHVybiAoKSA9PiB2YWx1ZSB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7IHJldHVybiB2YWx1ZSB9XG5cbiAgICAgIGlmICh2YWx1ZVtOb2RlJDEuaXNFeHByZXNzaW9uT3JJZGVudGlmaWVyU3ltYm9sXSkge1xuICAgICAgICByZXR1cm4gKCkgPT4gTm9kZSQxLnZhbHVlX29mKHZhbHVlLCBjb250ZXh0LCBnbG9iYWxzLCBub2RlKVxuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHZhbHVlLm1hcCh2ID0+IE5vZGUkMS52YWx1ZV9vZih2LCBjb250ZXh0LCBnbG9iYWxzLCBub2RlKSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBjbG9uZVBsYWluT2JqZWN0RGVlcCh2YWx1ZSlcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBoYXMgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhY2Nlc3NvcjogJyArIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQ29udmVydCByZXN1bHRbbmFtZV0gZnJvbSBhIHZhbHVlIHRvIGEgZnVuY3Rpb24gKGkuZS4gYHZhbHVlQWNjZXNzb3IoKWApXG4gICAgKiBAcGFyYW0gIHtvYmplY3R9IHJlc3VsdCBbTWFwIG9mIHRvcC1sZXZlbCBuYW1lcyB0byB2YWx1ZXNdXG4gICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICBbTWFwIG9mIHRvcC1sZXZlbCBuYW1lcyB0byBmdW5jdGlvbnNdXG4gICAgKlxuICAgICogQWNjZXNzb3JzIG1heSBiZSBvbmUgb2YgKGJlbG93KSBjb25zdEFjY2Vzc29yLCBpZGVudGlmaWVyQWNjZXNzb3IsXG4gICAgKiBleHByZXNzaW9uQWNjZXNzb3IsIG9yIG5vZGVBY2Nlc3Nvci5cbiAgICAqL1xuICAgIGNvbnZlcnRUb0FjY2Vzc29ycyAocmVzdWx0LCBjb250ZXh0LCBnbG9iYWxzLCBub2RlKSB7XG4gICAgICBvYmplY3RGb3JFYWNoKHJlc3VsdCwgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElkZW50aWZpZXIpIHtcbiAgICAgICAgICAvLyBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0LCB3aXRoIG5vIGFyZ3VtZW50cyByZXR1cm5zXG4gICAgICAgICAgLy8gdGhlIHZhbHVlIG9mIHRoZSBpZGVudGlmaWVyLCBvdGhlcndpc2Ugc2V0cyB0aGVcbiAgICAgICAgICAvLyB2YWx1ZSBvZiB0aGUgaWRlbnRpZmllciB0byB0aGUgZmlyc3QgZ2l2ZW4gYXJndW1lbnQuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgbmFtZSwge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChvcHRpb25hbFZhbHVlLCBvcHRpb25zJCQxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHZhbHVlLmdldF92YWx1ZSh1bmRlZmluZWQsIGNvbnRleHQsIGdsb2JhbHMsIG5vZGUpO1xuICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gY3VycmVudFZhbHVlIH1cbiAgICAgICAgICAgICAgY29uc3QgdW5jaGFuZ2VkID0gb3B0aW9uYWxWYWx1ZSA9PT0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucyQkMSAmJiBvcHRpb25zJCQxLm9ubHlJZkNoYW5nZWQgJiYgdW5jaGFuZ2VkKSB7IHJldHVybiB9XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zZXRfdmFsdWUob3B0aW9uYWxWYWx1ZSwgY29udGV4dCwgZ2xvYmFscylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbbmFtZV0gPSB0aGlzLnZhbHVlQXNBY2Nlc3Nvcih2YWx1ZSwgY29udGV4dCwgZ2xvYmFscywgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIHByZXBhcnNlIChzb3VyY2UgPSAnJykge1xuICAgICAgY29uc3QgcHJlcGFyc2VycyA9IG9wdGlvbnMuYmluZGluZ1N0cmluZ1ByZXBhcnNlcnMgfHwgW107XG4gICAgICByZXR1cm4gcHJlcGFyc2Vycy5yZWR1Y2UoKGFjYywgZm4pID0+IGZuKGFjYyksIHNvdXJjZS50cmltKCkpXG4gICAgfVxuXG4gICAgcnVuUGFyc2UgKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMudGV4dCA9IHRoaXMucHJlcGFyc2Uoc291cmNlKTtcbiAgICAgIHRoaXMuYXQgPSAwO1xuICAgICAgdGhpcy5jaCA9ICcgJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZuKCk7XG4gICAgICAgIHRoaXMud2hpdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuY2gpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKCdTeW50YXggRXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG9wdGlvbnMub25FcnJvcihlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJpbmRpbmdzIGFzIG5hbWU6IGFjY2Vzc29yKClcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHNvdXJjZSBUaGUgYmluZGluZyBzdHJpbmcgdG8gcGFyc2UuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgTWFwIG9mIG5hbWUgdG8gYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgcGFyc2UgKHNvdXJjZSwgY29udGV4dCA9IHt9LCBnbG9iYWxzID0ge30sIG5vZGUpIHtcbiAgICAgIGlmICghc291cmNlKSB7IHJldHVybiAoKSA9PiBudWxsIH1cbiAgICAgIHRoaXMuY3VycmVudENvbnRleHRHbG9iYWxzID0gW2NvbnRleHQsIGdsb2JhbHMsIG5vZGVdO1xuICAgICAgY29uc3QgcGFyc2VGbiA9ICgpID0+IHRoaXMucmVhZEJpbmRpbmdzKCk7XG4gICAgICBjb25zdCBiaW5kaW5nQWNjZXNzb3JzID0gdGhpcy5ydW5QYXJzZShzb3VyY2UsIHBhcnNlRm4pO1xuICAgICAgcmV0dXJuIHRoaXMuY29udmVydFRvQWNjZXNzb3JzKGJpbmRpbmdBY2Nlc3NvcnMsIGNvbnRleHQsIGdsb2JhbHMsIG5vZGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBldmFsdWF0ZXMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgZXhwcmVzc2lvbi5cbiAgICAgKi9cbiAgICBwYXJzZUV4cHJlc3Npb24gKHNvdXJjZSwgY29udGV4dCA9IHt9LCBnbG9iYWxzID0ge30sIG5vZGUpIHtcbiAgICAgIGlmICghc291cmNlKSB7IHJldHVybiAoKSA9PiAnJyB9XG4gICAgICB0aGlzLmN1cnJlbnRDb250ZXh0R2xvYmFscyA9IFtjb250ZXh0LCBnbG9iYWxzLCBub2RlXTtcbiAgICAgIGNvbnN0IHBhcnNlRm4gPSAoKSA9PiB0aGlzLmV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICBjb25zdCBiaW5kaW5nQWNjZXNzb3JzID0gdGhpcy5ydW5QYXJzZShzb3VyY2UsIHBhcnNlRm4pO1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVBc0FjY2Vzc29yKGJpbmRpbmdBY2Nlc3NvcnMsIGNvbnRleHQsIGdsb2JhbHMsIG5vZGUpXG4gICAgfVxuICB9XG5cbiAgLyogZXNsaW50IG5vLWNvbmQtYXNzaWduOiAwICovXG5cbiAgLy8gVGhlIGZvbGxvd2luZyByZWd1bGFyIGV4cHJlc3Npb25zIHdpbGwgYmUgdXNlZCB0byBzcGxpdCBhbiBvYmplY3QtbGl0ZXJhbCBzdHJpbmcgaW50byB0b2tlbnNcblxuICAvLyBUaGVzZSBjaGFyYWN0ZXJzIGhhdmUgc3BlY2lhbCBtZWFuaW5nIHRvIHRoZSBwYXJzZXIgYW5kIG11c3Qgbm90IGFwcGVhciBpbiB0aGUgbWlkZGxlIG9mIGFcbiAgLy8gdG9rZW4sIGV4Y2VwdCBhcyBwYXJ0IG9mIGEgc3RyaW5nLlxuICBjb25zdCBzcGVjaWFscyA9ICcsXCJcXCdge30oKS86W1xcXFxdJztcbiAgY29uc3QgYmluZGluZ1Rva2VuID0gUmVnRXhwKFtcbiAgICAgIC8vIFRoZXNlIG1hdGNoIHN0cmluZ3MsIGVpdGhlciB3aXRoIGRvdWJsZSBxdW90ZXMsIHNpbmdsZSBxdW90ZXMsIG9yIGJhY2t0aWNrc1xuICAgICdcIig/OlxcXFxcXFxcLnxbXlwiXSkqXCInLFxuICAgIFwiJyg/OlxcXFxcXFxcLnxbXiddKSonXCIsXG4gICAgJ2AoPzpcXFxcXFxcXC58W15gXSkqYCcsXG4gICAgICAvLyBNYXRjaCBDIHN0eWxlIGNvbW1lbnRzXG4gICAgJy9cXFxcKig/OlteKl18XFxcXCorW14qL10pKlxcXFwqKy8nLFxuICAgICAgLy8gTWF0Y2ggQysrIHN0eWxlIGNvbW1lbnRzXG4gICAgJy8vLipcXG4nLFxuICAgICAgLy8gTWF0Y2ggYSByZWd1bGFyIGV4cHJlc3Npb24gKHRleHQgZW5jbG9zZWQgYnkgc2xhc2hlcyksIGJ1dCB3aWxsIGFsc28gbWF0Y2ggc2V0cyBvZiBkaXZpc2lvbnNcbiAgICAgIC8vIGFzIGEgcmVndWxhciBleHByZXNzaW9uICh0aGlzIGlzIGhhbmRsZWQgYnkgdGhlIHBhcnNpbmcgbG9vcCBiZWxvdykuXG4gICAgJy8oPzpcXFxcXFxcXC58W14vXSkrL1xcXFx3KicsXG4gICAgICAvLyBNYXRjaCB0ZXh0IChhdCBsZWFzdCB0d28gY2hhcmFjdGVycykgdGhhdCBkb2VzIG5vdCBjb250YWluIGFueSBvZiB0aGUgYWJvdmUgc3BlY2lhbCBjaGFyYWN0ZXJzLFxuICAgICAgLy8gYWx0aG91Z2ggc29tZSBvZiB0aGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBhbGxvd2VkIHRvIHN0YXJ0IGl0IChhbGwgYnV0IHRoZSBjb2xvbiBhbmQgY29tbWEpLlxuICAgICAgLy8gVGhlIHRleHQgY2FuIGNvbnRhaW4gc3BhY2VzLCBidXQgbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZXMgYXJlIHNraXBwZWQuXG4gICAgJ1teXFxcXHM6LC9dW14nICsgc3BlY2lhbHMgKyAnXSpbXlxcXFxzJyArIHNwZWNpYWxzICsgJ10nLFxuICAgICAgLy8gTWF0Y2ggYW55IG5vbi1zcGFjZSBjaGFyYWN0ZXIgbm90IG1hdGNoZWQgYWxyZWFkeS4gVGhpcyB3aWxsIG1hdGNoIGNvbG9ucyBhbmQgY29tbWFzLCBzaW5jZSB0aGV5J3JlXG4gICAgICAvLyBub3QgbWF0Y2hlZCBieSBcImV2ZXJ5VGhpbmdFbHNlXCIsIGJ1dCB3aWxsIGFsc28gbWF0Y2ggYW55IG90aGVyIHNpbmdsZSBjaGFyYWN0ZXIgdGhhdCB3YXNuJ3QgYWxyZWFkeVxuICAgICAgLy8gbWF0Y2hlZCAoZm9yIGV4YW1wbGU6IGluIFwiYTogMSwgYjogMlwiLCBlYWNoIG9mIHRoZSBub24tc3BhY2UgY2hhcmFjdGVycyB3aWxsIGJlIG1hdGNoZWQgYnkgb25lTm90U3BhY2UpLlxuICAgICdbXlxcXFxzXSdcbiAgXS5qb2luKCd8JyksICdnJyk7XG5cbiAgICAvLyBNYXRjaCBlbmQgb2YgcHJldmlvdXMgdG9rZW4gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBzbGFzaCBpcyBhIGRpdmlzaW9uIG9yIHJlZ2V4LlxuICBjb25zdCBkaXZpc2lvbkxvb2tCZWhpbmQgPSAvW1xcXSlcIidBLVphLXowLTlfJF0rJC87XG4gIGNvbnN0IGtleXdvcmRSZWdleExvb2tCZWhpbmQgPSB7ICdpbic6IDEsICdyZXR1cm4nOiAxLCAndHlwZW9mJzogMSB9O1xuXG4gIC8qKlxuICAgKiBCcmVhayBhIGJpbmRpbmcgc3RyaW5nIChkYXRhLWJpbmQ9J3g6IHZhbCwgeTogLi4nKSBpbnRvIGEgc3RhYmxlIGFycmF5XG4gICAqIG9mIHtrZXk6IHZhbHVlfS5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0TGl0ZXJhbCAob2JqZWN0TGl0ZXJhbFN0cmluZykge1xuICAgIC8vIFRyaW0gbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzIGZyb20gdGhlIHN0cmluZ1xuICAgIHZhciBzdHIgPSBzdHJpbmdUcmltKG9iamVjdExpdGVyYWxTdHJpbmcpO1xuXG4gICAgLy8gVHJpbSBicmFjZXMgJ3snIHN1cnJvdW5kaW5nIHRoZSB3aG9sZSBvYmplY3QgbGl0ZXJhbFxuICAgIGlmIChzdHIuY2hhckNvZGVBdCgwKSA9PT0gMTIzKSBzdHIgPSBzdHIuc2xpY2UoMSwgLTEpO1xuXG4gICAgLy8gQWRkIGEgbmV3bGluZSB0byBjb3JyZWN0bHkgbWF0Y2ggYSBDKysgc3R5bGUgY29tbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgYW5kXG4gICAgLy8gYWRkIGEgY29tbWEgc28gdGhhdCB3ZSBkb24ndCBuZWVkIGEgc2VwYXJhdGUgY29kZSBibG9jayB0byBkZWFsIHdpdGggdGhlIGxhc3QgaXRlbVxuICAgIHN0ciArPSAnXFxuLCc7XG5cbiAgICAvLyBTcGxpdCBpbnRvIHRva2Vuc1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgdG9rcyA9IHN0ci5tYXRjaChiaW5kaW5nVG9rZW4pO1xuICAgIHZhciBrZXk7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHZhciBkZXB0aCA9IDA7XG5cbiAgICBpZiAodG9rcy5sZW5ndGggPD0gMSkgeyByZXR1cm4gW10gfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIHRvazsgdG9rID0gdG9rc1tpXTsgKytpKSB7XG4gICAgICB2YXIgYyA9IHRvay5jaGFyQ29kZUF0KDApO1xuICAgICAgLy8gQSBjb21tYSBzaWduYWxzIHRoZSBlbmQgb2YgYSBrZXkvdmFsdWUgcGFpciBpZiBkZXB0aCBpcyB6ZXJvXG4gICAgICBpZiAoYyA9PT0gNDQpIHsgLy8gXCIsXCJcbiAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgoa2V5ICYmIHZhbHVlcy5sZW5ndGgpID8ge1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVzLmpvaW4oJycpXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICd1bmtub3duJzoga2V5IHx8IHZhbHVlcy5qb2luKCcnKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGtleSA9IGRlcHRoID0gMDtcbiAgICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIFNpbXBseSBza2lwIHRoZSBjb2xvbiB0aGF0IHNlcGFyYXRlcyB0aGUgbmFtZSBhbmQgdmFsdWVcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gNTgpIHsgLy8gXCI6XCJcbiAgICAgICAgaWYgKCFkZXB0aCAmJiAha2V5ICYmIHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBrZXkgPSB2YWx1ZXMucG9wKCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHNldCBvZiBzbGFzaGVzIGlzIGluaXRpYWxseSBtYXRjaGVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uLCBidXQgY291bGQgYmUgZGl2aXNpb25cbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gNDcgJiYgdG9rLmxlbmd0aCA+IDEgJiYgKHRvay5jaGFyQ29kZUF0KDEpID09PSA0NyB8fCB0b2suY2hhckNvZGVBdCgxKSA9PT0gNDIpKSB7IC8vIFwiLy9cIiBvciBcIi8qXCJcbiAgICAgICAgLy8gc2tpcCBjb21tZW50c1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmIChjID09PSA0NyAmJiBpICYmIHRvay5sZW5ndGggPiAxKSB7IC8vIFwiL1wiXG4gICAgICAgIC8vIExvb2sgYXQgdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgdG9rZW4gdG8gZGV0ZXJtaW5lIGlmIHRoZSBzbGFzaCBpcyBhY3R1YWxseSBkaXZpc2lvblxuICAgICAgICB2YXIgbWF0Y2ggPSB0b2tzW2kgLSAxXS5tYXRjaChkaXZpc2lvbkxvb2tCZWhpbmQpO1xuICAgICAgICBpZiAobWF0Y2ggJiYgIWtleXdvcmRSZWdleExvb2tCZWhpbmRbbWF0Y2hbMF1dKSB7XG4gICAgICAgICAgLy8gVGhlIHNsYXNoIGlzIGFjdHVhbGx5IGEgZGl2aXNpb24gcHVuY3R1YXRvcjsgcmUtcGFyc2UgdGhlIHJlbWFpbmRlciBvZiB0aGUgc3RyaW5nIChub3QgaW5jbHVkaW5nIHRoZSBzbGFzaClcbiAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKHN0ci5pbmRleE9mKHRvaykgKyAxKTtcbiAgICAgICAgICB0b2tzID0gc3RyLm1hdGNoKGJpbmRpbmdUb2tlbik7XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGgganVzdCB0aGUgc2xhc2hcbiAgICAgICAgICB0b2sgPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5jcmVtZW50IGRlcHRoIGZvciBwYXJlbnRoZXNlcywgYnJhY2VzLCBhbmQgYnJhY2tldHMgc28gdGhhdCBpbnRlcmlvciBjb21tYXMgYXJlIGlnbm9yZWRcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gNDAgfHwgYyA9PT0gMTIzIHx8IGMgPT09IDkxKSB7IC8vICcoJywgJ3snLCAnWydcbiAgICAgICAgKytkZXB0aDtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gNDEgfHwgYyA9PT0gMTI1IHx8IGMgPT09IDkzKSB7IC8vICcpJywgJ30nLCAnXSdcbiAgICAgICAgLS1kZXB0aDtcbiAgICAgICAgLy8gVGhlIGtleSB3aWxsIGJlIHRoZSBmaXJzdCB0b2tlbjsgaWYgaXQncyBhIHN0cmluZywgdHJpbSB0aGUgcXVvdGVzXG4gICAgICB9IGVsc2UgaWYgKCFrZXkgJiYgIXZhbHVlcy5sZW5ndGggJiYgKGMgPT09IDM0IHx8IGMgPT09IDM5KSkgeyAvLyAnXCInLCBcIidcIlxuICAgICAgICB0b2sgPSB0b2suc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuICAgICAgdmFsdWVzLnB1c2godG9rKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvL1xuXG4gIGNvbnN0IGNvbXB1dGVkU3RhdGUgPSBjcmVhdGVTeW1ib2xPclN0cmluZygnX3N0YXRlJyk7XG4gIGNvbnN0IERJU1BPU0VEX1NUQVRFID0ge1xuICAgIGRlcGVuZGVuY3lUcmFja2luZzogbnVsbCxcbiAgICBkZXBlbmRlbmNpZXNDb3VudDogMCxcbiAgICBpc0Rpc3Bvc2VkOiB0cnVlLFxuICAgIGlzU3RhbGU6IGZhbHNlLFxuICAgIGlzRGlydHk6IGZhbHNlLFxuICAgIGlzU2xlZXBpbmc6IGZhbHNlLFxuICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogbnVsbCxcbiAgICByZWFkRnVuY3Rpb246IG51bGwsXG4gICAgX29wdGlvbnM6IG51bGxcbiAgfTtcblxuICBmdW5jdGlvbiBjb21wdXRlZCAoZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMsIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0LCBvcHRpb25zJCQxKSB7XG4gICAgaWYgKHR5cGVvZiBldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBTaW5nbGUtcGFyYW1ldGVyIHN5bnRheCAtIGV2ZXJ5dGhpbmcgaXMgb24gdGhpcyBcIm9wdGlvbnNcIiBwYXJhbVxuICAgICAgb3B0aW9ucyQkMSA9IGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTXVsdGktcGFyYW1ldGVyIHN5bnRheCAtIGNvbnN0cnVjdCB0aGUgb3B0aW9ucyBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtcyBwYXNzZWRcbiAgICAgIG9wdGlvbnMkJDEgPSBvcHRpb25zJCQxIHx8IHt9O1xuICAgICAgaWYgKGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMkJDEucmVhZCA9IGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMkJDEucmVhZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgRXJyb3IoJ1Bhc3MgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBjb21wdXRlZCcpXG4gICAgfVxuXG4gICAgdmFyIHdyaXRlRnVuY3Rpb24gPSBvcHRpb25zJCQxLndyaXRlO1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIGxhdGVzdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBpc1N0YWxlOiB0cnVlLFxuICAgICAgaXNEaXJ0eTogdHJ1ZSxcbiAgICAgIGlzQmVpbmdFdmFsdWF0ZWQ6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NEaXNwb3NhbFVudGlsRGlzcG9zZVdoZW5SZXR1cm5zRmFsc2U6IGZhbHNlLFxuICAgICAgaXNEaXNwb3NlZDogZmFsc2UsXG4gICAgICBwdXJlOiBmYWxzZSxcbiAgICAgIGlzU2xlZXBpbmc6IGZhbHNlLFxuICAgICAgcmVhZEZ1bmN0aW9uOiBvcHRpb25zJCQxLnJlYWQsXG4gICAgICBldmFsdWF0b3JGdW5jdGlvblRhcmdldDogZXZhbHVhdG9yRnVuY3Rpb25UYXJnZXQgfHwgb3B0aW9ucyQkMS5vd25lcixcbiAgICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogb3B0aW9ucyQkMS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQgfHwgb3B0aW9ucyQkMS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQgfHwgbnVsbCxcbiAgICAgIGRpc3Bvc2VXaGVuOiBvcHRpb25zJCQxLmRpc3Bvc2VXaGVuIHx8IG9wdGlvbnMkJDEuZGlzcG9zZVdoZW4sXG4gICAgICBkb21Ob2RlRGlzcG9zYWxDYWxsYmFjazogbnVsbCxcbiAgICAgIGRlcGVuZGVuY3lUcmFja2luZzoge30sXG4gICAgICBkZXBlbmRlbmNpZXNDb3VudDogMCxcbiAgICAgIGV2YWx1YXRpb25UaW1lb3V0SW5zdGFuY2U6IG51bGxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY29tcHV0ZWRPYnNlcnZhYmxlICgpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodHlwZW9mIHdyaXRlRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdyaXRpbmcgYSB2YWx1ZVxuICAgICAgICAgIHdyaXRlRnVuY3Rpb24uYXBwbHkoc3RhdGUuZXZhbHVhdG9yRnVuY3Rpb25UYXJnZXQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHdyaXRlIGEgdmFsdWUgdG8gYSBjb21wdXRlZCB1bmxlc3MgeW91IHNwZWNpZnkgYSAnd3JpdGUnIG9wdGlvbi4gSWYgeW91IHdpc2ggdG8gcmVhZCB0aGUgY3VycmVudCB2YWx1ZSwgZG9uJ3QgcGFzcyBhbnkgcGFyYW1ldGVycy5cIilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcyAvLyBQZXJtaXRzIGNoYWluZWQgYXNzaWdubWVudHNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlYWRpbmcgdGhlIHZhbHVlXG4gICAgICAgIGlmICghc3RhdGUuaXNEaXNwb3NlZCkge1xuICAgICAgICAgIHJlZ2lzdGVyRGVwZW5kZW5jeShjb21wdXRlZE9ic2VydmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5pc0RpcnR5IHx8IChzdGF0ZS5pc1NsZWVwaW5nICYmIGNvbXB1dGVkT2JzZXJ2YWJsZS5oYXZlRGVwZW5kZW5jaWVzQ2hhbmdlZCgpKSkge1xuICAgICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5ldmFsdWF0ZUltbWVkaWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZS5sYXRlc3RWYWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXB1dGVkT2JzZXJ2YWJsZVtjb21wdXRlZFN0YXRlXSA9IHN0YXRlO1xuICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5pc1dyaXRlYWJsZSA9IHR5cGVvZiB3cml0ZUZ1bmN0aW9uID09PSAnZnVuY3Rpb24nO1xuXG4gICAgc3Vic2NyaWJhYmxlLmZuLmluaXQoY29tcHV0ZWRPYnNlcnZhYmxlKTtcblxuICAgIC8vIEluaGVyaXQgZnJvbSAnY29tcHV0ZWQnXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNvbXB1dGVkT2JzZXJ2YWJsZSwgY29tcHV0ZWQuZm4pO1xuXG4gICAgaWYgKG9wdGlvbnMkJDEucHVyZSkge1xuICAgICAgc3RhdGUucHVyZSA9IHRydWU7XG4gICAgICBzdGF0ZS5pc1NsZWVwaW5nID0gdHJ1ZTsgICAgIC8vIFN0YXJ0cyBvZmYgc2xlZXBpbmc7IHdpbGwgYXdha2Ugb24gdGhlIGZpcnN0IHN1YnNjcmlwdGlvblxuICAgICAgZXh0ZW5kKGNvbXB1dGVkT2JzZXJ2YWJsZSwgcHVyZUNvbXB1dGVkT3ZlcnJpZGVzKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMkJDEuZGVmZXJFdmFsdWF0aW9uKSB7XG4gICAgICBleHRlbmQoY29tcHV0ZWRPYnNlcnZhYmxlLCBkZWZlckV2YWx1YXRpb25PdmVycmlkZXMpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRlZmVyVXBkYXRlcykge1xuICAgICAgZXh0ZW5kZXJzLmRlZmVycmVkKGNvbXB1dGVkT2JzZXJ2YWJsZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAvLyAjMTczMSAtIEFpZCBkZWJ1Z2dpbmcgYnkgZXhwb3NpbmcgdGhlIGNvbXB1dGVkJ3Mgb3B0aW9uc1xuICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLl9vcHRpb25zID0gb3B0aW9ucyQkMTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkKSB7XG4gICAgICAgICAgLy8gU2luY2UgdGhpcyBjb21wdXRlZCBpcyBhc3NvY2lhdGVkIHdpdGggYSBET00gbm9kZSwgYW5kIHdlIGRvbid0IHdhbnQgdG8gZGlzcG9zZSB0aGUgY29tcHV0ZWRcbiAgICAgICAgICAvLyB1bnRpbCB0aGUgRE9NIG5vZGUgaXMgKnJlbW92ZWQqIGZyb20gdGhlIGRvY3VtZW50IChhcyBvcHBvc2VkIHRvIG5ldmVyIGhhdmluZyBiZWVuIGluIHRoZSBkb2N1bWVudCksXG4gICAgICAgICAgLy8gd2UnbGwgcHJldmVudCBkaXNwb3NhbCB1bnRpbCBcImRpc3Bvc2VXaGVuXCIgZmlyc3QgcmV0dXJucyBmYWxzZS5cbiAgICAgIHN0YXRlLnN1cHByZXNzRGlzcG9zYWxVbnRpbERpc3Bvc2VXaGVuUmV0dXJuc0ZhbHNlID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogdHJ1ZSBjYW4gYmUgdXNlZCB0byBvcHQgaW50byB0aGUgXCJvbmx5IGRpc3Bvc2UgYWZ0ZXIgZmlyc3QgZmFsc2UgcmVzdWx0XCJcbiAgICAgICAgICAvLyBiZWhhdmlvciBldmVuIGlmIHRoZXJlJ3Mgbm8gc3BlY2lmaWMgbm9kZSB0byB3YXRjaC4gSW4gdGhhdCBjYXNlLCBjbGVhciB0aGUgb3B0aW9uIHNvIHdlIGRvbid0IHRyeVxuICAgICAgICAgIC8vIHRvIHdhdGNoIGZvciBhIG5vbi1ub2RlJ3MgZGlzcG9zYWwuIFRoaXMgdGVjaG5pcXVlIGlzIGludGVuZGVkIGZvciBLTydzIGludGVybmFsIHVzZSBvbmx5IGFuZCBzaG91bGRuJ3RcbiAgICAgICAgICAvLyBiZSBkb2N1bWVudGVkIG9yIHVzZWQgYnkgYXBwbGljYXRpb24gY29kZSwgYXMgaXQncyBsaWtlbHkgdG8gY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgS08uXG4gICAgICBpZiAoIXN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZC5ub2RlVHlwZSkge1xuICAgICAgICBzdGF0ZS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgICAgLy8gRXZhbHVhdGUsIHVubGVzcyBzbGVlcGluZyBvciBkZWZlckV2YWx1YXRpb24gaXMgdHJ1ZVxuICAgIGlmICghc3RhdGUuaXNTbGVlcGluZyAmJiAhb3B0aW9ucyQkMS5kZWZlckV2YWx1YXRpb24pIHtcbiAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5ldmFsdWF0ZUltbWVkaWF0ZSgpO1xuICAgIH1cblxuICAgICAgLy8gQXR0YWNoIGEgRE9NIG5vZGUgZGlzcG9zYWwgY2FsbGJhY2sgc28gdGhhdCB0aGUgY29tcHV0ZWQgd2lsbCBiZSBwcm9hY3RpdmVseSBkaXNwb3NlZCBhcyBzb29uIGFzIHRoZSBub2RlIGlzXG4gICAgICAvLyByZW1vdmVkIHVzaW5nIGtvLnJlbW92ZU5vZGUuIEJ1dCBza2lwIGlmIGlzQWN0aXZlIGlzIGZhbHNlICh0aGVyZSB3aWxsIG5ldmVyIGJlIGFueSBkZXBlbmRlbmNpZXMgdG8gZGlzcG9zZSkuXG4gICAgaWYgKHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCAmJiBjb21wdXRlZE9ic2VydmFibGUuaXNBY3RpdmUoKSkge1xuICAgICAgYWRkRGlzcG9zZUNhbGxiYWNrKHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCwgc3RhdGUuZG9tTm9kZURpc3Bvc2FsQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcHV0ZWRPYnNlcnZhYmxlXG4gIH1cblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgZGlzcG9zZXMgYSBnaXZlbiBkZXBlbmRlbmN5VHJhY2tpbmcgZW50cnlcbiAgZnVuY3Rpb24gY29tcHV0ZWREaXNwb3NlRGVwZW5kZW5jeUNhbGxiYWNrIChpZCwgZW50cnlUb0Rpc3Bvc2UpIHtcbiAgICBpZiAoZW50cnlUb0Rpc3Bvc2UgIT09IG51bGwgJiYgZW50cnlUb0Rpc3Bvc2UuZGlzcG9zZSkge1xuICAgICAgZW50cnlUb0Rpc3Bvc2UuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZWFjaCB0aW1lIGEgZGVwZW5kZW5jeSBpcyBkZXRlY3RlZCB3aGlsZSBldmFsdWF0aW5nIGEgY29tcHV0ZWQuXG4gIC8vIEl0J3MgZmFjdG9yZWQgb3V0IGFzIGEgc2hhcmVkIGZ1bmN0aW9uIHRvIGF2b2lkIGNyZWF0aW5nIHVubmVjZXNzYXJ5IGZ1bmN0aW9uIGluc3RhbmNlcyBkdXJpbmcgZXZhbHVhdGlvbi5cbiAgZnVuY3Rpb24gY29tcHV0ZWRCZWdpbkRlcGVuZGVuY3lEZXRlY3Rpb25DYWxsYmFjayAoc3Vic2NyaWJhYmxlJCQxLCBpZCkge1xuICAgIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLmNvbXB1dGVkT2JzZXJ2YWJsZSxcbiAgICAgIHN0YXRlID0gY29tcHV0ZWRPYnNlcnZhYmxlW2NvbXB1dGVkU3RhdGVdO1xuICAgIGlmICghc3RhdGUuaXNEaXNwb3NlZCkge1xuICAgICAgaWYgKHRoaXMuZGlzcG9zYWxDb3VudCAmJiB0aGlzLmRpc3Bvc2FsQ2FuZGlkYXRlc1tpZF0pIHtcbiAgICAgICAgLy8gRG9uJ3Qgd2FudCB0byBkaXNwb3NlIHRoaXMgc3Vic2NyaXB0aW9uLCBhcyBpdCdzIHN0aWxsIGJlaW5nIHVzZWRcbiAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLmFkZERlcGVuZGVuY3lUcmFja2luZyhpZCwgc3Vic2NyaWJhYmxlJCQxLCB0aGlzLmRpc3Bvc2FsQ2FuZGlkYXRlc1tpZF0pO1xuICAgICAgICB0aGlzLmRpc3Bvc2FsQ2FuZGlkYXRlc1tpZF0gPSBudWxsOyAvLyBObyBuZWVkIHRvIGFjdHVhbGx5IGRlbGV0ZSB0aGUgcHJvcGVydHkgLSBkaXNwb3NhbENhbmRpZGF0ZXMgaXMgYSB0cmFuc2llbnQgb2JqZWN0IGFueXdheVxuICAgICAgICAtLXRoaXMuZGlzcG9zYWxDb3VudDtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLmRlcGVuZGVuY3lUcmFja2luZ1tpZF0pIHtcbiAgICAgICAgLy8gQnJhbmQgbmV3IHN1YnNjcmlwdGlvbiAtIGFkZCBpdFxuICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuYWRkRGVwZW5kZW5jeVRyYWNraW5nKGlkLCBzdWJzY3JpYmFibGUkJDEsIHN0YXRlLmlzU2xlZXBpbmcgPyB7IF90YXJnZXQ6IHN1YnNjcmliYWJsZSQkMSB9IDogY29tcHV0ZWRPYnNlcnZhYmxlLnN1YnNjcmliZVRvRGVwZW5kZW5jeShzdWJzY3JpYmFibGUkJDEpKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBvYnNlcnZhYmxlIHdlJ3ZlIGFjY2Vzc2VkIGhhcyBhIHBlbmRpbmcgbm90aWZpY2F0aW9uLCBlbnN1cmVcbiAgICAgIC8vIHdlIGdldCBub3RpZmllZCBvZiB0aGUgYWN0dWFsIGZpbmFsIHZhbHVlIChieXBhc3MgZXF1YWxpdHkgY2hlY2tzKVxuICAgICAgaWYgKHN1YnNjcmliYWJsZSQkMS5fbm90aWZpY2F0aW9uSXNQZW5kaW5nKSB7XG4gICAgICAgIHN1YnNjcmliYWJsZSQkMS5fbm90aWZ5TmV4dENoYW5nZUlmVmFsdWVJc0RpZmZlcmVudCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbXB1dGVkLmZuID0ge1xuICAgIGVxdWFsaXR5Q29tcGFyZXI6IHZhbHVlc0FyZVByaW1pdGl2ZUFuZEVxdWFsLFxuICAgIGdldERlcGVuZGVuY2llc0NvdW50ICgpIHtcbiAgICAgIHJldHVybiB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY2llc0NvdW50XG4gICAgfSxcblxuICAgIGdldERlcGVuZGVuY2llcyAoKSB7XG4gICAgICBjb25zdCBkZXBlbmRlbmN5VHJhY2tpbmcgPSB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY3lUcmFja2luZztcbiAgICAgIGNvbnN0IGRlcGVuZGVudE9ic2VydmFibGVzID0gW107XG5cbiAgICAgIG9iamVjdEZvckVhY2goZGVwZW5kZW5jeVRyYWNraW5nLCBmdW5jdGlvbiAoaWQsIGRlcGVuZGVuY3kpIHtcbiAgICAgICAgZGVwZW5kZW50T2JzZXJ2YWJsZXNbZGVwZW5kZW5jeS5fb3JkZXJdID0gZGVwZW5kZW5jeS5fdGFyZ2V0O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBkZXBlbmRlbnRPYnNlcnZhYmxlc1xuICAgIH0sXG5cbiAgICBhZGREZXBlbmRlbmN5VHJhY2tpbmcgKGlkLCB0YXJnZXQsIHRyYWNraW5nT2JqKSB7XG4gICAgICBpZiAodGhpc1tjb21wdXRlZFN0YXRlXS5wdXJlICYmIHRhcmdldCA9PT0gdGhpcykge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkEgJ3B1cmUnIGNvbXB1dGVkIG11c3Qgbm90IGJlIGNhbGxlZCByZWN1cnNpdmVseVwiKVxuICAgICAgfVxuXG4gICAgICB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSB0cmFja2luZ09iajtcbiAgICAgIHRyYWNraW5nT2JqLl9vcmRlciA9IHRoaXNbY29tcHV0ZWRTdGF0ZV0uZGVwZW5kZW5jaWVzQ291bnQrKztcbiAgICAgIHRyYWNraW5nT2JqLl92ZXJzaW9uID0gdGFyZ2V0LmdldFZlcnNpb24oKTtcbiAgICB9LFxuICAgIGhhdmVEZXBlbmRlbmNpZXNDaGFuZ2VkICgpIHtcbiAgICAgIHZhciBpZCwgZGVwZW5kZW5jeSwgZGVwZW5kZW5jeVRyYWNraW5nID0gdGhpc1tjb21wdXRlZFN0YXRlXS5kZXBlbmRlbmN5VHJhY2tpbmc7XG4gICAgICBmb3IgKGlkIGluIGRlcGVuZGVuY3lUcmFja2luZykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeVRyYWNraW5nLCBpZCkpIHtcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jeVRyYWNraW5nW2lkXTtcbiAgICAgICAgICBpZiAoKHRoaXMuX2V2YWxEZWxheWVkICYmIGRlcGVuZGVuY3kuX3RhcmdldC5fbm90aWZpY2F0aW9uSXNQZW5kaW5nKSB8fCBkZXBlbmRlbmN5Ll90YXJnZXQuaGFzQ2hhbmdlZChkZXBlbmRlbmN5Ll92ZXJzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1hcmtEaXJ0eSAoKSB7XG4gICAgICAgICAgLy8gUHJvY2VzcyBcImRpcnR5XCIgZXZlbnRzIGlmIHdlIGNhbiBoYW5kbGUgZGVsYXllZCBub3RpZmljYXRpb25zXG4gICAgICBpZiAodGhpcy5fZXZhbERlbGF5ZWQgJiYgIXRoaXNbY29tcHV0ZWRTdGF0ZV0uaXNCZWluZ0V2YWx1YXRlZCkge1xuICAgICAgICB0aGlzLl9ldmFsRGVsYXllZChmYWxzZSAvKiBub3RpZnlDaGFuZ2UgKi8pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNBY3RpdmUgKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW2NvbXB1dGVkU3RhdGVdO1xuICAgICAgcmV0dXJuIHN0YXRlLmlzRGlydHkgfHwgc3RhdGUuZGVwZW5kZW5jaWVzQ291bnQgPiAwXG4gICAgfSxcbiAgICByZXNwb25kVG9DaGFuZ2UgKCkge1xuICAgICAgICAgIC8vIElnbm9yZSBcImNoYW5nZVwiIGV2ZW50cyBpZiB3ZSd2ZSBhbHJlYWR5IHNjaGVkdWxlZCBhIGRlbGF5ZWQgbm90aWZpY2F0aW9uXG4gICAgICBpZiAoIXRoaXMuX25vdGlmaWNhdGlvbklzUGVuZGluZykge1xuICAgICAgICB0aGlzLmV2YWx1YXRlUG9zc2libHlBc3luYygpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzW2NvbXB1dGVkU3RhdGVdLmlzRGlydHkpIHtcbiAgICAgICAgdGhpc1tjb21wdXRlZFN0YXRlXS5pc1N0YWxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN1YnNjcmliZVRvRGVwZW5kZW5jeSAodGFyZ2V0KSB7XG4gICAgICBpZiAodGFyZ2V0Ll9kZWZlclVwZGF0ZXMpIHtcbiAgICAgICAgdmFyIGRpcnR5U3ViID0gdGFyZ2V0LnN1YnNjcmliZSh0aGlzLm1hcmtEaXJ0eSwgdGhpcywgJ2RpcnR5JyksXG4gICAgICAgICAgY2hhbmdlU3ViID0gdGFyZ2V0LnN1YnNjcmliZSh0aGlzLnJlc3BvbmRUb0NoYW5nZSwgdGhpcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgX3RhcmdldDogdGFyZ2V0LFxuICAgICAgICAgIGRpc3Bvc2UgKCkge1xuICAgICAgICAgICAgZGlydHlTdWIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgY2hhbmdlU3ViLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQuc3Vic2NyaWJlKHRoaXMuZXZhbHVhdGVQb3NzaWJseUFzeW5jLCB0aGlzKVxuICAgICAgfVxuICAgIH0sXG4gICAgZXZhbHVhdGVQb3NzaWJseUFzeW5jICgpIHtcbiAgICAgIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLFxuICAgICAgICB0aHJvdHRsZUV2YWx1YXRpb25UaW1lb3V0ID0gY29tcHV0ZWRPYnNlcnZhYmxlLnRocm90dGxlRXZhbHVhdGlvbjtcbiAgICAgIGlmICh0aHJvdHRsZUV2YWx1YXRpb25UaW1lb3V0ICYmIHRocm90dGxlRXZhbHVhdGlvblRpbWVvdXQgPj0gMCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpc1tjb21wdXRlZFN0YXRlXS5ldmFsdWF0aW9uVGltZW91dEluc3RhbmNlKTtcbiAgICAgICAgdGhpc1tjb21wdXRlZFN0YXRlXS5ldmFsdWF0aW9uVGltZW91dEluc3RhbmNlID0gc2FmZVNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5ldmFsdWF0ZUltbWVkaWF0ZSh0cnVlIC8qIG5vdGlmeUNoYW5nZSAqLyk7XG4gICAgICAgIH0sIHRocm90dGxlRXZhbHVhdGlvblRpbWVvdXQpO1xuICAgICAgfSBlbHNlIGlmIChjb21wdXRlZE9ic2VydmFibGUuX2V2YWxEZWxheWVkKSB7XG4gICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5fZXZhbERlbGF5ZWQodHJ1ZSAvKiBub3RpZnlDaGFuZ2UgKi8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLmV2YWx1YXRlSW1tZWRpYXRlKHRydWUgLyogbm90aWZ5Q2hhbmdlICovKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV2YWx1YXRlSW1tZWRpYXRlIChub3RpZnlDaGFuZ2UpIHtcbiAgICAgIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLFxuICAgICAgICBzdGF0ZSA9IGNvbXB1dGVkT2JzZXJ2YWJsZVtjb21wdXRlZFN0YXRlXSxcbiAgICAgICAgZGlzcG9zZVdoZW4gPSBzdGF0ZS5kaXNwb3NlV2hlbixcbiAgICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoc3RhdGUuaXNCZWluZ0V2YWx1YXRlZCkge1xuICAgICAgICAvLyBJZiB0aGUgZXZhbHVhdGlvbiBvZiBhIGtvLmNvbXB1dGVkIGNhdXNlcyBzaWRlIGVmZmVjdHMsIGl0J3MgcG9zc2libGUgdGhhdCBpdCB3aWxsIHRyaWdnZXIgaXRzIG93biByZS1ldmFsdWF0aW9uLlxuICAgICAgICAvLyBUaGlzIGlzIG5vdCBkZXNpcmFibGUgKGl0J3MgaGFyZCBmb3IgYSBkZXZlbG9wZXIgdG8gcmVhbGlzZSBhIGNoYWluIG9mIGRlcGVuZGVuY2llcyBtaWdodCBjYXVzZSB0aGlzLCBhbmQgdGhleSBhbG1vc3RcbiAgICAgICAgLy8gY2VydGFpbmx5IGRpZG4ndCBpbnRlbmQgaW5maW5pdGUgcmUtZXZhbHVhdGlvbnMpLiBTbywgZm9yIHByZWRpY3RhYmlsaXR5LCB3ZSBzaW1wbHkgcHJldmVudCBrby5jb21wdXRlZHMgZnJvbSBjYXVzaW5nXG4gICAgICAgIC8vIHRoZWlyIG93biByZS1ldmFsdWF0aW9uLiBGdXJ0aGVyIGRpc2N1c3Npb24gYXQgaHR0cHM6Ly9naXRodWIuY29tL1N0ZXZlU2FuZGVyc29uL2tub2Nrb3V0L3B1bGwvMzg3XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAgICAgLy8gRG8gbm90IGV2YWx1YXRlIChhbmQgcG9zc2libHkgY2FwdHVyZSBuZXcgZGVwZW5kZW5jaWVzKSBpZiBkaXNwb3NlZFxuICAgICAgaWYgKHN0YXRlLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQgJiYgIWRvbU5vZGVJc0F0dGFjaGVkVG9Eb2N1bWVudChzdGF0ZS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQpIHx8IGRpc3Bvc2VXaGVuICYmIGRpc3Bvc2VXaGVuKCkpIHtcbiAgICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUgYWJvdXQgc3VwcHJlc3NEaXNwb3NhbFVudGlsRGlzcG9zZVdoZW5SZXR1cm5zRmFsc2VcbiAgICAgICAgaWYgKCFzdGF0ZS5zdXBwcmVzc0Rpc3Bvc2FsVW50aWxEaXNwb3NlV2hlblJldHVybnNGYWxzZSkge1xuICAgICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEl0IGp1c3QgZGlkIHJldHVybiBmYWxzZSwgc28gd2UgY2FuIHN0b3Agc3VwcHJlc3Npbmcgbm93XG4gICAgICAgIHN0YXRlLnN1cHByZXNzRGlzcG9zYWxVbnRpbERpc3Bvc2VXaGVuUmV0dXJuc0ZhbHNlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmlzQmVpbmdFdmFsdWF0ZWQgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2hhbmdlZCA9IHRoaXMuZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRXaXRoRGVwZW5kZW5jeURldGVjdGlvbihub3RpZnlDaGFuZ2UpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc3RhdGUuaXNCZWluZ0V2YWx1YXRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlZFxuICAgIH0sXG4gICAgZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRXaXRoRGVwZW5kZW5jeURldGVjdGlvbiAobm90aWZ5Q2hhbmdlKSB7XG4gICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyByZWFsbHkganVzdCBwYXJ0IG9mIHRoZSBldmFsdWF0ZUltbWVkaWF0ZSBsb2dpYy4gWW91IHdvdWxkIG5ldmVyIGNhbGwgaXQgZnJvbSBhbnl3aGVyZSBlbHNlLlxuICAgICAgICAgIC8vIEZhY3RvcmluZyBpdCBvdXQgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uIG1lYW5zIGl0IGNhbiBiZSBpbmRlcGVuZGVudCBvZiB0aGUgdHJ5L2NhdGNoIGJsb2NrIGluIGV2YWx1YXRlSW1tZWRpYXRlLFxuICAgICAgICAgIC8vIHdoaWNoIGNvbnRyaWJ1dGVzIHRvIHNhdmluZyBhYm91dCA0MCUgb2ZmIHRoZSBDUFUgb3ZlcmhlYWQgb2YgY29tcHV0ZWQgZXZhbHVhdGlvbiAob24gVjggYXQgbGVhc3QpLlxuXG4gICAgICB2YXIgY29tcHV0ZWRPYnNlcnZhYmxlID0gdGhpcyxcbiAgICAgICAgc3RhdGUgPSBjb21wdXRlZE9ic2VydmFibGVbY29tcHV0ZWRTdGF0ZV0sXG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIEluaXRpYWxseSwgd2UgYXNzdW1lIHRoYXQgbm9uZSBvZiB0aGUgc3Vic2NyaXB0aW9ucyBhcmUgc3RpbGwgYmVpbmcgdXNlZCAoaS5lLiwgYWxsIGFyZSBjYW5kaWRhdGVzIGZvciBkaXNwb3NhbCkuXG4gICAgICAgICAgLy8gVGhlbiwgZHVyaW5nIGV2YWx1YXRpb24sIHdlIGNyb3NzIG9mZiBhbnkgdGhhdCBhcmUgaW4gZmFjdCBzdGlsbCBiZWluZyB1c2VkLlxuICAgICAgdmFyIGlzSW5pdGlhbCQkMSA9IHN0YXRlLnB1cmUgPyB1bmRlZmluZWQgOiAhc3RhdGUuZGVwZW5kZW5jaWVzQ291bnQsICAgLy8gSWYgd2UncmUgZXZhbHVhdGluZyB3aGVuIHRoZXJlIGFyZSBubyBwcmV2aW91cyBkZXBlbmRlbmNpZXMsIGl0IG11c3QgYmUgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQgPSB7XG4gICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlOiBjb21wdXRlZE9ic2VydmFibGUsXG4gICAgICAgICAgZGlzcG9zYWxDYW5kaWRhdGVzOiBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcsXG4gICAgICAgICAgZGlzcG9zYWxDb3VudDogc3RhdGUuZGVwZW5kZW5jaWVzQ291bnRcbiAgICAgICAgfTtcblxuICAgICAgYmVnaW4oe1xuICAgICAgICBjYWxsYmFja1RhcmdldDogZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQsXG4gICAgICAgIGNhbGxiYWNrOiBjb21wdXRlZEJlZ2luRGVwZW5kZW5jeURldGVjdGlvbkNhbGxiYWNrLFxuICAgICAgICBjb21wdXRlZDogY29tcHV0ZWRPYnNlcnZhYmxlLFxuICAgICAgICBpc0luaXRpYWw6IGlzSW5pdGlhbCQkMVxuICAgICAgfSk7XG5cbiAgICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZyA9IHt9O1xuICAgICAgc3RhdGUuZGVwZW5kZW5jaWVzQ291bnQgPSAwO1xuXG4gICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmV2YWx1YXRlSW1tZWRpYXRlX0NhbGxSZWFkVGhlbkVuZERlcGVuZGVuY3lEZXRlY3Rpb24oc3RhdGUsIGRlcGVuZGVuY3lEZXRlY3Rpb25Db250ZXh0KTtcblxuICAgICAgaWYgKCFzdGF0ZS5kZXBlbmRlbmNpZXNDb3VudCkge1xuICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZGlzcG9zZSgpO1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTsgLy8gV2hlbiBldmFsdWF0aW9uIGNhdXNlcyBhIGRpc3Bvc2FsLCBtYWtlIHN1cmUgYWxsIGRlcGVuZGVudCBjb21wdXRlZHMgZ2V0IG5vdGlmaWVkIHNvIHRoZXknbGwgc2VlIHRoZSBuZXcgc3RhdGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYW5nZWQgPSBjb21wdXRlZE9ic2VydmFibGUuaXNEaWZmZXJlbnQoc3RhdGUubGF0ZXN0VmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5pc1NsZWVwaW5nKSB7XG4gICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLm5vdGlmeVN1YnNjcmliZXJzKHN0YXRlLmxhdGVzdFZhbHVlLCAnYmVmb3JlQ2hhbmdlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLnVwZGF0ZVZlcnNpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmxhdGVzdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7IGNvbXB1dGVkT2JzZXJ2YWJsZS5fbGF0ZXN0VmFsdWUgPSBuZXdWYWx1ZTsgfVxuXG4gICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5ub3RpZnlTdWJzY3JpYmVycyhzdGF0ZS5sYXRlc3RWYWx1ZSwgJ3NwZWN0YXRlJyk7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5pc1NsZWVwaW5nICYmIG5vdGlmeUNoYW5nZSkge1xuICAgICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5ub3RpZnlTdWJzY3JpYmVycyhzdGF0ZS5sYXRlc3RWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcHV0ZWRPYnNlcnZhYmxlLl9yZWNvcmRVcGRhdGUpIHtcbiAgICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuX3JlY29yZFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0luaXRpYWwkJDEpIHtcbiAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLm5vdGlmeVN1YnNjcmliZXJzKHN0YXRlLmxhdGVzdFZhbHVlLCAnYXdha2UnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZWRcbiAgICB9LFxuICAgIGV2YWx1YXRlSW1tZWRpYXRlX0NhbGxSZWFkVGhlbkVuZERlcGVuZGVuY3lEZXRlY3Rpb24gKHN0YXRlLCBkZXBlbmRlbmN5RGV0ZWN0aW9uQ29udGV4dCkge1xuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyByZWFsbHkgcGFydCBvZiB0aGUgZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRXaXRoRGVwZW5kZW5jeURldGVjdGlvbiBsb2dpYy5cbiAgICAgIC8vIFlvdSdkIG5ldmVyIGNhbGwgaXQgZnJvbSBhbnl3aGVyZSBlbHNlLiBGYWN0b3JpbmcgaXQgb3V0IG1lYW5zIHRoYXQgZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRXaXRoRGVwZW5kZW5jeURldGVjdGlvblxuICAgICAgLy8gY2FuIGJlIGluZGVwZW5kZW50IG9mIHRyeS9maW5hbGx5IGJsb2Nrcywgd2hpY2ggY29udHJpYnV0ZXMgdG8gc2F2aW5nIGFib3V0IDQwJSBvZmYgdGhlIENQVVxuICAgICAgLy8gb3ZlcmhlYWQgb2YgY29tcHV0ZWQgZXZhbHVhdGlvbiAob24gVjggYXQgbGVhc3QpLlxuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVhZEZ1bmN0aW9uID0gc3RhdGUucmVhZEZ1bmN0aW9uO1xuICAgICAgICByZXR1cm4gc3RhdGUuZXZhbHVhdG9yRnVuY3Rpb25UYXJnZXQgPyByZWFkRnVuY3Rpb24uY2FsbChzdGF0ZS5ldmFsdWF0b3JGdW5jdGlvblRhcmdldCkgOiByZWFkRnVuY3Rpb24oKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZW5kKCk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggc3Vic2NyaXB0aW9uIG5vIGxvbmdlciBiZWluZyB1c2VkLCByZW1vdmUgaXQgZnJvbSB0aGUgYWN0aXZlIHN1YnNjcmlwdGlvbnMgbGlzdCBhbmQgZGlzcG9zZSBpdFxuICAgICAgICBpZiAoZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQuZGlzcG9zYWxDb3VudCAmJiAhc3RhdGUuaXNTbGVlcGluZykge1xuICAgICAgICAgIG9iamVjdEZvckVhY2goZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQuZGlzcG9zYWxDYW5kaWRhdGVzLCBjb21wdXRlZERpc3Bvc2VEZXBlbmRlbmN5Q2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaXNTdGFsZSA9IHN0YXRlLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBlZWsgKGZvcmNlRXZhbHVhdGUpIHtcbiAgICAgIC8vIFBlZWsgd29uJ3Qgb3JkaW5hcmlseSByZS1ldmFsdWF0ZSwgZXhjZXB0IHdoaWxlIHRoZSBjb21wdXRlZCBpcyBzbGVlcGluZ1xuICAgICAgLy8gIG9yIHRvIGdldCB0aGUgaW5pdGlhbCB2YWx1ZSB3aGVuIFwiZGVmZXJFdmFsdWF0aW9uXCIgaXMgc2V0LlxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW2NvbXB1dGVkU3RhdGVdO1xuICAgICAgaWYgKChzdGF0ZS5pc0RpcnR5ICYmIChmb3JjZUV2YWx1YXRlIHx8ICFzdGF0ZS5kZXBlbmRlbmNpZXNDb3VudCkpIHx8IChzdGF0ZS5pc1NsZWVwaW5nICYmIHRoaXMuaGF2ZURlcGVuZGVuY2llc0NoYW5nZWQoKSkpIHtcbiAgICAgICAgdGhpcy5ldmFsdWF0ZUltbWVkaWF0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlLmxhdGVzdFZhbHVlXG4gICAgfSxcblxuICAgIGdldCBbTEFURVNUX1ZBTFVFXSAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wZWVrKClcbiAgICB9LFxuXG4gICAgbGltaXQgKGxpbWl0RnVuY3Rpb24pIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tjb21wdXRlZFN0YXRlXTtcbiAgICAgIC8vIE92ZXJyaWRlIHRoZSBsaW1pdCBmdW5jdGlvbiB3aXRoIG9uZSB0aGF0IGRlbGF5cyBldmFsdWF0aW9uIGFzIHdlbGxcbiAgICAgIHN1YnNjcmliYWJsZS5mbi5saW1pdC5jYWxsKHRoaXMsIGxpbWl0RnVuY3Rpb24pO1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgIF9ldmFsSWZDaGFuZ2VkICgpIHtcbiAgICAgICAgICBpZiAoIXRoaXNbY29tcHV0ZWRTdGF0ZV0uaXNTbGVlcGluZykge1xuICAgICAgICAgICAgaWYgKHRoaXNbY29tcHV0ZWRTdGF0ZV0uaXNTdGFsZSkge1xuICAgICAgICAgICAgICB0aGlzLmV2YWx1YXRlSW1tZWRpYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzW2NvbXB1dGVkU3RhdGVdLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmxhdGVzdFZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIF9ldmFsRGVsYXllZCAoaXNDaGFuZ2UpIHtcbiAgICAgICAgICB0aGlzLl9saW1pdEJlZm9yZUNoYW5nZShzdGF0ZS5sYXRlc3RWYWx1ZSk7XG5cbiAgICAgICAgICAvLyBNYXJrIGFzIGRpcnR5XG4gICAgICAgICAgc3RhdGUuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgaWYgKGlzQ2hhbmdlKSB7XG4gICAgICAgICAgICBzdGF0ZS5pc1N0YWxlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQYXNzIHRoZSBvYnNlcnZhYmxlIHRvIHRoZSBcImxpbWl0XCIgY29kZSwgd2hpY2ggd2lsbCBldmFsdWF0ZSBpdCB3aGVuXG4gICAgICAgICAgLy8gaXQncyB0aW1lIHRvIGRvIHRoZSBub3RpZmljYXRpb24uXG4gICAgICAgICAgdGhpcy5fbGltaXRDaGFuZ2UodGhpcywgIWlzQ2hhbmdlIC8qIGlzRGlydHkgKi8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRpc3Bvc2UgKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tjb21wdXRlZFN0YXRlXTtcbiAgICAgIGlmICghc3RhdGUuaXNTbGVlcGluZyAmJiBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcpIHtcbiAgICAgICAgb2JqZWN0Rm9yRWFjaChzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcsIGZ1bmN0aW9uIChpZCwgZGVwZW5kZW5jeSkge1xuICAgICAgICAgIGlmIChkZXBlbmRlbmN5LmRpc3Bvc2UpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY3kuZGlzcG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkICYmIHN0YXRlLmRvbU5vZGVEaXNwb3NhbENhbGxiYWNrKSB7XG4gICAgICAgIHJlbW92ZURpc3Bvc2VDYWxsYmFjayhzdGF0ZS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQsIHN0YXRlLmRvbU5vZGVEaXNwb3NhbENhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUsIERJU1BPU0VEX1NUQVRFKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHB1cmVDb21wdXRlZE92ZXJyaWRlcyA9IHtcbiAgICBiZWZvcmVTdWJzY3JpcHRpb25BZGQgKGV2ZW50KSB7XG4gICAgICAgICAgLy8gSWYgYXNsZWVwLCB3YWtlIHVwIHRoZSBjb21wdXRlZCBieSBzdWJzY3JpYmluZyB0byBhbnkgZGVwZW5kZW5jaWVzLlxuICAgICAgdmFyIGNvbXB1dGVkT2JzZXJ2YWJsZSA9IHRoaXMsXG4gICAgICAgIHN0YXRlID0gY29tcHV0ZWRPYnNlcnZhYmxlW2NvbXB1dGVkU3RhdGVdO1xuICAgICAgaWYgKCFzdGF0ZS5pc0Rpc3Bvc2VkICYmIHN0YXRlLmlzU2xlZXBpbmcgJiYgZXZlbnQgPT09ICdjaGFuZ2UnKSB7XG4gICAgICAgIHN0YXRlLmlzU2xlZXBpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmlzU3RhbGUgfHwgY29tcHV0ZWRPYnNlcnZhYmxlLmhhdmVEZXBlbmRlbmNpZXNDaGFuZ2VkKCkpIHtcbiAgICAgICAgICBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcgPSBudWxsO1xuICAgICAgICAgIHN0YXRlLmRlcGVuZGVuY2llc0NvdW50ID0gMDtcbiAgICAgICAgICBpZiAoY29tcHV0ZWRPYnNlcnZhYmxlLmV2YWx1YXRlSW1tZWRpYXRlKCkpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS51cGRhdGVWZXJzaW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZpcnN0IHB1dCB0aGUgZGVwZW5kZW5jaWVzIGluIG9yZGVyXG4gICAgICAgICAgdmFyIGRlcGVuZGVuY2llc09yZGVyID0gW107XG4gICAgICAgICAgb2JqZWN0Rm9yRWFjaChzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcsIGZ1bmN0aW9uIChpZCwgZGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzT3JkZXJbZGVwZW5kZW5jeS5fb3JkZXJdID0gaWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAvLyBOZXh0LCBzdWJzY3JpYmUgdG8gZWFjaCBvbmVcbiAgICAgICAgICBhcnJheUZvckVhY2goZGVwZW5kZW5jaWVzT3JkZXIsIGZ1bmN0aW9uIChpZCwgb3JkZXIpIHtcbiAgICAgICAgICAgIHZhciBkZXBlbmRlbmN5ID0gc3RhdGUuZGVwZW5kZW5jeVRyYWNraW5nW2lkXSxcbiAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gY29tcHV0ZWRPYnNlcnZhYmxlLnN1YnNjcmliZVRvRGVwZW5kZW5jeShkZXBlbmRlbmN5Ll90YXJnZXQpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLl9vcmRlciA9IG9yZGVyO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLl92ZXJzaW9uID0gZGVwZW5kZW5jeS5fdmVyc2lvbjtcbiAgICAgICAgICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBXYWtpbmcgZGVwZW5kZW5jaWVzIG1heSBoYXZlIHRyaWdnZXJlZCBlZmZlY3RzXG4gICAgICAgICAgaWYgKGNvbXB1dGVkT2JzZXJ2YWJsZS5oYXZlRGVwZW5kZW5jaWVzQ2hhbmdlZCgpKSB7XG4gICAgICAgICAgICBpZiAoY29tcHV0ZWRPYnNlcnZhYmxlLmV2YWx1YXRlSW1tZWRpYXRlKCkpIHtcbiAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLnVwZGF0ZVZlcnNpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXRlLmlzRGlzcG9zZWQpIHsgICAgIC8vIHRlc3Qgc2luY2UgZXZhbHVhdGluZyBjb3VsZCB0cmlnZ2VyIGRpc3Bvc2FsXG4gICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLm5vdGlmeVN1YnNjcmliZXJzKHN0YXRlLmxhdGVzdFZhbHVlLCAnYXdha2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmUgKGV2ZW50KSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW2NvbXB1dGVkU3RhdGVdO1xuICAgICAgaWYgKCFzdGF0ZS5pc0Rpc3Bvc2VkICYmIGV2ZW50ID09PSAnY2hhbmdlJyAmJiAhdGhpcy5oYXNTdWJzY3JpcHRpb25zRm9yRXZlbnQoJ2NoYW5nZScpKSB7XG4gICAgICAgIG9iamVjdEZvckVhY2goc3RhdGUuZGVwZW5kZW5jeVRyYWNraW5nLCBmdW5jdGlvbiAoaWQsIGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICBpZiAoZGVwZW5kZW5jeS5kaXNwb3NlKSB7XG4gICAgICAgICAgICBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmdbaWRdID0ge1xuICAgICAgICAgICAgICBfdGFyZ2V0OiBkZXBlbmRlbmN5Ll90YXJnZXQsXG4gICAgICAgICAgICAgIF9vcmRlcjogZGVwZW5kZW5jeS5fb3JkZXIsXG4gICAgICAgICAgICAgIF92ZXJzaW9uOiBkZXBlbmRlbmN5Ll92ZXJzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVwZW5kZW5jeS5kaXNwb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUuaXNTbGVlcGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnModW5kZWZpbmVkLCAnYXNsZWVwJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRWZXJzaW9uICgpIHtcbiAgICAgICAgICAvLyBCZWNhdXNlIGEgcHVyZSBjb21wdXRlZCBpcyBub3QgYXV0b21hdGljYWxseSB1cGRhdGVkIHdoaWxlIGl0IGlzIHNsZWVwaW5nLCB3ZSBjYW4ndFxuICAgICAgICAgIC8vIHNpbXBseSByZXR1cm4gdGhlIHZlcnNpb24gbnVtYmVyLiBJbnN0ZWFkLCB3ZSBjaGVjayBpZiBhbnkgb2YgdGhlIGRlcGVuZGVuY2llcyBoYXZlXG4gICAgICAgICAgLy8gY2hhbmdlZCBhbmQgY29uZGl0aW9uYWxseSByZS1ldmFsdWF0ZSB0aGUgY29tcHV0ZWQgb2JzZXJ2YWJsZS5cbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbY29tcHV0ZWRTdGF0ZV07XG4gICAgICBpZiAoc3RhdGUuaXNTbGVlcGluZyAmJiAoc3RhdGUuaXNTdGFsZSB8fCB0aGlzLmhhdmVEZXBlbmRlbmNpZXNDaGFuZ2VkKCkpKSB7XG4gICAgICAgIHRoaXMuZXZhbHVhdGVJbW1lZGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWJzY3JpYmFibGUuZm4uZ2V0VmVyc2lvbi5jYWxsKHRoaXMpXG4gICAgfVxuICB9O1xuXG4gIHZhciBkZWZlckV2YWx1YXRpb25PdmVycmlkZXMgPSB7XG4gICAgYmVmb3JlU3Vic2NyaXB0aW9uQWRkIChldmVudCkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCBmb3JjZSBhIGNvbXB1dGVkIHdpdGggZGVmZXJFdmFsdWF0aW9uIHRvIGV2YWx1YXRlIHdoZW4gdGhlIGZpcnN0IHN1YnNjcmlwdGlvbiBpcyByZWdpc3RlcmVkLlxuICAgICAgaWYgKGV2ZW50ID09PSAnY2hhbmdlJyB8fCBldmVudCA9PT0gJ2JlZm9yZUNoYW5nZScpIHtcbiAgICAgICAgdGhpcy5wZWVrKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjb21wdXRlZC5mbiwgc3Vic2NyaWJhYmxlLmZuKTtcblxuICAvLyBTZXQgdGhlIHByb3RvIHZhbHVlcyBmb3Iga28uY29tcHV0ZWRcbiAgdmFyIHByb3RvUHJvcCA9IG9ic2VydmFibGUucHJvdG9Qcm9wZXJ0eTsgLy8gPT0gXCJfX2tvX3Byb3RvX19cIlxuICBjb21wdXRlZC5mbltwcm90b1Byb3BdID0gY29tcHV0ZWQ7XG5cbiAgLyogVGhpcyBpcyB1c2VkIGJ5IGtvLmlzT2JzZXJ2YWJsZSAqL1xuICBvYnNlcnZhYmxlLm9ic2VydmFibGVQcm90b3R5cGVzLmFkZChjb21wdXRlZCk7XG5cbiAgZnVuY3Rpb24gaXNDb21wdXRlZCAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBpbnN0YW5jZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZVtwcm90b1Byb3BdID09PSBjb21wdXRlZClcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUHVyZUNvbXB1dGVkIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpc0NvbXB1dGVkKGluc3RhbmNlKSAmJiBpbnN0YW5jZVtjb21wdXRlZFN0YXRlXSAmJiBpbnN0YW5jZVtjb21wdXRlZFN0YXRlXS5wdXJlXG4gIH1cblxuICBmdW5jdGlvbiBwdXJlQ29tcHV0ZWQgKGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zLCBldmFsdWF0b3JGdW5jdGlvblRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjb21wdXRlZChldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucywgZXZhbHVhdG9yRnVuY3Rpb25UYXJnZXQsIHsncHVyZSc6IHRydWV9KVxuICAgIH0gZWxzZSB7XG4gICAgICBldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucyA9IGV4dGVuZCh7fSwgZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMpOyAgIC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBwYXJhbWV0ZXIgb2JqZWN0XG4gICAgICBldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucy5wdXJlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjb21wdXRlZChldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucywgZXZhbHVhdG9yRnVuY3Rpb25UYXJnZXQpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGhyb3R0bGVFeHRlbmRlciAodGFyZ2V0LCB0aW1lb3V0KSB7XG4gICAgICAvLyBUaHJvdHRsaW5nIG1lYW5zIHR3byB0aGluZ3M6XG5cbiAgICAgIC8vICgxKSBGb3IgZGVwZW5kZW50IG9ic2VydmFibGVzLCB3ZSB0aHJvdHRsZSAqZXZhbHVhdGlvbnMqIHNvIHRoYXQsIG5vIG1hdHRlciBob3cgZmFzdCBpdHMgZGVwZW5kZW5jaWVzXG4gICAgICAvLyAgICAgbm90aWZ5IHVwZGF0ZXMsIHRoZSB0YXJnZXQgZG9lc24ndCByZS1ldmFsdWF0ZSAoYW5kIGhlbmNlIGRvZXNuJ3Qgbm90aWZ5KSBmYXN0ZXIgdGhhbiBhIGNlcnRhaW4gcmF0ZVxuICAgIHRhcmdldC50aHJvdHRsZUV2YWx1YXRpb24gPSB0aW1lb3V0O1xuXG4gICAgICAvLyAoMikgRm9yIHdyaXRhYmxlIHRhcmdldHMgKG9ic2VydmFibGVzLCBvciB3cml0YWJsZSBkZXBlbmRlbnQgb2JzZXJ2YWJsZXMpLCB3ZSB0aHJvdHRsZSAqd3JpdGVzKlxuICAgICAgLy8gICAgIHNvIHRoZSB0YXJnZXQgY2Fubm90IGNoYW5nZSB2YWx1ZSBzeW5jaHJvbm91c2x5IG9yIGZhc3RlciB0aGFuIGEgY2VydGFpbiByYXRlXG4gICAgdmFyIHdyaXRlVGltZW91dEluc3RhbmNlID0gbnVsbDtcbiAgICByZXR1cm4gY29tcHV0ZWQoe1xuICAgICAgcmVhZDogdGFyZ2V0LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQod3JpdGVUaW1lb3V0SW5zdGFuY2UpO1xuICAgICAgICB3cml0ZVRpbWVvdXRJbnN0YW5jZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldCh2YWx1ZSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBleHRlbmRlcnMudGhyb3R0bGUgPSB0aHJvdHRsZUV4dGVuZGVyO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gRVNcbiAgICovXG5cbiAgY29uc3QgUFJPWFlfU1lNID0gU3ltYm9sKCdLbm9ja291dCBQcm94aWVkIE9iamVjdCcpO1xuICBjb25zdCBNSVJST1JfU1lNID0gU3ltYm9sKCdLbm9ja291dCBQcm94aWVkIE9ic2VydmFibGVzJyk7XG5cbiAgZnVuY3Rpb24gbWFrZUNvbXB1dGVkIChwcm94eSwgZm4pIHtcbiAgICByZXR1cm4gY29tcHV0ZWQoe1xuICAgICAgb3duZXI6IHByb3h5LFxuICAgICAgcmVhZDogZm4sXG4gICAgICB3cml0ZTogZm4sXG4gICAgICBwdXJlOiAncHVyZScgaW4gZm4gPyBmbi5wdXJlIDogdHJ1ZSxcbiAgICAgIGRlZmVyRXZhbHVhdGlvbjogJ2RlZmVyRXZhbHVhdGlvbicgaW4gZm4gPyBmbi5kZWZlckV2YWx1YXRpb24gOiB0cnVlXG4gICAgfSkuZXh0ZW5kKHsgZGVmZXJyZWQ6IHRydWUgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldE9yQ3JlYXRlIChtaXJyb3IsIHByb3AsIHZhbHVlLCBwcm94eSkge1xuICAgIGlmICghbWlycm9yW3Byb3BdKSB7XG4gICAgICBjb25zdCBjdHIgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IG9ic2VydmFibGVBcnJheVxuICAgICAgICA6IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IG1ha2VDb21wdXRlZC5iaW5kKG51bGwsIHByb3h5KVxuICAgICAgICA6IG9ic2VydmFibGU7XG4gICAgICBtaXJyb3JbcHJvcF0gPSBjdHIodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaXJyb3JbcHJvcF0odmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnbk9yVXBkYXRlKG1pcnJvciwgb2JqZWN0LCBwcm94eSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iamVjdCkpIHtcbiAgICAgIHNldE9yQ3JlYXRlKG1pcnJvciwga2V5LCBvYmplY3Rba2V5XSwgcHJveHkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0XG4gIH1cblxuICBmdW5jdGlvbiBwcm94eSAob2JqZWN0KSB7XG4gICAgY29uc3QgbWlycm9yID0geyBbUFJPWFlfU1lNXTogb2JqZWN0IH07XG4gICAgbWlycm9yW01JUlJPUl9TWU1dID0gbWlycm9yO1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGZ1bmN0aW9uICgpIHt9LCB7XG4gICAgICBoYXMgKHRhcmdldCwgcHJvcCkgeyByZXR1cm4gcHJvcCBpbiBtaXJyb3IgfSxcbiAgICAgIGdldCAodGFyZ2V0LCBwcm9wKSB7IHJldHVybiB1bndyYXAobWlycm9yW3Byb3BdKSB9LFxuICAgICAgc2V0ICh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICBzZXRPckNyZWF0ZShtaXJyb3IsIHByb3AsIHZhbHVlLCBwcm94eSk7XG4gICAgICAgIG9iamVjdFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSxcbiAgICAgIGRlbGV0ZVByb3BlcnR5IChwcm9wZXJ0eSkge1xuICAgICAgICBkZWxldGUgbWlycm9yW3Byb3BlcnR5XTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZSBvYmplY3RbcHJvcGVydHldXG4gICAgICB9LFxuICAgICAgYXBwbHkgKHRhcmdldCwgdGhpc0FyZywgW3Byb3BzXSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBhc3NpZ25PclVwZGF0ZShtaXJyb3IsIHByb3BzLCBwcm94eSk7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqZWN0LCBwcm9wcylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0XG4gICAgICB9LFxuICAgICAgZ2V0UHJvdG90eXBlT2YgKCkgeyByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkgfSxcbiAgICAgIHNldFByb3RvdHlwZU9mICh0YXJnZXQsIHByb3RvKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqZWN0LCBwcm90bykgfSxcbiAgICAgIGRlZmluZVByb3BlcnR5ICh0YXJnZXQsIHByb3AsIGRlc2MpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3AsIGRlc2MpIH0sXG4gICAgICBwcmV2ZW50RXh0ZW5zaW9ucyAoKSB7IHJldHVybiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMob2JqZWN0KSB9LFxuICAgICAgaXNFeHRlbnNpYmxlICgpIHsgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUob2JqZWN0KSB9LFxuICAgICAgb3duS2V5cyAoKSB7XG4gICAgICAgIHJldHVybiBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSxcbiAgICAgICAgICAgICAgICAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCldXG4gICAgICB9XG4gICAgfSk7XG4gICAgYXNzaWduT3JVcGRhdGUobWlycm9yLCBvYmplY3QsIHByb3h5KTtcbiAgICByZXR1cm4gcHJveHlcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9ic2VydmFibGUgKHByb3hpZWQsIHByb3ApIHsgcmV0dXJuIHByb3hpZWRbTUlSUk9SX1NZTV1bcHJvcF0gfVxuICBmdW5jdGlvbiBwZWVrJDEgKHByb3hpZWQsIHByb3ApIHsgcmV0dXJuIGdldE9ic2VydmFibGUocHJveGllZCwgcHJvcCkucGVlaygpIH1cbiAgZnVuY3Rpb24gaXNQcm94aWVkIChwcm94aWVkKSB7IHJldHVybiBQUk9YWV9TWU0gaW4gcHJveGllZCB9XG5cbiAgT2JqZWN0LmFzc2lnbihwcm94eSwgeyBnZXRPYnNlcnZhYmxlLCBwZWVrOiBwZWVrJDEsIGlzUHJveGllZCB9KTtcblxuICBmdW5jdGlvbiBrb3doZW4gKHByZWRpY2F0ZSwgY29udGV4dCwgcmVzb2x2ZSkge1xuICAgIGNvbnN0IG9ic2VydmFibGUgPSBwdXJlQ29tcHV0ZWQocHJlZGljYXRlLCBjb250ZXh0KS5leHRlbmQoe25vdGlmeTogJ2Fsd2F5cyd9KTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gSW4gY2FzZSB0aGUgaW5pdGlhbCB2YWx1ZSBpcyB0cnVlLCBwcm9jZXNzIGl0IHJpZ2h0IGF3YXlcbiAgICBvYnNlcnZhYmxlLm5vdGlmeVN1YnNjcmliZXJzKG9ic2VydmFibGUucGVlaygpKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uXG4gIH1cblxuICBmdW5jdGlvbiB3aGVuIChwcmVkaWNhdGUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgY29uc3Qgd2hlbkZuID0ga293aGVuLmJpbmQobnVsbCwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gY2FsbGJhY2sgPyB3aGVuRm4oY2FsbGJhY2suYmluZChjb250ZXh0KSkgOiBuZXcgUHJvbWlzZSh3aGVuRm4pXG4gIH1cblxuICAvL1xuXG4gIGNvbnN0IFNVQlNDUklQVElPTlMgPSBjcmVhdGVTeW1ib2xPclN0cmluZygnTGlmZUN5Y2xlIFN1YnNjcmlwdGlvbnMgTGlzdCcpO1xuICBjb25zdCBBTkNIT1JfTk9ERSA9IGNyZWF0ZVN5bWJvbE9yU3RyaW5nKCdMaWZlQ3ljbGUgQW5jaG9yIE5vZGUnKTtcblxuICBjbGFzcyBMaWZlQ3ljbGUge1xuICAgIC8vIE5PVEU6IEZvciBtb3JlIGFkdmFuY2VkIGludGVncmF0aW9uIGFzIGFuIEVTNiBtaXhpbiwgc2VlIGUuZy46XG4gICAgLy8gaHR0cDovL2p1c3RpbmZhZ25hbmkuY29tLzIwMTUvMTIvMjEvcmVhbC1taXhpbnMtd2l0aC1qYXZhc2NyaXB0LWNsYXNzZXMvXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBMaWZlQ3ljbGUgY2xhc3MgdG8gdGhlIHRhcmdldCAob3IgaXRzIHByb3RvdHlwZSlcbiAgICAgKlxuICAgICAqIE5PVEU6IGdldE93blByb3BlcnR5TmFtZXMgaXMgbmVlZGVkIHRvIGNvcHkgdGhlIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgc3RhdGljIG1peEludG8gKENvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgfHwgQ29uc3RydWN0b3I7XG4gICAgICBjb25zdCBtaXhpbiA9IExpZmVDeWNsZS5wcm90b3R5cGU7XG4gICAgICBmb3IgKGxldCBwcm9wIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG1peGluKSkge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSBtaXhpbltwcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdWJzY3JpYmUgKG9ic2VydmFibGUsIGFjdGlvbiwgc3Vic2NyaXB0aW9uVHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnKSB7IGFjdGlvbiA9IHRoaXNbYWN0aW9uXTsgfVxuICAgICAgdGhpcy5hZGREaXNwb3NhYmxlKG9ic2VydmFibGUuc3Vic2NyaWJlKGFjdGlvbiwgdGhpcywgc3Vic2NyaXB0aW9uVHlwZSkpO1xuICAgIH1cblxuICAgIGNvbXB1dGVkIChwYXJhbXMpIHtcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJhbXMgPSB7IHJlYWQ6IHRoaXNbcGFyYW1zXSwgd3JpdGU6IHRoaXNbcGFyYW1zXSB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7IG93bmVyOiB0aGlzIH0sIHBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgICAgIGlmIChwcm90byAmJiBwcm90b1twYXJhbXMubmFtZV0gPT09IHBhcmFtcykgeyBwYXJhbXMgPSBwYXJhbXMuYmluZCh0aGlzKTsgfVxuICAgICAgICBwYXJhbXMgPSB7IHJlYWQ6IHBhcmFtcywgd3JpdGU6IHBhcmFtcyB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaWZlQ3ljbGU6OmNvbXB1dGVkIG5vdCBnaXZlbiBhIHZhbGlkIHR5cGUuJylcbiAgICAgIH1cblxuICAgICAgcGFyYW1zLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCA9IHRoaXNbQU5DSE9SX05PREVdO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkRGlzcG9zYWJsZShjb21wdXRlZChwYXJhbXMpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGdpdmVuIG9yIGFuY2hvcmVkIG5vZGUuXG4gICAgICogQHBhcmFtIHtub2RlfSBbbm9kZV0gKG9wdGlvbmFsKSBUaGUgdGFyZ2V0IG5vZGUgKG90aGVyd2lzZSB0aGUgYW5jaG9yZWQgbm9kZSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIEV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufHN0cmluZ30gW2FjdGlvbl0gRWl0aGVyIGNhbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIG9yIGB0aGlzW2FjdGlvbl1gXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAob3B0aW9uYWwpIFBhc3NlZCBhcyBgb3B0aW9uc2AgdG8gYG5vZGUuYWRkRXZlbnRMaXN0ZW5lcmBcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyICguLi5hcmdzKSB7XG4gICAgICBjb25zdCBub2RlID0gYXJnc1swXS5ub2RlVHlwZSA/IGFyZ3Muc2hpZnQoKSA6IHRoaXNbQU5DSE9SX05PREVdO1xuICAgICAgY29uc3QgW3R5cGUsIGFjdCwgb3B0aW9ucyQkMV0gPSBhcmdzO1xuICAgICAgY29uc3QgaGFuZGxlciA9IHR5cGVvZiBhY3QgPT09ICdzdHJpbmcnID8gdGhpc1thY3RdLmJpbmQodGhpcykgOiBhY3Q7XG4gICAgICB0aGlzLl9fYWRkRXZlbnRMaXN0ZW5lcihub2RlLCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zJCQxKTtcbiAgICB9XG5cbiAgICBfX2FkZEV2ZW50TGlzdGVuZXIgKG5vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyQkMSkge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyQkMSk7XG4gICAgICBmdW5jdGlvbiBkaXNwb3NlICgpIHsgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlcik7IH1cbiAgICAgIGFkZERpc3Bvc2VDYWxsYmFjayhub2RlLCBkaXNwb3NlKTtcbiAgICAgIHRoaXMuYWRkRGlzcG9zYWJsZSh7IGRpc3Bvc2UgfSk7XG4gICAgfVxuXG4gICAgYW5jaG9yVG8gKG5vZGVPckxpZmVDeWNsZSkge1xuICAgICAgaWYgKCdhZGREaXNwb3NhYmxlJyBpbiBub2RlT3JMaWZlQ3ljbGUpIHtcbiAgICAgICAgbm9kZU9yTGlmZUN5Y2xlLmFkZERpc3Bvc2FibGUodGhpcyk7XG4gICAgICAgIHRoaXNbQU5DSE9SX05PREVdID0gbnVsbDsgLy8gcmUtYW5jaG9yIG9uIGBhbmNob3JUb2AgY2FsbHNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbQU5DSE9SX05PREVdID0gbm9kZU9yTGlmZUN5Y2xlO1xuICAgICAgICBhZGREaXNwb3NlQ2FsbGJhY2sobm9kZU9yTGlmZUN5Y2xlLCAoKSA9PiB0aGlzW0FOQ0hPUl9OT0RFXSA9PT0gbm9kZU9yTGlmZUN5Y2xlICYmIHRoaXMuZGlzcG9zZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNwb3NlICgpIHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzW1NVQlNDUklQVElPTlNdIHx8IFtdO1xuICAgICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHMgPT4gcy5kaXNwb3NlKCkpO1xuICAgICAgdGhpc1tTVUJTQ1JJUFRJT05TXSA9IFtdO1xuICAgICAgdGhpc1tBTkNIT1JfTk9ERV0gPSBudWxsO1xuICAgIH1cblxuICAgIGFkZERpc3Bvc2FibGUgKHN1YnNjcmlwdGlvbikge1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRoaXNbU1VCU0NSSVBUSU9OU10gfHwgW107XG4gICAgICBpZiAoIXRoaXNbU1VCU0NSSVBUSU9OU10pIHsgdGhpc1tTVUJTQ1JJUFRJT05TXSA9IHN1YnNjcmlwdGlvbnM7IH1cbiAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uLmRpc3Bvc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaWZlY3ljbGU6OmFkZERpc3Bvc2FibGUgYXJndW1lbnQgbWlzc2luZyBgZGlzcG9zZWAuJylcbiAgICAgIH1cbiAgICAgIHN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvblxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNvbnRleHRBbmNlc3RvckJpbmRpbmdJbmZvID0gU3ltYm9sKCdfYW5jZXN0b3JCaW5kaW5nSW5mbycpO1xuICBjb25zdCBib3VuZEVsZW1lbnREb21EYXRhS2V5ID0gbmV4dEtleSgpO1xuXG4gIGNvbnN0IGJpbmRpbmdFdmVudCA9IHtcbiAgICBjaGlsZHJlbkNvbXBsZXRlOiAnY2hpbGRyZW5Db21wbGV0ZScsXG4gICAgZGVzY2VuZGFudHNDb21wbGV0ZTogJ2Rlc2NlbmRhbnRzQ29tcGxldGUnLFxuXG4gICAgc3Vic2NyaWJlIChub2RlLCBldmVudCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGJpbmRpbmdJbmZvID0gZ2V0T3JTZXQobm9kZSwgYm91bmRFbGVtZW50RG9tRGF0YUtleSwge30pO1xuICAgICAgaWYgKCFiaW5kaW5nSW5mby5ldmVudFN1YnNjcmliYWJsZSkge1xuICAgICAgICBiaW5kaW5nSW5mby5ldmVudFN1YnNjcmliYWJsZSA9IG5ldyBzdWJzY3JpYmFibGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5kaW5nSW5mby5ldmVudFN1YnNjcmliYWJsZS5zdWJzY3JpYmUoY2FsbGJhY2ssIGNvbnRleHQsIGV2ZW50KVxuICAgIH0sXG5cbiAgICBub3RpZnkgKG5vZGUsIGV2ZW50KSB7XG4gICAgICBjb25zdCBiaW5kaW5nSW5mbyA9IGdldChub2RlLCBib3VuZEVsZW1lbnREb21EYXRhS2V5KTtcbiAgICAgIGlmIChiaW5kaW5nSW5mbykge1xuICAgICAgICBpZiAoYmluZGluZ0luZm8uZXZlbnRTdWJzY3JpYmFibGUpIHtcbiAgICAgICAgICBiaW5kaW5nSW5mby5ldmVudFN1YnNjcmliYWJsZS5ub3RpZnlTdWJzY3JpYmVycyhub2RlLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgYm91bmRFbGVtZW50RG9tRGF0YUtleSQxID0gbmV4dEtleSgpO1xuXG4gIGNvbnN0IGNvbnRleHRTdWJzY3JpYmVTeW1ib2wgPSBTeW1ib2woJ0tub2Nrb3V0IENvbnRleHQgU3Vic2NyaXB0aW9uJyk7XG5cbiAgLy8gVW5pcXVlIHN0dWIgdG8gaW5kaWNhdGUgaW5oZXJpdGFuY2UuXG4gIGNvbnN0IGluaGVyaXRQYXJlbnRJbmRpY2F0b3IgPSBTeW1ib2woJ0tub2Nrb3V0IFBhcmVudCBJbmRpY2F0b3InKTtcblxuICAvLyBUaGUgYmluZGluZ0NvbnRleHQgY29uc3RydWN0b3IgaXMgb25seSBjYWxsZWQgZGlyZWN0bHkgdG8gY3JlYXRlIHRoZSByb290IGNvbnRleHQuIEZvciBjaGlsZFxuICAvLyBjb250ZXh0cywgdXNlIGJpbmRpbmdDb250ZXh0LmNyZWF0ZUNoaWxkQ29udGV4dCBvciBiaW5kaW5nQ29udGV4dC5leHRlbmQuXG4gIGZ1bmN0aW9uIGJpbmRpbmdDb250ZXh0IChkYXRhSXRlbU9yQWNjZXNzb3IsIHBhcmVudENvbnRleHQsIGRhdGFJdGVtQWxpYXMsIGV4dGVuZENhbGxiYWNrLCBzZXR0aW5ncykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHNob3VsZEluaGVyaXREYXRhID0gZGF0YUl0ZW1PckFjY2Vzc29yID09PSBpbmhlcml0UGFyZW50SW5kaWNhdG9yO1xuICAgIGNvbnN0IHJlYWxEYXRhSXRlbU9yQWNjZXNzb3IgPSBzaG91bGRJbmhlcml0RGF0YSA/IHVuZGVmaW5lZCA6IGRhdGFJdGVtT3JBY2Nlc3NvcjtcbiAgICBjb25zdCBpc0Z1bmMgPSB0eXBlb2YgcmVhbERhdGFJdGVtT3JBY2Nlc3NvciA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYnNlcnZhYmxlKHJlYWxEYXRhSXRlbU9yQWNjZXNzb3IpO1xuXG4gICAgLy8gRXhwb3J0ICdrbycgaW4gdGhlIGJpbmRpbmcgY29udGV4dCBzbyBpdCB3aWxsIGJlIGF2YWlsYWJsZSBpbiBiaW5kaW5ncyBhbmQgdGVtcGxhdGVzXG4gICAgLy8gZXZlbiBpZiAna28nIGlzbid0IGV4cG9ydGVkIGFzIGEgZ2xvYmFsLCBzdWNoIGFzIHdoZW4gdXNpbmcgYW4gQU1EIGxvYWRlci5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1N0ZXZlU2FuZGVyc29uL2tub2Nrb3V0L2lzc3Vlcy80OTBcbiAgICBzZWxmLmtvID0gb3B0aW9ucy5rbm9ja291dEluc3RhbmNlO1xuICAgIGxldCBzdWJzY3JpYmFibGUkJDE7XG5cbiAgICAgIC8vIFRoZSBiaW5kaW5nIGNvbnRleHQgb2JqZWN0IGluY2x1ZGVzIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciB0aGUgY3VycmVudCwgcGFyZW50LCBhbmQgcm9vdCB2aWV3IG1vZGVscy5cbiAgICAgIC8vIElmIGEgdmlldyBtb2RlbCBpcyBhY3R1YWxseSBzdG9yZWQgaW4gYW4gb2JzZXJ2YWJsZSwgdGhlIGNvcnJlc3BvbmRpbmcgYmluZGluZyBjb250ZXh0IG9iamVjdCwgYW5kXG4gICAgICAvLyBhbnkgY2hpbGQgY29udGV4dHMsIG11c3QgYmUgdXBkYXRlZCB3aGVuIHRoZSB2aWV3IG1vZGVsIGlzIGNoYW5nZWQuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ29udGV4dCAoKSB7XG4gICAgICAgICAgLy8gTW9zdCBvZiB0aGUgdGltZSwgdGhlIGNvbnRleHQgd2lsbCBkaXJlY3RseSBnZXQgYSB2aWV3IG1vZGVsIG9iamVjdCwgYnV0IGlmIGEgZnVuY3Rpb24gaXMgZ2l2ZW4sXG4gICAgICAgICAgLy8gd2UgY2FsbCB0aGUgZnVuY3Rpb24gdG8gcmV0cmlldmUgdGhlIHZpZXcgbW9kZWwuIElmIHRoZSBmdW5jdGlvbiBhY2Nlc3NlcyBhbnkgb2JzZXJ2YWJsZXMgb3IgcmV0dXJuc1xuICAgICAgICAgIC8vIGFuIG9ic2VydmFibGUsIHRoZSBkZXBlbmRlbmN5IGlzIHRyYWNrZWQsIGFuZCB0aG9zZSBvYnNlcnZhYmxlcyBjYW4gbGF0ZXIgY2F1c2UgdGhlIGJpbmRpbmdcbiAgICAgICAgICAvLyBjb250ZXh0IHRvIGJlIHVwZGF0ZWQuXG4gICAgICBjb25zdCBkYXRhSXRlbU9yT2JzZXJ2YWJsZSA9IGlzRnVuYyA/IHJlYWxEYXRhSXRlbU9yQWNjZXNzb3IoKSA6IHJlYWxEYXRhSXRlbU9yQWNjZXNzb3I7XG4gICAgICBsZXQgZGF0YUl0ZW0gPSB1bndyYXAoZGF0YUl0ZW1Pck9ic2VydmFibGUpO1xuXG4gICAgICBpZiAocGFyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgICAvLyBXaGVuIGEgXCJwYXJlbnRcIiBjb250ZXh0IGlzIGdpdmVuLCByZWdpc3RlciBhIGRlcGVuZGVuY3kgb24gdGhlIHBhcmVudCBjb250ZXh0LiBUaHVzIHdoZW5ldmVyIHRoZVxuICAgICAgICAgICAgICAvLyBwYXJlbnQgY29udGV4dCBpcyB1cGRhdGVkLCB0aGlzIGNvbnRleHQgd2lsbCBhbHNvIGJlIHVwZGF0ZWQuXG4gICAgICAgIGlmIChwYXJlbnRDb250ZXh0W2NvbnRleHRTdWJzY3JpYmVTeW1ib2xdKSB7XG4gICAgICAgICAgcGFyZW50Q29udGV4dFtjb250ZXh0U3Vic2NyaWJlU3ltYm9sXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQ29weSAkcm9vdCBhbmQgYW55IGN1c3RvbSBwcm9wZXJ0aWVzIGZyb20gdGhlIHBhcmVudCBjb250ZXh0XG4gICAgICAgIGV4dGVuZChzZWxmLCBwYXJlbnRDb250ZXh0KTtcblxuICAgICAgICAgLy8gQ29weSBTeW1ib2wgcHJvcGVydGllc1xuICAgICAgICBpZiAoY29udGV4dEFuY2VzdG9yQmluZGluZ0luZm8gaW4gcGFyZW50Q29udGV4dCkge1xuICAgICAgICAgIHNlbGZbY29udGV4dEFuY2VzdG9yQmluZGluZ0luZm9dID0gcGFyZW50Q29udGV4dFtjb250ZXh0QW5jZXN0b3JCaW5kaW5nSW5mb107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuJHBhcmVudHMgPSBbXTtcbiAgICAgICAgc2VsZi4kcm9vdCA9IGRhdGFJdGVtO1xuICAgICAgfVxuXG4gICAgICBzZWxmW2NvbnRleHRTdWJzY3JpYmVTeW1ib2xdID0gc3Vic2NyaWJhYmxlJCQxO1xuXG4gICAgICBpZiAoc2hvdWxkSW5oZXJpdERhdGEpIHtcbiAgICAgICAgZGF0YUl0ZW0gPSBzZWxmLiRkYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi4kcmF3RGF0YSA9IGRhdGFJdGVtT3JPYnNlcnZhYmxlO1xuICAgICAgICBzZWxmLiRkYXRhID0gZGF0YUl0ZW07XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhSXRlbUFsaWFzKSB7IHNlbGZbZGF0YUl0ZW1BbGlhc10gPSBkYXRhSXRlbTsgfVxuXG4gICAgICAgICAgLy8gVGhlIGV4dGVuZENhbGxiYWNrIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgYSBjaGlsZCBjb250ZXh0IG9yIGV4dGVuZGluZyBhIGNvbnRleHQuXG4gICAgICAgICAgLy8gSXQgaGFuZGxlcyB0aGUgc3BlY2lmaWMgYWN0aW9ucyBuZWVkZWQgdG8gZmluaXNoIHNldHRpbmcgdXAgdGhlIGJpbmRpbmcgY29udGV4dC4gQWN0aW9ucyBpbiB0aGlzXG4gICAgICAgICAgLy8gZnVuY3Rpb24gY291bGQgYWxzbyBhZGQgZGVwZW5kZW5jaWVzIHRvIHRoaXMgYmluZGluZyBjb250ZXh0LlxuICAgICAgaWYgKGV4dGVuZENhbGxiYWNrKSB7IGV4dGVuZENhbGxiYWNrKHNlbGYsIHBhcmVudENvbnRleHQsIGRhdGFJdGVtKTsgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZGF0YVxuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5leHBvcnREZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAvLyBUaGUgXCJleHBvcnREZXBlbmRlbmNpZXNcIiBvcHRpb24gbWVhbnMgdGhhdCB0aGUgY2FsbGluZyBjb2RlIHdpbGwgdHJhY2sgYW55IGRlcGVuZGVuY2llcyBhbmQgcmUtY3JlYXRlXG4gICAgICAgICAgLy8gdGhlIGJpbmRpbmcgY29udGV4dCB3aGVuIHRoZXkgY2hhbmdlLlxuICAgICAgdXBkYXRlQ29udGV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJzY3JpYmFibGUkJDEgPSBwdXJlQ29tcHV0ZWQodXBkYXRlQ29udGV4dCk7XG4gICAgICBzdWJzY3JpYmFibGUkJDEucGVlaygpO1xuXG4gICAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgYmluZGluZyBjb250ZXh0IGhhcyBiZWVuIGluaXRpYWxpemVkLCBhbmQgdGhlIFwic3Vic2NyaWJhYmxlXCIgY29tcHV0ZWQgb2JzZXJ2YWJsZSBpc1xuICAgICAgLy8gc3Vic2NyaWJlZCB0byBhbnkgb2JzZXJ2YWJsZXMgdGhhdCB3ZXJlIGFjY2Vzc2VkIGluIHRoZSBwcm9jZXNzLiBJZiB0aGVyZSBpcyBub3RoaW5nIHRvIHRyYWNrLCB0aGVcbiAgICAgIC8vIGNvbXB1dGVkIHdpbGwgYmUgaW5hY3RpdmUsIGFuZCB3ZSBjYW4gc2FmZWx5IHRocm93IGl0IGF3YXkuIElmIGl0J3MgYWN0aXZlLCB0aGUgY29tcHV0ZWQgaXMgc3RvcmVkIGluXG4gICAgICAvLyB0aGUgY29udGV4dCBvYmplY3QuXG4gICAgICBpZiAoc3Vic2NyaWJhYmxlJCQxLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgc2VsZltjb250ZXh0U3Vic2NyaWJlU3ltYm9sXSA9IHN1YnNjcmliYWJsZSQkMTtcblxuICAgICAgICAvLyBBbHdheXMgbm90aWZ5IGJlY2F1c2UgZXZlbiBpZiB0aGUgbW9kZWwgKCRkYXRhKSBoYXNuJ3QgY2hhbmdlZCwgb3RoZXIgY29udGV4dCBwcm9wZXJ0aWVzIG1pZ2h0IGhhdmUgY2hhbmdlZFxuICAgICAgICBzdWJzY3JpYmFibGUkJDFbJ2VxdWFsaXR5Q29tcGFyZXInXSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmW2NvbnRleHRTdWJzY3JpYmVTeW1ib2xdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24oYmluZGluZ0NvbnRleHQucHJvdG90eXBlLCB7XG5cbiAgICBsb29rdXAgKHRva2VuLCBnbG9iYWxzLCBub2RlKSB7XG4gICAgICAvLyBzaG9ydCBjaXJjdWl0c1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICckZWxlbWVudCc6IHJldHVybiBub2RlXG4gICAgICAgIGNhc2UgJyRjb250ZXh0JzogcmV0dXJuIHRoaXNcbiAgICAgICAgY2FzZSAndGhpcyc6IGNhc2UgJyRkYXRhJzogcmV0dXJuIHRoaXMuJGRhdGFcbiAgICAgIH1cbiAgICAgIGNvbnN0ICRkYXRhID0gdGhpcy4kZGF0YTtcbiAgICAgIC8vIGluc3RhbmNlb2YgT2JqZWN0IGNvdmVycyAxLiB7fSwgMi4gW10sIDMuIGZ1bmN0aW9uKCkge30sIDQuIG5ldyAqOyAgaXQgZXhjbHVkZXMgdW5kZWZpbmVkLCBudWxsLCBwcmltaXRpdmVzLlxuICAgICAgaWYgKCRkYXRhIGluc3RhbmNlb2YgT2JqZWN0ICYmIHRva2VuIGluICRkYXRhKSB7IHJldHVybiAkZGF0YVt0b2tlbl0gfVxuICAgICAgaWYgKHRva2VuIGluIHRoaXMpIHsgcmV0dXJuIHRoaXNbdG9rZW5dIH1cbiAgICAgIGlmICh0b2tlbiBpbiBnbG9iYWxzKSB7IHJldHVybiBnbG9iYWxzW3Rva2VuXSB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHZhcmlhYmxlIFwiJHt0b2tlbn1cIiB3YXMgbm90IGZvdW5kIG9uICRkYXRhLCAkY29udGV4dCwgb3IgZ2xvYmFscy5gKVxuICAgIH0sXG5cbiAgICAvLyBFeHRlbmQgdGhlIGJpbmRpbmcgY29udGV4dCBoaWVyYXJjaHkgd2l0aCBhIG5ldyB2aWV3IG1vZGVsIG9iamVjdC4gSWYgdGhlIHBhcmVudCBjb250ZXh0IGlzIHdhdGNoaW5nXG4gICAgLy8gYW55IG9ic2VydmFibGVzLCB0aGUgbmV3IGNoaWxkIGNvbnRleHQgd2lsbCBhdXRvbWF0aWNhbGx5IGdldCBhIGRlcGVuZGVuY3kgb24gdGhlIHBhcmVudCBjb250ZXh0LlxuICAgIC8vIEJ1dCB0aGlzIGRvZXMgbm90IG1lYW4gdGhhdCB0aGUgJGRhdGEgdmFsdWUgb2YgdGhlIGNoaWxkIGNvbnRleHQgd2lsbCBhbHNvIGdldCB1cGRhdGVkLiBJZiB0aGUgY2hpbGRcbiAgICAvLyB2aWV3IG1vZGVsIGFsc28gZGVwZW5kcyBvbiB0aGUgcGFyZW50IHZpZXcgbW9kZWwsIHlvdSBtdXN0IHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNvcnJlY3RcbiAgICAvLyB2aWV3IG1vZGVsIG9uIGVhY2ggdXBkYXRlLlxuICAgIGNyZWF0ZUNoaWxkQ29udGV4dCAoZGF0YUl0ZW1PckFjY2Vzc29yLCBkYXRhSXRlbUFsaWFzLCBleHRlbmRDYWxsYmFjaywgc2V0dGluZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgYmluZGluZ0NvbnRleHQoZGF0YUl0ZW1PckFjY2Vzc29yLCB0aGlzLCBkYXRhSXRlbUFsaWFzLCBmdW5jdGlvbiAoc2VsZiwgcGFyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBjb250ZXh0IGhpZXJhcmNoeSBieSBzZXR0aW5nIHRoZSBhcHByb3ByaWF0ZSBwb2ludGVyc1xuICAgICAgICBzZWxmLiRwYXJlbnRDb250ZXh0ID0gcGFyZW50Q29udGV4dDtcbiAgICAgICAgc2VsZi4kcGFyZW50ID0gcGFyZW50Q29udGV4dC4kZGF0YTtcbiAgICAgICAgc2VsZi4kcGFyZW50cyA9IChwYXJlbnRDb250ZXh0LiRwYXJlbnRzIHx8IFtdKS5zbGljZSgwKTtcbiAgICAgICAgc2VsZi4kcGFyZW50cy51bnNoaWZ0KHNlbGYuJHBhcmVudCk7XG4gICAgICAgIGlmIChleHRlbmRDYWxsYmFjaykgeyBleHRlbmRDYWxsYmFjayhzZWxmKTsgfVxuICAgICAgfSwgc2V0dGluZ3MpXG4gICAgfSxcblxuICAgIC8vIEV4dGVuZCB0aGUgYmluZGluZyBjb250ZXh0IHdpdGggbmV3IGN1c3RvbSBwcm9wZXJ0aWVzLiBUaGlzIGRvZXNuJ3QgY2hhbmdlIHRoZSBjb250ZXh0IGhpZXJhcmNoeS5cbiAgICAvLyBTaW1pbGFybHkgdG8gXCJjaGlsZFwiIGNvbnRleHRzLCBwcm92aWRlIGEgZnVuY3Rpb24gaGVyZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgY29ycmVjdCB2YWx1ZXMgYXJlIHNldFxuICAgIC8vIHdoZW4gYW4gb2JzZXJ2YWJsZSB2aWV3IG1vZGVsIGlzIHVwZGF0ZWQuXG4gICAgZXh0ZW5kIChwcm9wZXJ0aWVzKSB7XG4gICAgICAvLyBJZiB0aGUgcGFyZW50IGNvbnRleHQgcmVmZXJlbmNlcyBhbiBvYnNlcnZhYmxlIHZpZXcgbW9kZWwsIFwiX3N1YnNjcmliYWJsZVwiIHdpbGwgYWx3YXlzIGJlIHRoZVxuICAgICAgLy8gbGF0ZXN0IHZpZXcgbW9kZWwgb2JqZWN0LiBJZiBub3QsIFwiX3N1YnNjcmliYWJsZVwiIGlzbid0IHNldCwgYW5kIHdlIGNhbiB1c2UgdGhlIHN0YXRpYyBcIiRkYXRhXCIgdmFsdWUuXG4gICAgICByZXR1cm4gbmV3IGJpbmRpbmdDb250ZXh0KGluaGVyaXRQYXJlbnRJbmRpY2F0b3IsIHRoaXMsIG51bGwsIGZ1bmN0aW9uIChzZWxmLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgICAgIGV4dGVuZChzZWxmLCB0eXBlb2YgcHJvcGVydGllcyA9PT0gJ2Z1bmN0aW9uJyA/IHByb3BlcnRpZXMuY2FsbChzZWxmKSA6IHByb3BlcnRpZXMpO1xuICAgICAgfSlcbiAgICB9LFxuXG4gICAgY3JlYXRlU3RhdGljQ2hpbGRDb250ZXh0IChkYXRhSXRlbU9yQWNjZXNzb3IsIGRhdGFJdGVtQWxpYXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNoaWxkQ29udGV4dChkYXRhSXRlbU9yQWNjZXNzb3IsIGRhdGFJdGVtQWxpYXMsIG51bGwsIHsgJ2V4cG9ydERlcGVuZGVuY2llcyc6IHRydWUgfSlcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHN0b3JlZEJpbmRpbmdDb250ZXh0Rm9yTm9kZSAobm9kZSkge1xuICAgIGNvbnN0IGJpbmRpbmdJbmZvID0gZ2V0KG5vZGUsIGJvdW5kRWxlbWVudERvbURhdGFLZXkkMSk7XG4gICAgcmV0dXJuIGJpbmRpbmdJbmZvICYmIGJpbmRpbmdJbmZvLmNvbnRleHRcbiAgfVxuXG4gIC8vIFJldHJpZXZpbmcgYmluZGluZyBjb250ZXh0IGZyb20gYXJiaXRyYXJ5IG5vZGVzXG4gIGZ1bmN0aW9uIGNvbnRleHRGb3IgKG5vZGUpIHtcbiAgICAvLyBXZSBjYW4gb25seSBkbyBzb21ldGhpbmcgbWVhbmluZ2Z1bCBmb3IgZWxlbWVudHMgYW5kIGNvbW1lbnQgbm9kZXMgKGluIHBhcnRpY3VsYXIsIG5vdCB0ZXh0IG5vZGVzLCBhcyBJRSBjYW4ndCBzdG9yZSBkb21kYXRhIGZvciB0aGVtKVxuICAgIGlmIChub2RlICYmIChub2RlLm5vZGVUeXBlID09PSAxIHx8IG5vZGUubm9kZVR5cGUgPT09IDgpKSB7XG4gICAgICByZXR1cm4gc3RvcmVkQmluZGluZ0NvbnRleHRGb3JOb2RlKG5vZGUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGF0YUZvciAobm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gY29udGV4dEZvcihub2RlKTtcbiAgICByZXR1cm4gY29udGV4dCA/IGNvbnRleHQuJGRhdGEgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGNsYXNzIEJpbmRpbmdSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yICh7YXN5bmNCaW5kaW5nc0FwcGxpZWQsIHJvb3ROb2RlLCBiaW5kaW5nQ29udGV4dH0pIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgICByb290Tm9kZSxcbiAgICAgICAgYmluZGluZ0NvbnRleHQsXG4gICAgICAgIGlzU3luYzogYXN5bmNCaW5kaW5nc0FwcGxpZWQuc2l6ZSA9PT0gMCxcbiAgICAgICAgaXNDb21wbGV0ZTogdGhpcy5pc1N5bmNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRoaXMuaXNTeW5jKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGlvblByb21pc2UgPSB0aGlzLmNvbXBsZXRlV2hlbkJpbmRpbmdzRmluaXNoKGFzeW5jQmluZGluZ3NBcHBsaWVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBjb21wbGV0ZVdoZW5CaW5kaW5nc0ZpbmlzaCAoYXN5bmNCaW5kaW5nc0FwcGxpZWQpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGFzeW5jQmluZGluZ3NBcHBsaWVkKTtcbiAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIEJpbmRpbmdIYW5kbGVyIGV4dGVuZHMgTGlmZUN5Y2xlIHtcbiAgICBjb25zdHJ1Y3RvciAocGFyYW1zKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgY29uc3QgeyRlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgJGNvbnRleHR9ID0gcGFyYW1zO1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgIHZhbHVlQWNjZXNzb3IsXG4gICAgICAgIGFsbEJpbmRpbmdzLFxuICAgICAgICAkZWxlbWVudCxcbiAgICAgICAgJGNvbnRleHQsXG4gICAgICAgICRkYXRhOiAkY29udGV4dC4kZGF0YVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuYW5jaG9yVG8oJGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSAoKSB7IHJldHVybiB0aGlzLnZhbHVlQWNjZXNzb3IoKSB9XG4gICAgc2V0IHZhbHVlICh2KSB7XG4gICAgICBjb25zdCB2YSA9IHRoaXMudmFsdWVBY2Nlc3NvcigpO1xuICAgICAgaWYgKGlzV3JpdGVhYmxlT2JzZXJ2YWJsZSh2YSkpIHtcbiAgICAgICAgdmEodik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3Iodik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGNvbnRyb2xzRGVzY2VuZGFudHMgKCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgc3RhdGljIGdldCBhbGxvd1ZpcnR1YWxFbGVtZW50cyAoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgc3RhdGljIGdldCBpc0JpbmRpbmdIYW5kbGVyQ2xhc3MgKCkgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgICAvKiBPdmVybG9hZCB0aGlzIGZvciBhc3luY2hyb25vdXMgYmluZGluZ3Mgb3IgYmluZGluZ3MgdGhhdCByZWN1cnNpdmVseVxuICAgICAgIGFwcGx5IGJpbmRpbmdzIChlLmcuIGNvbXBvbmVudHMsIGZvcmVhY2gsIHRlbXBsYXRlKS5cblxuICAgICAgIEEgYmluZGluZyBzaG91bGQgYmUgY29tcGxldGUgd2hlbiBpdCBoYXMgcnVuIHRocm91Z2ggb25jZSwgbm90YWJseVxuICAgICAgIGluIHNlcnZlci1zaWRlIGJpbmRpbmdzIGZvciBwcmUtcmVuZGVyaW5nLlxuICAgICovXG4gICAgZ2V0IGJpbmRpbmdDb21wbGV0ZWQgKCkgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgICBzdGF0aWMgcmVnaXN0ZXJBcyAobmFtZSwgcHJvdmlkZXIgPSBvcHRpb25zLmJpbmRpbmdQcm92aWRlckluc3RhbmNlKSB7XG4gICAgICBwcm92aWRlci5iaW5kaW5nSGFuZGxlcnMuc2V0KG5hbWUsIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBBc3luY0JpbmRpbmdIYW5kbGVyIHNoYWxsIGNhbGwgYGNvbXBsZXRlQmluZGluZ2Agd2hlbiB0aGUgYmluZGluZ1xuICAgKiBpcyB0byBiZSBjb25zaWRlcmVkIGNvbXBsZXRlLlxuICAgKi9cbiAgY29uc3QgUmVzb2x2ZVN5bWJvbCA9IFN5bWJvbCgnQXN5bmMgQmluZGluZyBSZXNvbHZlZCcpO1xuXG4gIGNsYXNzIEFzeW5jQmluZGluZ0hhbmRsZXIgZXh0ZW5kcyBCaW5kaW5nSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IgKHBhcmFtcykge1xuICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgIHRoaXMuYmluZGluZ0NvbXBsZXRpb24gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzW1Jlc29sdmVTeW1ib2xdID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb21wbGV0ZUJpbmRpbmcgPSBiaW5kaW5nUmVzdWx0ID0+IHRoaXNbUmVzb2x2ZVN5bWJvbF0oYmluZGluZ1Jlc3VsdCk7XG4gICAgfVxuXG4gICAgZ2V0IGJpbmRpbmdDb21wbGV0ZWQgKCkgeyByZXR1cm4gdGhpcy5iaW5kaW5nQ29tcGxldGlvbiB9XG4gIH1cblxuICAvKipcbiAgICogV2UgaGF2ZSBubyBndWFyYW50ZWVzLCBmb3IgdXNlcnMgZW1wbG95aW5nIGxlZ2FjeSBiaW5kaW5ncyxcbiAgICogdGhhdCBpdCBoYXMgbm90IGJlZW4gY2hhbmdlZCB3aXRoIGEgbW9kaWZpY2F0aW9uIGxpa2VcbiAgICpcbiAgICogICAga28uYmluZGluZ0hhbmRsZXJzW25hbWVdID0geyBpbml0OiAuLi59XG4gICAqXG4gICAqIC4uLiBzbyB3ZSBoYXZlIHRvIGtlZXAgdHJhY2sgYnkgd2F5IG9mIGEgbWFwLlxuICAgKi9cbiAgY29uc3QgUG9zc2libGVXZWFrTWFwID0gb3B0aW9ucy5nbG9iYWwuV2Vha01hcCB8fCBNYXA7XG4gIGNvbnN0IGxlZ2FjeUJpbmRpbmdNYXAgPSBuZXcgUG9zc2libGVXZWFrTWFwKCk7XG5cbiAgY2xhc3MgTGVnYWN5QmluZGluZ0hhbmRsZXIgZXh0ZW5kcyBCaW5kaW5nSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IgKHBhcmFtcykge1xuICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXI7XG4gICAgICB0aGlzLm9uRXJyb3IgPSBwYXJhbXMub25FcnJvcjtcblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5hZGREaXNwb3NhYmxlKGhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmluaXRSZXR1cm4gPSBoYW5kbGVyLmluaXQgJiYgaGFuZGxlci5pbml0KC4uLnRoaXMubGVnYWN5QXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHBhcmFtcy5vbkVycm9yKCdpbml0JywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb25WYWx1ZUNoYW5nZSAoKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5oYW5kbGVyO1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlci51cGRhdGUoLi4udGhpcy5sZWdhY3lBcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5vbkVycm9yKCd1cGRhdGUnLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbGVnYWN5QXJncyAoKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzLiRlbGVtZW50LCB0aGlzLnZhbHVlQWNjZXNzb3IsIHRoaXMuYWxsQmluZGluZ3MsXG4gICAgICAgIHRoaXMuJGRhdGEsIHRoaXMuJGNvbnRleHRcbiAgICAgIF1cbiAgICB9XG5cbiAgICBnZXQgY29udHJvbHNEZXNjZW5kYW50cyAoKSB7XG4gICAgICBjb25zdCBvYmplY3RUb1Rlc3QgPSB0aGlzLmluaXRSZXR1cm4gfHwgdGhpcy5oYW5kbGVyIHx8IHt9O1xuICAgICAgcmV0dXJuIG9iamVjdFRvVGVzdC5jb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGhhbmRsZXIgaW5zdGFuY2UgZnJvbSB0aGUgYG9yaWdpbmAsIHdoaWNoIG1heSBiZTpcbiAgICAgKlxuICAgICAqIDEuIGFuIG9iamVjdCAoYmVjb21lcyBMZWdhY3lCaW5kaW5nSGFuZGxlcilcbiAgICAgKiAyLiBhIGZ1bmN0aW9uIChiZWNvbWVzIExlZ2FjeUJpbmRpbmdIYW5kbGVyIHdpdGggYGluaXQ6IGZ1bmN0aW9uYClcbiAgICAgKlxuICAgICAqIElmIGdpdmVuIGFuIG9iamVjdCAodGhlIG9ubHkga2luZCBzdXBwb3J0ZWQgaW4ga25vY2tvdXQgMy54IGFuZCBiZWZvcmUpLCBpdFxuICAgICAqIHNoYWxsIGRyYXcgdGhlIGBpbml0YCwgYHVwZGF0ZWAsIGFuZCBgYWxsb3dWaXJ0dWFsRWxlbWVudHNgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0T3JDcmVhdGVGb3IgKGtleSwgaGFuZGxlcikge1xuICAgICAgaWYgKGxlZ2FjeUJpbmRpbmdNYXAuaGFzKGhhbmRsZXIpKSB7XG4gICAgICAgIHJldHVybiBsZWdhY3lCaW5kaW5nTWFwLmdldChoYW5kbGVyKVxuICAgICAgfVxuICAgICAgY29uc3QgbmV3TGVnYWN5SGFuZGxlciA9IHRoaXMuY3JlYXRlRm9yKGtleSwgaGFuZGxlcik7XG4gICAgICBsZWdhY3lCaW5kaW5nTWFwLnNldChoYW5kbGVyLCBuZXdMZWdhY3lIYW5kbGVyKTtcbiAgICAgIHJldHVybiBuZXdMZWdhY3lIYW5kbGVyXG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZUZvciAoa2V5LCBoYW5kbGVyKSB7XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgW2luaXRGbiwgZGlzcG9zZUZuXSA9IFtoYW5kbGVyLCBoYW5kbGVyLmRpc3Bvc2VdO1xuICAgICAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBMZWdhY3lCaW5kaW5nSGFuZGxlciB7XG4gICAgICAgICAgZ2V0IGhhbmRsZXIgKCkge1xuICAgICAgICAgICAgY29uc3QgaW5pdCA9IGluaXRGbi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgZGlzcG9zZSA9IGRpc3Bvc2VGbiA/IGRpc3Bvc2VGbi5iaW5kKHRoaXMpIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB7IGluaXQsIGRpc3Bvc2UgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0aWMgZ2V0IGFmdGVyICgpIHsgcmV0dXJuIGhhbmRsZXIuYWZ0ZXIgfVxuICAgICAgICAgIHN0YXRpYyBnZXQgYWxsb3dWaXJ0dWFsRWxlbWVudHMgKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuYWxsb3dWaXJ0dWFsRWxlbWVudHMgfHwgYWxsb3dlZEJpbmRpbmdzW2tleV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBMZWdhY3lCaW5kaW5nSGFuZGxlciB7XG4gICAgICAgICAgZ2V0IGhhbmRsZXIgKCkgeyByZXR1cm4gaGFuZGxlciB9XG4gICAgICAgICAgc3RhdGljIGdldCBhZnRlciAoKSB7IHJldHVybiBoYW5kbGVyLmFmdGVyIH1cbiAgICAgICAgICBzdGF0aWMgZ2V0IGFsbG93VmlydHVhbEVsZW1lbnRzICgpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmFsbG93VmlydHVhbEVsZW1lbnRzIHx8IGFsbG93ZWRCaW5kaW5nc1trZXldXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGdpdmVuIGhhbmRsZXIgaXMgbm90IGFuIGFwcHJvcHJpYXRlIHR5cGUuJylcbiAgICB9XG4gIH1cblxuICAvLyBUaGUgZm9sbG93aW5nIGVsZW1lbnQgdHlwZXMgd2lsbCBub3QgYmUgcmVjdXJzZWQgaW50byBkdXJpbmcgYmluZGluZy5cbiAgY29uc3QgYmluZGluZ0RvZXNOb3RSZWN1cnNlSW50b0VsZW1lbnRUeXBlcyA9IHtcbiAgICAgIC8vIERvbid0IHdhbnQgYmluZGluZ3MgdGhhdCBvcGVyYXRlIG9uIHRleHQgbm9kZXMgdG8gbXV0YXRlIDxzY3JpcHQ+IGFuZCA8dGV4dGFyZWE+IGNvbnRlbnRzLFxuICAgICAgLy8gYmVjYXVzZSBpdCdzIHVuZXhwZWN0ZWQgYW5kIGEgcG90ZW50aWFsIFhTUyBpc3N1ZS5cbiAgICAgIC8vIEFsc28gYmluZGluZ3Mgc2hvdWxkIG5vdCBvcGVyYXRlIG9uIDx0ZW1wbGF0ZT4gZWxlbWVudHMgc2luY2UgdGhpcyBicmVha3MgaW4gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgIC8vIGFuZCBiZWNhdXNlIHN1Y2ggZWxlbWVudHMnIGNvbnRlbnRzIGFyZSBhbHdheXMgaW50ZW5kZWQgdG8gYmUgYm91bmQgaW4gYSBkaWZmZXJlbnQgY29udGV4dFxuICAgICAgLy8gZnJvbSB3aGVyZSB0aGV5IGFwcGVhciBpbiB0aGUgZG9jdW1lbnQuXG4gICAgJ3NjcmlwdCc6IHRydWUsXG4gICAgJ3RleHRhcmVhJzogdHJ1ZSxcbiAgICAndGVtcGxhdGUnOiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0QmluZGluZ1Byb3ZpZGVyICgpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5iaW5kaW5nUHJvdmlkZXJJbnN0YW5jZS5pbnN0YW5jZSB8fCBvcHRpb25zLmJpbmRpbmdQcm92aWRlckluc3RhbmNlXG4gIH1cblxuICBmdW5jdGlvbiBpc1Byb3ZpZGVyRm9yTm9kZSAocHJvdmlkZXIsIG5vZGUpIHtcbiAgICBjb25zdCBub2RlVHlwZXMgPSBwcm92aWRlci5GT1JfTk9ERV9UWVBFUyB8fCBbMSwgMywgOF07XG4gICAgcmV0dXJuIG5vZGVUeXBlcy5pbmNsdWRlcyhub2RlLm5vZGVUeXBlKVxuICB9XG5cbiAgZnVuY3Rpb24gYXNQcm9wZXJIYW5kbGVyQ2xhc3MgKGhhbmRsZXIsIGJpbmRpbmdLZXkpIHtcbiAgICBpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIH1cbiAgICByZXR1cm4gaGFuZGxlci5pc0JpbmRpbmdIYW5kbGVyQ2xhc3MgPyBoYW5kbGVyXG4gICAgICA6IExlZ2FjeUJpbmRpbmdIYW5kbGVyLmdldE9yQ3JlYXRlRm9yKGJpbmRpbmdLZXksIGhhbmRsZXIpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5kaW5nSGFuZGxlckZyb21Db21wb25lbnQgKGJpbmRpbmdLZXksICRjb21wb25lbnQpIHtcbiAgICBpZiAoISRjb21wb25lbnQgfHwgdHlwZW9mICRjb21wb25lbnQuZ2V0QmluZGluZ0hhbmRsZXIgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIH1cbiAgICByZXR1cm4gYXNQcm9wZXJIYW5kbGVyQ2xhc3MoJGNvbXBvbmVudC5nZXRCaW5kaW5nSGFuZGxlcihiaW5kaW5nS2V5KSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJpbmRpbmdIYW5kbGVyIChiaW5kaW5nS2V5KSB7XG4gICAgY29uc3QgYmluZGluZ0RlZmluaXRpb24gPSBvcHRpb25zLmdldEJpbmRpbmdIYW5kbGVyKGJpbmRpbmdLZXkpIHx8IGdldEJpbmRpbmdQcm92aWRlcigpLmJpbmRpbmdIYW5kbGVycy5nZXQoYmluZGluZ0tleSk7XG4gICAgcmV0dXJuIGFzUHJvcGVySGFuZGxlckNsYXNzKGJpbmRpbmdEZWZpbml0aW9uLCBiaW5kaW5nS2V5KVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgYSB2YWx1ZUFjY2Vzc29yIGZ1bmN0aW9uXG4gIGZ1bmN0aW9uIGV2YWx1YXRlVmFsdWVBY2Nlc3NvciAodmFsdWVBY2Nlc3Nvcikge1xuICAgIHJldHVybiB2YWx1ZUFjY2Vzc29yKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzSW50ZXJuYWwgKGJpbmRpbmdDb250ZXh0JCQxLCBlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgYXN5bmNCaW5kaW5nc0FwcGxpZWQpIHtcbiAgICBsZXQgbmV4dEluUXVldWUgPSBmaXJzdENoaWxkKGVsZW1lbnRPclZpcnR1YWxFbGVtZW50KTtcblxuICAgIGlmICghbmV4dEluUXVldWUpIHsgcmV0dXJuIH1cblxuICAgIGxldCBjdXJyZW50Q2hpbGQ7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBnZXRCaW5kaW5nUHJvdmlkZXIoKTtcbiAgICBjb25zdCBwcmVwcm9jZXNzTm9kZSA9IHByb3ZpZGVyLnByZXByb2Nlc3NOb2RlO1xuXG4gICAgLy8gUHJlcHJvY2Vzc2luZyBhbGxvd3MgYSBiaW5kaW5nIHByb3ZpZGVyIHRvIG11dGF0ZSBhIG5vZGUgYmVmb3JlIGJpbmRpbmdzIGFyZSBhcHBsaWVkIHRvIGl0LiBGb3IgZXhhbXBsZSBpdCdzXG4gICAgLy8gcG9zc2libGUgdG8gaW5zZXJ0IG5ldyBzaWJsaW5ncyBhZnRlciBpdCwgYW5kL29yIHJlcGxhY2UgdGhlIG5vZGUgd2l0aCBhIGRpZmZlcmVudCBvbmUuIFRoaXMgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBpbXBsZW1lbnQgY3VzdG9tIGJpbmRpbmcgc3ludGF4ZXMsIHN1Y2ggYXMge3sgdmFsdWUgfX0gZm9yIHN0cmluZyBpbnRlcnBvbGF0aW9uLCBvciBjdXN0b20gZWxlbWVudCB0eXBlcyB0aGF0XG4gICAgLy8gdHJpZ2dlciBpbnNlcnRpb24gb2YgPHRlbXBsYXRlPiBjb250ZW50cyBhdCB0aGF0IHBvaW50IGluIHRoZSBkb2N1bWVudC5cbiAgICBpZiAocHJlcHJvY2Vzc05vZGUpIHtcbiAgICAgIHdoaWxlIChjdXJyZW50Q2hpbGQgPSBuZXh0SW5RdWV1ZSkge1xuICAgICAgICBuZXh0SW5RdWV1ZSA9IG5leHRTaWJsaW5nKGN1cnJlbnRDaGlsZCk7XG4gICAgICAgIHByZXByb2Nlc3NOb2RlLmNhbGwocHJvdmlkZXIsIGN1cnJlbnRDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IG5leHRJblF1ZXVlIGZvciB0aGUgbmV4dCBsb29wXG4gICAgICBuZXh0SW5RdWV1ZSA9IGZpcnN0Q2hpbGQoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQpO1xuICAgIH1cblxuICAgIHdoaWxlIChjdXJyZW50Q2hpbGQgPSBuZXh0SW5RdWV1ZSkge1xuICAgICAgLy8gS2VlcCBhIHJlY29yZCBvZiB0aGUgbmV4dCBjaGlsZCAqYmVmb3JlKiBhcHBseWluZyBiaW5kaW5ncywgaW4gY2FzZSB0aGUgYmluZGluZyByZW1vdmVzIHRoZSBjdXJyZW50IGNoaWxkIGZyb20gaXRzIHBvc2l0aW9uXG4gICAgICBuZXh0SW5RdWV1ZSA9IG5leHRTaWJsaW5nKGN1cnJlbnRDaGlsZCk7XG4gICAgICBhcHBseUJpbmRpbmdzVG9Ob2RlQW5kRGVzY2VuZGFudHNJbnRlcm5hbChiaW5kaW5nQ29udGV4dCQkMSwgY3VycmVudENoaWxkLCBhc3luY0JpbmRpbmdzQXBwbGllZCk7XG4gICAgfVxuXG4gICAgYmluZGluZ0V2ZW50Lm5vdGlmeShlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgYmluZGluZ0V2ZW50LmNoaWxkcmVuQ29tcGxldGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQmluZGluZ3MgKG5vZGUpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGdldEJpbmRpbmdQcm92aWRlcigpO1xuICAgIHJldHVybiBpc1Byb3ZpZGVyRm9yTm9kZShwcm92aWRlciwgbm9kZSkgJiYgcHJvdmlkZXIubm9kZUhhc0JpbmRpbmdzKG5vZGUpXG4gIH1cblxuICBmdW5jdGlvbiBub2RlT3JDaGlsZEhhc0JpbmRpbmdzIChub2RlKSB7XG4gICAgcmV0dXJuIGhhc0JpbmRpbmdzKG5vZGUpIHx8IFsuLi5ub2RlLmNoaWxkTm9kZXNdLnNvbWUoYyA9PiBub2RlT3JDaGlsZEhhc0JpbmRpbmdzKGMpKVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlCaW5kaW5nc1RvTm9kZUFuZERlc2NlbmRhbnRzSW50ZXJuYWwgKGJpbmRpbmdDb250ZXh0JCQxLCBub2RlVmVyaWZpZWQsIGFzeW5jQmluZGluZ3NBcHBsaWVkKSB7XG4gICAgdmFyIGlzRWxlbWVudCA9IG5vZGVWZXJpZmllZC5ub2RlVHlwZSA9PT0gMTtcbiAgICBpZiAoaXNFbGVtZW50KSB7IC8vIFdvcmthcm91bmQgSUUgPD0gOCBIVE1MIHBhcnNpbmcgd2VpcmRuZXNzXG4gICAgICBub3JtYWxpc2VWaXJ0dWFsRWxlbWVudERvbVN0cnVjdHVyZShub2RlVmVyaWZpZWQpO1xuICAgIH1cblxuICAgIC8vIFBlcmYgb3B0aW1pc2F0aW9uOiBBcHBseSBiaW5kaW5ncyBvbmx5IGlmLi4uXG4gICAgLy8gKDEpIFdlIG5lZWQgdG8gc3RvcmUgdGhlIGJpbmRpbmcgaW5mbyBmb3IgdGhlIG5vZGUgKGFsbCBlbGVtZW50IG5vZGVzKVxuICAgIC8vICgyKSBJdCBtaWdodCBoYXZlIGJpbmRpbmdzIChlLmcuLCBpdCBoYXMgYSBkYXRhLWJpbmQgYXR0cmlidXRlLCBvciBpdCdzIGEgbWFya2VyIGZvciBhIGNvbnRhaW5lcmxlc3MgdGVtcGxhdGUpXG5cbiAgICBsZXQgc2hvdWxkQXBwbHlCaW5kaW5ncyA9IGlzRWxlbWVudCB8fCAvLyBDYXNlICgxKVxuICAgICAgICBoYXNCaW5kaW5ncyhub2RlVmVyaWZpZWQpOyAgICAgICAgICAvLyBDYXNlICgyKVxuXG4gICAgY29uc3QgeyBzaG91bGRCaW5kRGVzY2VuZGFudHMgfSA9IHNob3VsZEFwcGx5QmluZGluZ3NcbiAgICAgID8gYXBwbHlCaW5kaW5nc1RvTm9kZUludGVybmFsKG5vZGVWZXJpZmllZCwgbnVsbCwgYmluZGluZ0NvbnRleHQkJDEsIGFzeW5jQmluZGluZ3NBcHBsaWVkKVxuICAgICAgOiB7IHNob3VsZEJpbmREZXNjZW5kYW50czogdHJ1ZSB9O1xuXG4gICAgaWYgKHNob3VsZEJpbmREZXNjZW5kYW50cyAmJiAhYmluZGluZ0RvZXNOb3RSZWN1cnNlSW50b0VsZW1lbnRUeXBlc1t0YWdOYW1lTG93ZXIobm9kZVZlcmlmaWVkKV0pIHtcbiAgICAgIC8vIFdlJ3JlIHJlY3Vyc2luZyBhdXRvbWF0aWNhbGx5IGludG8gKHJlYWwgb3IgdmlydHVhbCkgY2hpbGQgbm9kZXMgd2l0aG91dCBjaGFuZ2luZyBiaW5kaW5nIGNvbnRleHRzLiBTbyxcbiAgICAgIC8vICAqIEZvciBjaGlsZHJlbiBvZiBhICpyZWFsKiBlbGVtZW50LCB0aGUgYmluZGluZyBjb250ZXh0IGlzIGNlcnRhaW5seSB0aGUgc2FtZSBhcyBvbiB0aGVpciBET00gLnBhcmVudE5vZGUsXG4gICAgICAvLyAgICBoZW5jZSBiaW5kaW5nQ29udGV4dHNNYXlEaWZmZXJGcm9tRG9tUGFyZW50RWxlbWVudCBpcyBmYWxzZVxuICAgICAgLy8gICogRm9yIGNoaWxkcmVuIG9mIGEgKnZpcnR1YWwqIGVsZW1lbnQsIHdlIGNhbid0IGJlIHN1cmUuIEV2YWx1YXRpbmcgLnBhcmVudE5vZGUgb24gdGhvc2UgY2hpbGRyZW4gbWF5XG4gICAgICAvLyAgICBza2lwIG92ZXIgYW55IG51bWJlciBvZiBpbnRlcm1lZGlhdGUgdmlydHVhbCBlbGVtZW50cywgYW55IG9mIHdoaWNoIG1pZ2h0IGRlZmluZSBhIGN1c3RvbSBiaW5kaW5nIGNvbnRleHQsXG4gICAgICAvLyAgICBoZW5jZSBiaW5kaW5nQ29udGV4dHNNYXlEaWZmZXJGcm9tRG9tUGFyZW50RWxlbWVudCBpcyB0cnVlXG4gICAgICBhcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50c0ludGVybmFsKGJpbmRpbmdDb250ZXh0JCQxLCBub2RlVmVyaWZpZWQsIGFzeW5jQmluZGluZ3NBcHBsaWVkKTtcbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uICogdG9wb2xvZ2ljYWxTb3J0QmluZGluZ3MgKGJpbmRpbmdzLCAkY29tcG9uZW50KSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIC8vIERlcHRoLWZpcnN0IHNvcnRcbiAgICBjb25zdCBiaW5kaW5nc0NvbnNpZGVyZWQgPSB7fTsgICAgLy8gQSB0ZW1wb3JhcnkgcmVjb3JkIG9mIHdoaWNoIGJpbmRpbmdzIGFyZSBhbHJlYWR5IGluICdyZXN1bHQnXG4gICAgY29uc3QgY3ljbGljRGVwZW5kZW5jeVN0YWNrID0gW107IC8vIEtlZXBzIHRyYWNrIG9mIGEgZGVwdGgtc2VhcmNoIHNvIHRoYXQsIGlmIHRoZXJlJ3MgYSBjeWNsZSwgd2Uga25vdyB3aGljaCBiaW5kaW5ncyBjYXVzZWQgaXRcblxuICAgIG9iamVjdEZvckVhY2goYmluZGluZ3MsIGZ1bmN0aW9uIHB1c2hCaW5kaW5nIChiaW5kaW5nS2V5KSB7XG4gICAgICBpZiAoIWJpbmRpbmdzQ29uc2lkZXJlZFtiaW5kaW5nS2V5XSkge1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gZ2V0QmluZGluZ0hhbmRsZXJGcm9tQ29tcG9uZW50KGJpbmRpbmdLZXksICRjb21wb25lbnQpIHx8IGdldEJpbmRpbmdIYW5kbGVyKGJpbmRpbmdLZXkpO1xuICAgICAgICBpZiAoIWJpbmRpbmcpIHsgcmV0dXJuIH1cbiAgICAgICAgICAvLyBGaXJzdCBhZGQgZGVwZW5kZW5jaWVzIChpZiBhbnkpIG9mIHRoZSBjdXJyZW50IGJpbmRpbmdcbiAgICAgICAgaWYgKGJpbmRpbmcuYWZ0ZXIpIHtcbiAgICAgICAgICBjeWNsaWNEZXBlbmRlbmN5U3RhY2sucHVzaChiaW5kaW5nS2V5KTtcbiAgICAgICAgICBhcnJheUZvckVhY2goYmluZGluZy5hZnRlciwgZnVuY3Rpb24gKGJpbmRpbmdEZXBlbmRlbmN5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIWJpbmRpbmdzW2JpbmRpbmdEZXBlbmRlbmN5S2V5XSkgeyByZXR1cm4gfVxuICAgICAgICAgICAgaWYgKGFycmF5SW5kZXhPZihjeWNsaWNEZXBlbmRlbmN5U3RhY2ssIGJpbmRpbmdEZXBlbmRlbmN5S2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjb21iaW5lIHRoZSBmb2xsb3dpbmcgYmluZGluZ3MsIGJlY2F1c2UgdGhleSBoYXZlIGEgY3ljbGljIGRlcGVuZGVuY3k6ICcgKyBjeWNsaWNEZXBlbmRlbmN5U3RhY2suam9pbignLCAnKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHB1c2hCaW5kaW5nKGJpbmRpbmdEZXBlbmRlbmN5S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjeWNsaWNEZXBlbmRlbmN5U3RhY2subGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICAgICAgICAvLyBOZXh0IGFkZCB0aGUgY3VycmVudCBiaW5kaW5nXG4gICAgICAgIHJlc3VsdHMucHVzaChbIGJpbmRpbmdLZXksIGJpbmRpbmcgXSk7XG4gICAgICB9XG4gICAgICBiaW5kaW5nc0NvbnNpZGVyZWRbYmluZGluZ0tleV0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykgeyB5aWVsZCByZXN1bHQ7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5QmluZGluZ3NUb05vZGVJbnRlcm5hbCAobm9kZSwgc291cmNlQmluZGluZ3MsIGJpbmRpbmdDb250ZXh0JCQxLCBhc3luY0JpbmRpbmdzQXBwbGllZCkge1xuICAgIGNvbnN0IGJpbmRpbmdJbmZvID0gZ2V0T3JTZXQobm9kZSwgYm91bmRFbGVtZW50RG9tRGF0YUtleSQxLCB7fSk7XG4gICAgLy8gUHJldmVudCBtdWx0aXBsZSBhcHBseUJpbmRpbmdzIGNhbGxzIGZvciB0aGUgc2FtZSBub2RlLCBleGNlcHQgd2hlbiBhIGJpbmRpbmcgdmFsdWUgaXMgc3BlY2lmaWVkXG4gICAgY29uc3QgYWxyZWFkeUJvdW5kID0gYmluZGluZ0luZm8uYWxyZWFkeUJvdW5kO1xuICAgIGlmICghc291cmNlQmluZGluZ3MpIHtcbiAgICAgIGlmIChhbHJlYWR5Qm91bmQpIHtcbiAgICAgICAgaWYgKCFub2RlT3JDaGlsZEhhc0JpbmRpbmdzKG5vZGUpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIG9uQmluZGluZ0Vycm9yKHtcbiAgICAgICAgICBkdXJpbmc6ICdhcHBseScsXG4gICAgICAgICAgZXJyb3JDYXB0dXJlZDogbmV3IEVycm9yKCdZb3UgY2Fubm90IGFwcGx5IGJpbmRpbmdzIG11bHRpcGxlIHRpbWVzIHRvIHRoZSBzYW1lIGVsZW1lbnQuJyksXG4gICAgICAgICAgZWxlbWVudDogbm9kZSxcbiAgICAgICAgICBiaW5kaW5nQ29udGV4dDogYmluZGluZ0NvbnRleHQkJDFcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgYmluZGluZ0luZm8uYWxyZWFkeUJvdW5kID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWFscmVhZHlCb3VuZCkge1xuICAgICAgYmluZGluZ0luZm8uY29udGV4dCA9IGJpbmRpbmdDb250ZXh0JCQxO1xuICAgIH1cblxuICAgIC8vIFVzZSBiaW5kaW5ncyBpZiBnaXZlbiwgb3RoZXJ3aXNlIGZhbGwgYmFjayBvbiBhc2tpbmcgdGhlIGJpbmRpbmdzIHByb3ZpZGVyIHRvIGdpdmUgdXMgc29tZSBiaW5kaW5nc1xuICAgIHZhciBiaW5kaW5ncztcbiAgICBpZiAoc291cmNlQmluZGluZ3MgJiYgdHlwZW9mIHNvdXJjZUJpbmRpbmdzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBiaW5kaW5ncyA9IHNvdXJjZUJpbmRpbmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGdldEJpbmRpbmdQcm92aWRlcigpO1xuICAgICAgY29uc3QgZ2V0QmluZGluZ3MgPSBwcm92aWRlci5nZXRCaW5kaW5nQWNjZXNzb3JzO1xuXG4gICAgICBpZiAoaXNQcm92aWRlckZvck5vZGUocHJvdmlkZXIsIG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGJpbmRpbmcgZnJvbSB0aGUgcHJvdmlkZXIgd2l0aGluIGEgY29tcHV0ZWQgb2JzZXJ2YWJsZSBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIGJpbmRpbmdzIHdoZW5ldmVyXG4gICAgICAgICAgICAvLyB0aGUgYmluZGluZyBjb250ZXh0IGlzIHVwZGF0ZWQgb3IgaWYgdGhlIGJpbmRpbmcgcHJvdmlkZXIgYWNjZXNzZXMgb2JzZXJ2YWJsZXMuXG4gICAgICAgIHZhciBiaW5kaW5nc1VwZGF0ZXIgPSBjb21wdXRlZChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBiaW5kaW5ncyA9IHNvdXJjZUJpbmRpbmdzID8gc291cmNlQmluZGluZ3MoYmluZGluZ0NvbnRleHQkJDEsIG5vZGUpIDogZ2V0QmluZGluZ3MuY2FsbChwcm92aWRlciwgbm9kZSwgYmluZGluZ0NvbnRleHQkJDEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWdpc3RlciBhIGRlcGVuZGVuY3kgb24gdGhlIGJpbmRpbmcgY29udGV4dCB0byBzdXBwb3J0IG9ic2VydmFibGUgdmlldyBtb2RlbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoYmluZGluZ3MgJiYgYmluZGluZ0NvbnRleHQkJDFbY29udGV4dFN1YnNjcmliZVN5bWJvbF0pIHsgYmluZGluZ0NvbnRleHQkJDFbY29udGV4dFN1YnNjcmliZVN5bWJvbF0oKTsgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmdzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBudWxsLCB7IGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogbm9kZSB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGlmICghYmluZGluZ3MgfHwgIWJpbmRpbmdzVXBkYXRlci5pc0FjdGl2ZSgpKSB7IGJpbmRpbmdzVXBkYXRlciA9IG51bGw7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmluZGluZ0hhbmRsZXJUaGF0Q29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M7XG4gICAgaWYgKGJpbmRpbmdzKSB7XG4gICAgICBjb25zdCAkY29tcG9uZW50ID0gYmluZGluZ0NvbnRleHQkJDEuJGNvbXBvbmVudCB8fCB7fTtcblxuICAgICAgY29uc3QgYWxsQmluZGluZ0hhbmRsZXJzID0ge307XG4gICAgICBzZXQobm9kZSwgJ2JpbmRpbmdIYW5kbGVycycsIGFsbEJpbmRpbmdIYW5kbGVycyk7XG5cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIGFjY2Vzc29yIGZvciBhIGdpdmVuIGJpbmRpbmcuIFdoZW4gYmluZGluZ3MgYXJlIHN0YXRpYyAod29uJ3QgYmUgdXBkYXRlZCBiZWNhdXNlIG9mIGEgYmluZGluZ1xuICAgICAgICAgIC8vIGNvbnRleHQgdXBkYXRlKSwganVzdCByZXR1cm4gdGhlIHZhbHVlIGFjY2Vzc29yIGZyb20gdGhlIGJpbmRpbmcuIE90aGVyd2lzZSwgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgZ2V0c1xuICAgICAgICAgIC8vIHRoZSBsYXRlc3QgYmluZGluZyB2YWx1ZSBhbmQgcmVnaXN0ZXJzIGEgZGVwZW5kZW5jeSBvbiB0aGUgYmluZGluZyB1cGRhdGVyLlxuICAgICAgY29uc3QgZ2V0VmFsdWVBY2Nlc3NvciA9IGJpbmRpbmdzVXBkYXRlclxuICAgICAgICAgICAgICA/IChiaW5kaW5nS2V5KSA9PiBmdW5jdGlvbiAob3B0aW9uYWxWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlQWNjZXNzb3IgPSBiaW5kaW5nc1VwZGF0ZXIoKVtiaW5kaW5nS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVBY2Nlc3NvcihvcHRpb25hbFZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSA6IChiaW5kaW5nS2V5KSA9PiBiaW5kaW5nc1tiaW5kaW5nS2V5XTtcblxuICAgICAgICAgIC8vIFVzZSBvZiBhbGxCaW5kaW5ncyBhcyBhIGZ1bmN0aW9uIGlzIG1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBidXQgaXRzIHVzZSBpcyBkZXByZWNhdGVkXG4gICAgICBmdW5jdGlvbiBhbGxCaW5kaW5ncyAoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RNYXAoYmluZGluZ3NVcGRhdGVyID8gYmluZGluZ3NVcGRhdGVyKCkgOiBiaW5kaW5ncywgZXZhbHVhdGVWYWx1ZUFjY2Vzc29yKVxuICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyB0aGUgMy54IGFsbEJpbmRpbmdzIEFQSVxuICAgICAgYWxsQmluZGluZ3MuaGFzID0gKGtleSkgPT4ga2V5IGluIGJpbmRpbmdzO1xuICAgICAgYWxsQmluZGluZ3MuZ2V0ID0gKGtleSkgPT4gYmluZGluZ3Nba2V5XSAmJiBldmFsdWF0ZVZhbHVlQWNjZXNzb3IoZ2V0VmFsdWVBY2Nlc3NvcihrZXkpKTtcblxuICAgICAgaWYgKGJpbmRpbmdFdmVudC5jaGlsZHJlbkNvbXBsZXRlIGluIGJpbmRpbmdzKSB7XG4gICAgICAgIGJpbmRpbmdFdmVudC5zdWJzY3JpYmUobm9kZSwgYmluZGluZ0V2ZW50LmNoaWxkcmVuQ29tcGxldGUsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGV2YWx1YXRlVmFsdWVBY2Nlc3NvcihiaW5kaW5nc1tiaW5kaW5nRXZlbnQuY2hpbGRyZW5Db21wbGV0ZV0pO1xuICAgICAgICAgIGlmICghY2FsbGJhY2spIHsgcmV0dXJuIH1cbiAgICAgICAgICBjb25zdCBub2RlcyA9IGNoaWxkTm9kZXMobm9kZSk7XG4gICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkgeyBjYWxsYmFjayhub2RlcywgZGF0YUZvcihub2Rlc1swXSkpOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiaW5kaW5nc0dlbmVyYXRlZCA9IHRvcG9sb2dpY2FsU29ydEJpbmRpbmdzKGJpbmRpbmdzLCAkY29tcG9uZW50KTtcbiAgICAgIGNvbnN0IG5vZGVBc3luY0JpbmRpbmdQcm9taXNlcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgQmluZGluZ0hhbmRsZXJDbGFzc10gb2YgYmluZGluZ3NHZW5lcmF0ZWQpIHtcbiAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBzb3J0ZWQgYmluZGluZ3MsIGNhbGxpbmcgaW5pdCBhbmQgdXBkYXRlIGZvciBlYWNoXG4gICAgICAgIGZ1bmN0aW9uIHJlcG9ydEJpbmRpbmdFcnJvciAoZHVyaW5nLCBlcnJvckNhcHR1cmVkKSB7XG4gICAgICAgICAgb25CaW5kaW5nRXJyb3Ioe1xuICAgICAgICAgICAgZHVyaW5nLFxuICAgICAgICAgICAgZXJyb3JDYXB0dXJlZCxcbiAgICAgICAgICAgIGJpbmRpbmdzLFxuICAgICAgICAgICAgYWxsQmluZGluZ3MsXG4gICAgICAgICAgICBiaW5kaW5nS2V5OiBrZXksXG4gICAgICAgICAgICBiaW5kaW5nQ29udGV4dDogYmluZGluZ0NvbnRleHQkJDEsXG4gICAgICAgICAgICBlbGVtZW50OiBub2RlLFxuICAgICAgICAgICAgdmFsdWVBY2Nlc3NvcjogZ2V0VmFsdWVBY2Nlc3NvcihrZXkpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAmJiAhQmluZGluZ0hhbmRsZXJDbGFzcy5hbGxvd1ZpcnR1YWxFbGVtZW50cykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGJpbmRpbmcgJyR7a2V5fScgY2Fubm90IGJlIHVzZWQgd2l0aCB2aXJ0dWFsIGVsZW1lbnRzYClcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgYmluZGluZ0hhbmRsZXIgPSBpZ25vcmUoKCkgPT5cbiAgICAgICAgICAgIG5ldyBCaW5kaW5nSGFuZGxlckNsYXNzKHtcbiAgICAgICAgICAgICAgYWxsQmluZGluZ3MsXG4gICAgICAgICAgICAgICRlbGVtZW50OiBub2RlLFxuICAgICAgICAgICAgICAkY29udGV4dDogYmluZGluZ0NvbnRleHQkJDEsXG4gICAgICAgICAgICAgIG9uRXJyb3I6IHJlcG9ydEJpbmRpbmdFcnJvcixcbiAgICAgICAgICAgICAgdmFsdWVBY2Nlc3NvciAoLi4udikgeyByZXR1cm4gZ2V0VmFsdWVBY2Nlc3NvcihrZXkpKC4uLnYpIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChiaW5kaW5nSGFuZGxlci5vblZhbHVlQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZ25vcmUoKCkgPT5cbiAgICAgICAgICAgICAgYmluZGluZ0hhbmRsZXIuY29tcHV0ZWQoJ29uVmFsdWVDaGFuZ2UnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFeHBvc2UgdGhlIGJpbmRpbmdzIHZpYSBkb21EYXRhLlxuICAgICAgICAgIGFsbEJpbmRpbmdIYW5kbGVyc1trZXldID0gYmluZGluZ0hhbmRsZXI7XG5cbiAgICAgICAgICBpZiAoYmluZGluZ0hhbmRsZXIuY29udHJvbHNEZXNjZW5kYW50cykge1xuICAgICAgICAgICAgaWYgKGJpbmRpbmdIYW5kbGVyVGhhdENvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzICE9PSB1bmRlZmluZWQpIHsgdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBiaW5kaW5ncyAoJyArIGJpbmRpbmdIYW5kbGVyVGhhdENvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzICsgJyBhbmQgJyArIGtleSArICcpIGFyZSB0cnlpbmcgdG8gY29udHJvbCBkZXNjZW5kYW50IGJpbmRpbmdzIG9mIHRoZSBzYW1lIGVsZW1lbnQuIFlvdSBjYW5ub3QgdXNlIHRoZXNlIGJpbmRpbmdzIHRvZ2V0aGVyIG9uIHRoZSBzYW1lIGVsZW1lbnQuJykgfVxuICAgICAgICAgICAgYmluZGluZ0hhbmRsZXJUaGF0Q29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MgPSBrZXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJpbmRpbmdIYW5kbGVyLmJpbmRpbmdDb21wbGV0ZWQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBhc3luY0JpbmRpbmdzQXBwbGllZC5hZGQoYmluZGluZ0hhbmRsZXIuYmluZGluZ0NvbXBsZXRlZCk7XG4gICAgICAgICAgICBub2RlQXN5bmNCaW5kaW5nUHJvbWlzZXMuYWRkKGJpbmRpbmdIYW5kbGVyLmJpbmRpbmdDb21wbGV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVwb3J0QmluZGluZ0Vycm9yKCdjcmVhdGlvbicsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckRlc2NlbmRhbnRzQ29tcGxldGUobm9kZSwgYmluZGluZ3MsIG5vZGVBc3luY0JpbmRpbmdQcm9taXNlcyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hvdWxkQmluZERlc2NlbmRhbnRzID0gYmluZGluZ0hhbmRsZXJUaGF0Q29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyBzaG91bGRCaW5kRGVzY2VuZGFudHMgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGJpbmRpbmdzXG4gICAqIEBwYXJhbSB7W1Byb21pc2VdfSBub2RlQXN5bmNCaW5kaW5nUHJvbWlzZXNcbiAgICovXG4gIGZ1bmN0aW9uIHRyaWdnZXJEZXNjZW5kYW50c0NvbXBsZXRlIChub2RlLCBiaW5kaW5ncywgbm9kZUFzeW5jQmluZGluZ1Byb21pc2VzKSB7XG4gICAgLyoqIGRlc2NlbmRhbnRzQ29tcGxldGUgb3VnaHQgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgdGhlIGRlc2NlbmRhbnRzQ29tcGxldGVcbiAgICAgICogIGJpbmRpbmcgaGFuZGxlci4gKi9cbiAgICBjb25zdCBoYXNCaW5kaW5nSGFuZGxlciA9IGJpbmRpbmdFdmVudC5kZXNjZW5kYW50c0NvbXBsZXRlIGluIGJpbmRpbmdzO1xuICAgIGNvbnN0IGhhc0ZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkKG5vZGUpO1xuICAgIGNvbnN0IGFjY2Vzc29yID0gaGFzQmluZGluZ0hhbmRsZXIgJiYgZXZhbHVhdGVWYWx1ZUFjY2Vzc29yKGJpbmRpbmdzW2JpbmRpbmdFdmVudC5kZXNjZW5kYW50c0NvbXBsZXRlXSk7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBiaW5kaW5nRXZlbnQubm90aWZ5KG5vZGUsIGJpbmRpbmdFdmVudC5kZXNjZW5kYW50c0NvbXBsZXRlKTtcbiAgICAgIGlmIChhY2Nlc3NvciAmJiBoYXNGaXJzdENoaWxkKSB7IGFjY2Vzc29yKG5vZGUpOyB9XG4gICAgfTtcbiAgICBpZiAobm9kZUFzeW5jQmluZGluZ1Byb21pc2VzLnNpemUpIHtcbiAgICAgIFByb21pc2UuYWxsKG5vZGVBc3luY0JpbmRpbmdQcm9taXNlcykudGhlbihjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBnZXRCaW5kaW5nQ29udGV4dCAodmlld01vZGVsT3JCaW5kaW5nQ29udGV4dCwgZXh0ZW5kQ29udGV4dENhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHQgJiYgKHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHQgaW5zdGFuY2VvZiBiaW5kaW5nQ29udGV4dClcbiAgICAgID8gdmlld01vZGVsT3JCaW5kaW5nQ29udGV4dFxuICAgICAgOiBuZXcgYmluZGluZ0NvbnRleHQodmlld01vZGVsT3JCaW5kaW5nQ29udGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGV4dGVuZENvbnRleHRDYWxsYmFjaylcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5QmluZGluZ0FjY2Vzc29yc1RvTm9kZSAobm9kZSwgYmluZGluZ3MsIHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHQsIGFzeW5jQmluZGluZ3NBcHBsaWVkKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHsgLy8gSWYgaXQncyBhbiBlbGVtZW50LCB3b3JrYXJvdW5kIElFIDw9IDggSFRNTCBwYXJzaW5nIHdlaXJkbmVzc1xuICAgICAgbm9ybWFsaXNlVmlydHVhbEVsZW1lbnREb21TdHJ1Y3R1cmUobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBhcHBseUJpbmRpbmdzVG9Ob2RlSW50ZXJuYWwobm9kZSwgYmluZGluZ3MsIGdldEJpbmRpbmdDb250ZXh0KHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHQpLCBhc3luY0JpbmRpbmdzQXBwbGllZClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5QmluZGluZ3NUb05vZGUgKG5vZGUsIGJpbmRpbmdzLCB2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0KSB7XG4gICAgY29uc3QgYXN5bmNCaW5kaW5nc0FwcGxpZWQgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgYmluZGluZ0NvbnRleHQkJDEgPSBnZXRCaW5kaW5nQ29udGV4dCh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0KTtcbiAgICBjb25zdCBiaW5kaW5nQWNjZXNzb3JzID0gZ2V0QmluZGluZ1Byb3ZpZGVyKCkubWFrZUJpbmRpbmdBY2Nlc3NvcnMoYmluZGluZ3MsIGJpbmRpbmdDb250ZXh0JCQxLCBub2RlKTtcbiAgICBhcHBseUJpbmRpbmdBY2Nlc3NvcnNUb05vZGUobm9kZSwgYmluZGluZ0FjY2Vzc29ycywgYmluZGluZ0NvbnRleHQkJDEsIGFzeW5jQmluZGluZ3NBcHBsaWVkKTtcbiAgICByZXR1cm4gbmV3IEJpbmRpbmdSZXN1bHQoe2FzeW5jQmluZGluZ3NBcHBsaWVkLCByb290Tm9kZTogbm9kZSwgYmluZGluZ0NvbnRleHQ6IGJpbmRpbmdDb250ZXh0JCQxfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzICh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0LCByb290Tm9kZSkge1xuICAgIGNvbnN0IGFzeW5jQmluZGluZ3NBcHBsaWVkID0gbmV3IFNldCgpO1xuICAgIGlmIChyb290Tm9kZS5ub2RlVHlwZSA9PT0gMSB8fCByb290Tm9kZS5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgY29uc3QgYmluZGluZ0NvbnRleHQkJDEgPSBnZXRCaW5kaW5nQ29udGV4dCh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0KTtcbiAgICAgIGFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzSW50ZXJuYWwoYmluZGluZ0NvbnRleHQkJDEsIHJvb3ROb2RlLCBhc3luY0JpbmRpbmdzQXBwbGllZCk7XG4gICAgICByZXR1cm4gbmV3IEJpbmRpbmdSZXN1bHQoe2FzeW5jQmluZGluZ3NBcHBsaWVkLCByb290Tm9kZSwgYmluZGluZ0NvbnRleHQ6IGJpbmRpbmdDb250ZXh0JCQxfSlcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaW5kaW5nUmVzdWx0KHthc3luY0JpbmRpbmdzQXBwbGllZCwgcm9vdE5vZGV9KVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlCaW5kaW5ncyAodmlld01vZGVsT3JCaW5kaW5nQ29udGV4dCwgcm9vdE5vZGUsIGV4dGVuZENvbnRleHRDYWxsYmFjaykge1xuICAgIGNvbnN0IGFzeW5jQmluZGluZ3NBcHBsaWVkID0gbmV3IFNldCgpO1xuICAgIC8vIElmIGpRdWVyeSBpcyBsb2FkZWQgYWZ0ZXIgS25vY2tvdXQsIHdlIHdvbid0IGluaXRpYWxseSBoYXZlIGFjY2VzcyB0byBpdC4gU28gc2F2ZSBpdCBoZXJlLlxuICAgIGlmICghb3B0aW9ucy5qUXVlcnkgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmpRdWVyeSkge1xuICAgICAgb3B0aW9ucy5qUXVlcnkgPSBvcHRpb25zLmpRdWVyeTtcbiAgICB9XG5cbiAgICAvLyByb290Tm9kZSBpcyBvcHRpb25hbFxuICAgIGlmICghcm9vdE5vZGUpIHtcbiAgICAgIHJvb3ROb2RlID0gd2luZG93LmRvY3VtZW50LmJvZHk7XG4gICAgICBpZiAoIXJvb3ROb2RlKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdrby5hcHBseUJpbmRpbmdzOiBjb3VsZCBub3QgZmluZCB3aW5kb3cuZG9jdW1lbnQuYm9keTsgaGFzIHRoZSBkb2N1bWVudCBiZWVuIGxvYWRlZD8nKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocm9vdE5vZGUubm9kZVR5cGUgIT09IDEgJiYgcm9vdE5vZGUubm9kZVR5cGUgIT09IDgpIHtcbiAgICAgIHRocm93IEVycm9yKCdrby5hcHBseUJpbmRpbmdzOiBmaXJzdCBwYXJhbWV0ZXIgc2hvdWxkIGJlIHlvdXIgdmlldyBtb2RlbDsgc2Vjb25kIHBhcmFtZXRlciBzaG91bGQgYmUgYSBET00gbm9kZScpXG4gICAgfVxuICAgIGNvbnN0IHJvb3RDb250ZXh0ID0gZ2V0QmluZGluZ0NvbnRleHQodmlld01vZGVsT3JCaW5kaW5nQ29udGV4dCwgZXh0ZW5kQ29udGV4dENhbGxiYWNrKTtcbiAgICBhcHBseUJpbmRpbmdzVG9Ob2RlQW5kRGVzY2VuZGFudHNJbnRlcm5hbChyb290Q29udGV4dCwgcm9vdE5vZGUsIGFzeW5jQmluZGluZ3NBcHBsaWVkKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoYXN5bmNCaW5kaW5nc0FwcGxpZWQpXG4gIH1cblxuICBmdW5jdGlvbiBvbkJpbmRpbmdFcnJvciAoc3BlYykge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoc3BlYy5iaW5kaW5nS2V5KSB7XG4gICAgICAgICAgLy8gRHVyaW5nOiAnaW5pdCcgb3IgaW5pdGlhbCAndXBkYXRlJ1xuICAgICAgZXJyb3IgPSBzcGVjLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBzcGVjLm1lc3NhZ2UgPSAnVW5hYmxlIHRvIHByb2Nlc3MgYmluZGluZyBcIicgKyBzcGVjLmJpbmRpbmdLZXkgK1xuICAgICAgICAgICAgICAnXCIgaW4gYmluZGluZyBcIicgKyBzcGVjLmJpbmRpbmdLZXkgK1xuICAgICAgICAgICAgICAnXCJcXG5NZXNzYWdlOiAnICsgKGVycm9yLm1lc3NhZ2UgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRHVyaW5nOiAnYXBwbHknXG4gICAgICBlcnJvciA9IHNwZWMuZXJyb3JDYXB0dXJlZDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGV4dGVuZChlcnJvciwgc3BlYyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFJlYWQtb25seSBlcnJvciBlLmcuIGEgRE9NRVhjZXB0aW9uLlxuICAgICAgc3BlYy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcik7XG4gICAgICBleHRlbmQoZXJyb3IsIHNwZWMpO1xuICAgIH1cbiAgICBvcHRpb25zLm9uRXJyb3IoZXJyb3IpO1xuICB9XG5cbiAgLyogZXNsaW50IG5vLWNvbmQtYXNzaWduOiAwICovXG5cbiAgLy8gT2JqZWN0aXZlOlxuICAvLyAqIEdpdmVuIGFuIGlucHV0IGFycmF5LCBhIGNvbnRhaW5lciBET00gbm9kZSwgYW5kIGEgZnVuY3Rpb24gZnJvbSBhcnJheSBlbGVtZW50cyB0byBhcnJheXMgb2YgRE9NIG5vZGVzLFxuICAvLyAgIG1hcCB0aGUgYXJyYXkgZWxlbWVudHMgdG8gYXJyYXlzIG9mIERPTSBub2RlcywgY29uY2F0ZW5hdGUgdG9nZXRoZXIgYWxsIHRoZXNlIGFycmF5cywgYW5kIHVzZSB0aGVtIHRvIHBvcHVsYXRlIHRoZSBjb250YWluZXIgRE9NIG5vZGVcbiAgLy8gKiBOZXh0IHRpbWUgd2UncmUgZ2l2ZW4gdGhlIHNhbWUgY29tYmluYXRpb24gb2YgdGhpbmdzICh3aXRoIHRoZSBhcnJheSBwb3NzaWJseSBoYXZpbmcgbXV0YXRlZCksIHVwZGF0ZSB0aGUgY29udGFpbmVyIERPTSBub2RlXG4gIC8vICAgc28gdGhhdCBpdHMgY2hpbGRyZW4gaXMgYWdhaW4gdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIG1hcHBpbmdzIG9mIHRoZSBhcnJheSBlbGVtZW50cywgYnV0IGRvbid0IHJlLW1hcCBhbnkgYXJyYXkgZWxlbWVudHMgdGhhdCB3ZVxuICAvLyAgIHByZXZpb3VzbHkgbWFwcGVkIC0gcmV0YWluIHRob3NlIG5vZGVzLCBhbmQganVzdCBpbnNlcnQvZGVsZXRlIG90aGVyIG9uZXNcblxuICAvLyBcImNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2Rlc1wiIHdpbGwgYmUgaW52b2tlZCBhZnRlciBhbnkgXCJtYXBwaW5nXCItZ2VuZXJhdGVkIG5vZGVzIGFyZSBpbnNlcnRlZCBpbnRvIHRoZSBjb250YWluZXIgbm9kZVxuICAvLyBZb3UgY2FuIHVzZSB0aGlzLCBmb3IgZXhhbXBsZSwgdG8gYWN0aXZhdGUgYmluZGluZ3Mgb24gdGhvc2Ugbm9kZXMuXG5cbiAgZnVuY3Rpb24gbWFwTm9kZUFuZFJlZnJlc2hXaGVuQ2hhbmdlZCAoY29udGFpbmVyTm9kZSwgbWFwcGluZywgdmFsdWVUb01hcCwgY2FsbGJhY2tBZnRlckFkZGluZ05vZGVzLCBpbmRleCkge1xuICAgIC8vIE1hcCB0aGlzIGFycmF5IHZhbHVlIGluc2lkZSBhIGRlcGVuZGVudE9ic2VydmFibGUgc28gd2UgcmUtbWFwIHdoZW4gYW55IGRlcGVuZGVuY3kgY2hhbmdlc1xuICAgIHZhciBtYXBwZWROb2RlcyA9IFtdO1xuICAgIHZhciBkZXBlbmRlbnRPYnNlcnZhYmxlID0gY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5ld01hcHBlZE5vZGVzID0gbWFwcGluZyh2YWx1ZVRvTWFwLCBpbmRleCwgZml4VXBDb250aW51b3VzTm9kZUFycmF5KG1hcHBlZE5vZGVzLCBjb250YWluZXJOb2RlKSkgfHwgW107XG5cbiAgICAgIC8vIE9uIHN1YnNlcXVlbnQgZXZhbHVhdGlvbnMsIGp1c3QgcmVwbGFjZSB0aGUgcHJldmlvdXNseS1pbnNlcnRlZCBET00gbm9kZXNcbiAgICAgIGlmIChtYXBwZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlcGxhY2VEb21Ob2RlcyhtYXBwZWROb2RlcywgbmV3TWFwcGVkTm9kZXMpO1xuICAgICAgICBpZiAoY2FsbGJhY2tBZnRlckFkZGluZ05vZGVzKSB7IGlnbm9yZShjYWxsYmFja0FmdGVyQWRkaW5nTm9kZXMsIG51bGwsIFt2YWx1ZVRvTWFwLCBuZXdNYXBwZWROb2RlcywgaW5kZXhdKTsgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZXBsYWNlIHRoZSBjb250ZW50cyBvZiB0aGUgbWFwcGVkTm9kZXMgYXJyYXksIHRoZXJlYnkgdXBkYXRpbmcgdGhlIHJlY29yZFxuICAgICAgLy8gb2Ygd2hpY2ggbm9kZXMgd291bGQgYmUgZGVsZXRlZCBpZiB2YWx1ZVRvTWFwIHdhcyBpdHNlbGYgbGF0ZXIgcmVtb3ZlZFxuICAgICAgbWFwcGVkTm9kZXMubGVuZ3RoID0gMDtcbiAgICAgIGFycmF5UHVzaEFsbChtYXBwZWROb2RlcywgbmV3TWFwcGVkTm9kZXMpO1xuICAgIH0sIG51bGwsIHsgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBjb250YWluZXJOb2RlLCBkaXNwb3NlV2hlbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gIWFueURvbU5vZGVJc0F0dGFjaGVkVG9Eb2N1bWVudChtYXBwZWROb2RlcykgfSB9KTtcbiAgICByZXR1cm4geyBtYXBwZWROb2RlczogbWFwcGVkTm9kZXMsIGRlcGVuZGVudE9ic2VydmFibGU6IChkZXBlbmRlbnRPYnNlcnZhYmxlLmlzQWN0aXZlKCkgPyBkZXBlbmRlbnRPYnNlcnZhYmxlIDogdW5kZWZpbmVkKSB9XG4gIH1cblxuICB2YXIgbGFzdE1hcHBpbmdSZXN1bHREb21EYXRhS2V5ID0gbmV4dEtleSgpO1xuICBsZXQgZGVsZXRlZEl0ZW1EdW1teVZhbHVlID0gbmV4dEtleSgpO1xuXG4gIGZ1bmN0aW9uIHNldERvbU5vZGVDaGlsZHJlbkZyb21BcnJheU1hcHBpbmcgKGRvbU5vZGUsIGFycmF5LCBtYXBwaW5nLCBvcHRpb25zJCQxLCBjYWxsYmFja0FmdGVyQWRkaW5nTm9kZXMsIGVkaXRTY3JpcHQpIHtcbiAgICAvLyBDb21wYXJlIHRoZSBwcm92aWRlZCBhcnJheSBhZ2FpbnN0IHRoZSBwcmV2aW91cyBvbmVcbiAgICBhcnJheSA9IGFycmF5IHx8IFtdO1xuICAgIGlmICh0eXBlb2YgYXJyYXkubGVuZ3RoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgYXJyYXkgPSBbYXJyYXldO1xuICAgIH1cbiAgICBvcHRpb25zJCQxID0gb3B0aW9ucyQkMSB8fCB7fTtcbiAgICBsZXQgbGFzdE1hcHBpbmdSZXN1bHQgPSBnZXQoZG9tTm9kZSwgbGFzdE1hcHBpbmdSZXN1bHREb21EYXRhS2V5KTtcbiAgICBsZXQgaXNGaXJzdEV4ZWN1dGlvbiA9ICFsYXN0TWFwcGluZ1Jlc3VsdDtcblxuICAgIC8vIEJ1aWxkIHRoZSBuZXcgbWFwcGluZyByZXN1bHRcbiAgICB2YXIgbmV3TWFwcGluZ1Jlc3VsdCA9IFtdO1xuICAgIHZhciBsYXN0TWFwcGluZ1Jlc3VsdEluZGV4ID0gMDtcbiAgICB2YXIgbmV3TWFwcGluZ1Jlc3VsdEluZGV4ID0gMDtcblxuICAgIHZhciBub2Rlc1RvRGVsZXRlID0gW107XG4gICAgdmFyIGl0ZW1zVG9Qcm9jZXNzID0gW107XG4gICAgdmFyIGl0ZW1zRm9yQmVmb3JlUmVtb3ZlQ2FsbGJhY2tzID0gW107XG4gICAgdmFyIGl0ZW1zRm9yTW92ZUNhbGxiYWNrcyA9IFtdO1xuICAgIHZhciBpdGVtc0ZvckFmdGVyQWRkQ2FsbGJhY2tzID0gW107XG4gICAgdmFyIG1hcERhdGE7XG4gICAgbGV0IGNvdW50V2FpdGluZ0ZvclJlbW92ZSA9IDA7XG5cbiAgICBmdW5jdGlvbiBpdGVtQWRkZWQgKHZhbHVlKSB7XG4gICAgICBtYXBEYXRhID0geyBhcnJheUVudHJ5OiB2YWx1ZSwgaW5kZXhPYnNlcnZhYmxlOiBvYnNlcnZhYmxlKG5ld01hcHBpbmdSZXN1bHRJbmRleCsrKSB9O1xuICAgICAgbmV3TWFwcGluZ1Jlc3VsdC5wdXNoKG1hcERhdGEpO1xuICAgICAgaXRlbXNUb1Byb2Nlc3MucHVzaChtYXBEYXRhKTtcbiAgICAgIGlmICghaXNGaXJzdEV4ZWN1dGlvbikge1xuICAgICAgICBpdGVtc0ZvckFmdGVyQWRkQ2FsbGJhY2tzLnB1c2gobWFwRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlbU1vdmVkT3JSZXRhaW5lZCAob2xkUG9zaXRpb24pIHtcbiAgICAgIG1hcERhdGEgPSBsYXN0TWFwcGluZ1Jlc3VsdFtvbGRQb3NpdGlvbl07XG4gICAgICBpZiAobmV3TWFwcGluZ1Jlc3VsdEluZGV4ICE9PSBvbGRQb3NpdGlvbikge1xuICAgICAgICBpdGVtc0Zvck1vdmVDYWxsYmFja3MucHVzaChtYXBEYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIFNpbmNlIHVwZGF0aW5nIHRoZSBpbmRleCBtaWdodCBjaGFuZ2UgdGhlIG5vZGVzLCBkbyBzbyBiZWZvcmUgY2FsbGluZyBmaXhVcENvbnRpbnVvdXNOb2RlQXJyYXlcbiAgICAgIG1hcERhdGEuaW5kZXhPYnNlcnZhYmxlKG5ld01hcHBpbmdSZXN1bHRJbmRleCsrKTtcbiAgICAgIGZpeFVwQ29udGludW91c05vZGVBcnJheShtYXBEYXRhLm1hcHBlZE5vZGVzLCBkb21Ob2RlKTtcbiAgICAgIG5ld01hcHBpbmdSZXN1bHQucHVzaChtYXBEYXRhKTtcbiAgICAgIGl0ZW1zVG9Qcm9jZXNzLnB1c2gobWFwRGF0YSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrIChjYWxsYmFjaywgaXRlbXMpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIGFycmF5Rm9yRWFjaChpdGVtc1tpXS5tYXBwZWROb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUsIGksIGl0ZW1zW2ldLmFycmF5RW50cnkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRmlyc3RFeGVjdXRpb24pIHtcbiAgICAgIGFycmF5Rm9yRWFjaChhcnJheSwgaXRlbUFkZGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFlZGl0U2NyaXB0IHx8IChsYXN0TWFwcGluZ1Jlc3VsdCAmJiBsYXN0TWFwcGluZ1Jlc3VsdFsnX2NvdW50V2FpdGluZ0ZvclJlbW92ZSddKSkge1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBwcm92aWRlZCBhcnJheSBhZ2FpbnN0IHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgdmFyIGxhc3RBcnJheSA9IGlzRmlyc3RFeGVjdXRpb24gPyBbXSA6IGFycmF5TWFwKGxhc3RNYXBwaW5nUmVzdWx0LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5hcnJheUVudHJ5IH0pO1xuICAgICAgICB2YXIgY29tcGFyZU9wdGlvbnMgPSB7XG4gICAgICAgICAgJ2RvbnRMaW1pdE1vdmVzJzogb3B0aW9ucyQkMVsnZG9udExpbWl0TW92ZXMnXSxcbiAgICAgICAgICAnc3BhcnNlJzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBlZGl0U2NyaXB0ID0gY29tcGFyZUFycmF5cyhsYXN0QXJyYXksIGFycmF5LCBjb21wYXJlT3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBlZGl0U2NyaXB0SXRlbSwgbW92ZWRJbmRleCwgaXRlbUluZGV4OyBlZGl0U2NyaXB0SXRlbSA9IGVkaXRTY3JpcHRbaV07IGkrKykge1xuICAgICAgICBtb3ZlZEluZGV4ID0gZWRpdFNjcmlwdEl0ZW1bJ21vdmVkJ107XG4gICAgICAgIGl0ZW1JbmRleCA9IGVkaXRTY3JpcHRJdGVtWydpbmRleCddO1xuICAgICAgICBzd2l0Y2ggKGVkaXRTY3JpcHRJdGVtWydzdGF0dXMnXSkge1xuICAgICAgICAgIGNhc2UgJ2RlbGV0ZWQnOlxuICAgICAgICAgICAgd2hpbGUgKGxhc3RNYXBwaW5nUmVzdWx0SW5kZXggPCBpdGVtSW5kZXgpIHtcbiAgICAgICAgICAgICAgaXRlbU1vdmVkT3JSZXRhaW5lZChsYXN0TWFwcGluZ1Jlc3VsdEluZGV4KyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdmVkSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBtYXBEYXRhID0gbGFzdE1hcHBpbmdSZXN1bHRbbGFzdE1hcHBpbmdSZXN1bHRJbmRleF07XG5cbiAgICAgICAgICAgICAgLy8gU3RvcCB0cmFja2luZyBjaGFuZ2VzIHRvIHRoZSBtYXBwaW5nIGZvciB0aGVzZSBub2Rlc1xuICAgICAgICAgICAgICBpZiAobWFwRGF0YS5kZXBlbmRlbnRPYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAgICAgbWFwRGF0YS5kZXBlbmRlbnRPYnNlcnZhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBtYXBEYXRhLmRlcGVuZGVudE9ic2VydmFibGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBRdWV1ZSB0aGVzZSBub2RlcyBmb3IgbGF0ZXIgcmVtb3ZhbFxuICAgICAgICAgICAgICBpZiAoZml4VXBDb250aW51b3VzTm9kZUFycmF5KG1hcERhdGEubWFwcGVkTm9kZXMsIGRvbU5vZGUpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zJCQxWydiZWZvcmVSZW1vdmUnXSkge1xuICAgICAgICAgICAgICAgICAgbmV3TWFwcGluZ1Jlc3VsdC5wdXNoKG1hcERhdGEpO1xuICAgICAgICAgICAgICAgICAgaXRlbXNUb1Byb2Nlc3MucHVzaChtYXBEYXRhKTtcbiAgICAgICAgICAgICAgICAgIGNvdW50V2FpdGluZ0ZvclJlbW92ZSsrO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hcERhdGEuYXJyYXlFbnRyeSA9PT0gZGVsZXRlZEl0ZW1EdW1teVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcERhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNGb3JCZWZvcmVSZW1vdmVDYWxsYmFja3MucHVzaChtYXBEYXRhKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hcERhdGEpIHtcbiAgICAgICAgICAgICAgICAgIG5vZGVzVG9EZWxldGUucHVzaC5hcHBseShub2Rlc1RvRGVsZXRlLCBtYXBEYXRhLm1hcHBlZE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNYXBwaW5nUmVzdWx0SW5kZXgrKztcbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICBjYXNlICdhZGRlZCc6XG4gICAgICAgICAgICB3aGlsZSAobmV3TWFwcGluZ1Jlc3VsdEluZGV4IDwgaXRlbUluZGV4KSB7XG4gICAgICAgICAgICAgIGl0ZW1Nb3ZlZE9yUmV0YWluZWQobGFzdE1hcHBpbmdSZXN1bHRJbmRleCsrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3ZlZEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaXRlbU1vdmVkT3JSZXRhaW5lZChtb3ZlZEluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGl0ZW1BZGRlZChlZGl0U2NyaXB0SXRlbVsndmFsdWUnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChuZXdNYXBwaW5nUmVzdWx0SW5kZXggPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgaXRlbU1vdmVkT3JSZXRhaW5lZChsYXN0TWFwcGluZ1Jlc3VsdEluZGV4KyspO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWNvcmQgdGhhdCB0aGUgY3VycmVudCB2aWV3IG1heSBzdGlsbCBjb250YWluIGRlbGV0ZWQgaXRlbXNcbiAgICAgIC8vIGJlY2F1c2UgaXQgbWVhbnMgd2Ugd29uJ3QgYmUgYWJsZSB0byB1c2UgYSBwcm92aWRlZCBlZGl0U2NyaXB0LlxuICAgICAgbmV3TWFwcGluZ1Jlc3VsdFsnX2NvdW50V2FpdGluZ0ZvclJlbW92ZSddID0gY291bnRXYWl0aW5nRm9yUmVtb3ZlO1xuICAgIH1cblxuICAgIC8vIFN0b3JlIGEgY29weSBvZiB0aGUgYXJyYXkgaXRlbXMgd2UganVzdCBjb25zaWRlcmVkIHNvIHdlIGNhbiBkaWZmZXJlbmNlIGl0IG5leHQgdGltZVxuICAgIHNldChkb21Ob2RlLCBsYXN0TWFwcGluZ1Jlc3VsdERvbURhdGFLZXksIG5ld01hcHBpbmdSZXN1bHQpO1xuXG4gICAgLy8gQ2FsbCBiZWZvcmVNb3ZlIGZpcnN0IGJlZm9yZSBhbnkgY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSB0byB0aGUgRE9NXG4gICAgY2FsbENhbGxiYWNrKG9wdGlvbnMkJDFbJ2JlZm9yZU1vdmUnXSwgaXRlbXNGb3JNb3ZlQ2FsbGJhY2tzKTtcblxuICAgIC8vIE5leHQgcmVtb3ZlIG5vZGVzIGZvciBkZWxldGVkIGl0ZW1zIChvciBqdXN0IGNsZWFuIGlmIHRoZXJlJ3MgYSBiZWZvcmVSZW1vdmUgY2FsbGJhY2spXG4gICAgYXJyYXlGb3JFYWNoKG5vZGVzVG9EZWxldGUsIG9wdGlvbnMkJDFbJ2JlZm9yZVJlbW92ZSddID8gY2xlYW5Ob2RlIDogcmVtb3ZlTm9kZSk7XG5cbiAgICAvLyBOZXh0IGFkZC9yZW9yZGVyIHRoZSByZW1haW5pbmcgaXRlbXMgKHdpbGwgaW5jbHVkZSBkZWxldGVkIGl0ZW1zIGlmIHRoZXJlJ3MgYSBiZWZvcmVSZW1vdmUgY2FsbGJhY2spXG4gICAgaSA9IDA7XG4gICAgZm9yICh2YXIgbmV4dE5vZGUgPSBmaXJzdENoaWxkKGRvbU5vZGUpLCBsYXN0Tm9kZSwgbm9kZTsgbWFwRGF0YSA9IGl0ZW1zVG9Qcm9jZXNzW2ldOyBpKyspIHtcbiAgICAgIC8vIEdldCBub2RlcyBmb3IgbmV3bHkgYWRkZWQgaXRlbXNcbiAgICAgIGlmICghbWFwRGF0YS5tYXBwZWROb2RlcykgeyBleHRlbmQobWFwRGF0YSwgbWFwTm9kZUFuZFJlZnJlc2hXaGVuQ2hhbmdlZChkb21Ob2RlLCBtYXBwaW5nLCBtYXBEYXRhLmFycmF5RW50cnksIGNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2RlcywgbWFwRGF0YS5pbmRleE9ic2VydmFibGUpKTsgfVxuXG4gICAgICAvLyBQdXQgbm9kZXMgaW4gdGhlIHJpZ2h0IHBsYWNlIGlmIHRoZXkgYXJlbid0IHRoZXJlIGFscmVhZHlcbiAgICAgIGZvciAodmFyIGogPSAwOyBub2RlID0gbWFwRGF0YS5tYXBwZWROb2Rlc1tqXTsgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nLCBsYXN0Tm9kZSA9IG5vZGUsIGorKykge1xuICAgICAgICBpZiAobm9kZSAhPT0gbmV4dE5vZGUpIHsgaW5zZXJ0QWZ0ZXIoZG9tTm9kZSwgbm9kZSwgbGFzdE5vZGUpOyB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJ1biB0aGUgY2FsbGJhY2tzIGZvciBuZXdseSBhZGRlZCBub2RlcyAoZm9yIGV4YW1wbGUsIHRvIGFwcGx5IGJpbmRpbmdzLCBldGMuKVxuICAgICAgaWYgKCFtYXBEYXRhLmluaXRpYWxpemVkICYmIGNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2Rlcykge1xuICAgICAgICBjYWxsYmFja0FmdGVyQWRkaW5nTm9kZXMobWFwRGF0YS5hcnJheUVudHJ5LCBtYXBEYXRhLm1hcHBlZE5vZGVzLCBtYXBEYXRhLmluZGV4T2JzZXJ2YWJsZSk7XG4gICAgICAgIG1hcERhdGEuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZXJlJ3MgYSBiZWZvcmVSZW1vdmUgY2FsbGJhY2ssIGNhbGwgaXQgYWZ0ZXIgcmVvcmRlcmluZy5cbiAgICAvLyBOb3RlIHRoYXQgd2UgYXNzdW1lIHRoYXQgdGhlIGJlZm9yZVJlbW92ZSBjYWxsYmFjayB3aWxsIHVzdWFsbHkgYmUgdXNlZCB0byByZW1vdmUgdGhlIG5vZGVzIHVzaW5nXG4gICAgLy8gc29tZSBzb3J0IG9mIGFuaW1hdGlvbiwgd2hpY2ggaXMgd2h5IHdlIGZpcnN0IHJlb3JkZXIgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSByZW1vdmVkLiBJZiB0aGVcbiAgICAvLyBjYWxsYmFjayBpbnN0ZWFkIHJlbW92ZXMgdGhlIG5vZGVzIHJpZ2h0IGF3YXksIGl0IHdvdWxkIGJlIG1vcmUgZWZmaWNpZW50IHRvIHNraXAgcmVvcmRlcmluZyB0aGVtLlxuICAgIC8vIFBlcmhhcHMgd2UnbGwgbWFrZSB0aGF0IGNoYW5nZSBpbiB0aGUgZnV0dXJlIGlmIHRoaXMgc2NlbmFyaW8gYmVjb21lcyBtb3JlIGNvbW1vbi5cbiAgICBjYWxsQ2FsbGJhY2sob3B0aW9ucyQkMVsnYmVmb3JlUmVtb3ZlJ10sIGl0ZW1zRm9yQmVmb3JlUmVtb3ZlQ2FsbGJhY2tzKTtcblxuICAgIC8vIFJlcGxhY2UgdGhlIHN0b3JlZCB2YWx1ZXMgb2YgZGVsZXRlZCBpdGVtcyB3aXRoIGEgZHVtbXkgdmFsdWUuIFRoaXMgcHJvdmlkZXMgdHdvIGJlbmVmaXRzOiBpdCBtYXJrcyB0aGlzIGl0ZW1cbiAgICAvLyBhcyBhbHJlYWR5IFwicmVtb3ZlZFwiIHNvIHdlIHdvbid0IGNhbGwgYmVmb3JlUmVtb3ZlIGZvciBpdCBhZ2FpbiwgYW5kIGl0IGVuc3VyZXMgdGhhdCB0aGUgaXRlbSB3b24ndCBtYXRjaCB1cFxuICAgIC8vIHdpdGggYW4gYWN0dWFsIGl0ZW0gaW4gdGhlIGFycmF5IGFuZCBhcHBlYXIgYXMgXCJyZXRhaW5lZFwiIG9yIFwibW92ZWRcIi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXNGb3JCZWZvcmVSZW1vdmVDYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIGl0ZW1zRm9yQmVmb3JlUmVtb3ZlQ2FsbGJhY2tzW2ldLmFycmF5RW50cnkgPSBkZWxldGVkSXRlbUR1bW15VmFsdWU7XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSBjYWxsIGFmdGVyTW92ZSBhbmQgYWZ0ZXJBZGQgY2FsbGJhY2tzXG4gICAgY2FsbENhbGxiYWNrKG9wdGlvbnMkJDFbJ2FmdGVyTW92ZSddLCBpdGVtc0Zvck1vdmVDYWxsYmFja3MpO1xuICAgIGNhbGxDYWxsYmFjayhvcHRpb25zJCQxWydhZnRlckFkZCddLCBpdGVtc0ZvckFmdGVyQWRkQ2FsbGJhY2tzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIERlc2NlbmRhbnRCaW5kaW5nSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGJpbmRpbmdzIHRoYXQgY29udHJvbFxuICAgKiBkZXNjZW5kYW50cywgc3VjaCBhcyB0aGUgYGlmYCwgYHdpdGhgLCBgY29tcG9uZW50YCwgYGZvcmVhY2hgIGFuZCBgdGVtcGxhdGVgXG4gICAqIGJpbmRpbmdzLlxuICAgKi9cbiAgY2xhc3MgRGVzY2VuZGFudEJpbmRpbmdIYW5kbGVyIGV4dGVuZHMgQXN5bmNCaW5kaW5nSGFuZGxlciB7XG4gICAgZ2V0IGNvbnRyb2xzRGVzY2VuZGFudHMgKCkgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgICBhc3luYyBhcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50cyAoY2hpbGRDb250ZXh0LCBjYWxsYmFjaykge1xuICAgICAgY29uc3QgYmluZGluZ1Jlc3VsdCA9IGFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzKGNoaWxkQ29udGV4dCwgdGhpcy4kZWxlbWVudCk7XG4gICAgICBpZiAoYmluZGluZ1Jlc3VsdC5pc1N5bmMpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nQ29tcGxldGlvbiA9IGJpbmRpbmdSZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBiaW5kaW5nUmVzdWx0LmNvbXBsZXRpb25Qcm9taXNlO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGJpbmRpbmdSZXN1bHQpOyB9XG4gICAgICB0aGlzLmNvbXBsZXRlQmluZGluZyhiaW5kaW5nUmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICAvLyBBIHRlbXBsYXRlIHNvdXJjZSByZXByZXNlbnRzIGEgcmVhZC93cml0ZSB3YXkgb2YgYWNjZXNzaW5nIGEgdGVtcGxhdGUuIFRoaXMgaXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciB0ZW1wbGF0ZSBsb2FkaW5nL3NhdmluZ1xuXG4gIC8vIC0tLS0ga28udGVtcGxhdGVTb3VyY2VzLmRvbUVsZW1lbnQgLS0tLS1cblxuICAvLyB0ZW1wbGF0ZSB0eXBlc1xuICB2YXIgdGVtcGxhdGVTY3JpcHQgPSAxLFxuICAgIHRlbXBsYXRlVGV4dEFyZWEgPSAyLFxuICAgIHRlbXBsYXRlVGVtcGxhdGUgPSAzLFxuICAgIHRlbXBsYXRlRWxlbWVudCA9IDQ7XG5cbiAgZnVuY3Rpb24gZG9tRWxlbWVudCAoZWxlbWVudCkge1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHsgcmV0dXJuIH1cbiAgICB2YXIgdGFnTmFtZUxvd2VyJCQxID0gdGFnTmFtZUxvd2VyKGVsZW1lbnQpO1xuICAgIHRoaXMudGVtcGxhdGVUeXBlID1cbiAgICAgICAgICB0YWdOYW1lTG93ZXIkJDEgPT09ICdzY3JpcHQnID8gdGVtcGxhdGVTY3JpcHRcbiAgICAgICAgICA6IHRhZ05hbWVMb3dlciQkMSA9PT0gJ3RleHRhcmVhJyA/IHRlbXBsYXRlVGV4dEFyZWFcbiAgICAgICAgICAgICAgLy8gRm9yIGJyb3dzZXJzIHdpdGggcHJvcGVyIDx0ZW1wbGF0ZT4gZWxlbWVudCBzdXBwb3J0LCB3aGVyZSB0aGUgLmNvbnRlbnQgcHJvcGVydHkgZ2l2ZXMgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAgICAgIDogdGFnTmFtZUxvd2VyJCQxID09ICd0ZW1wbGF0ZScgJiYgZWxlbWVudC5jb250ZW50ICYmIGVsZW1lbnQuY29udGVudC5ub2RlVHlwZSA9PT0gMTEgPyB0ZW1wbGF0ZVRlbXBsYXRlXG4gICAgICAgICAgOiB0ZW1wbGF0ZUVsZW1lbnQ7XG4gIH1cblxuICBkb21FbGVtZW50LnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKC8qIHZhbHVlVG9Xcml0ZSAqLykge1xuICAgIHZhciBlbGVtQ29udGVudHNQcm9wZXJ0eSA9IHRoaXMudGVtcGxhdGVUeXBlID09PSB0ZW1wbGF0ZVNjcmlwdCA/ICd0ZXh0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50ZW1wbGF0ZVR5cGUgPT09IHRlbXBsYXRlVGV4dEFyZWEgPyAndmFsdWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnaW5uZXJIVE1MJztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnRbZWxlbUNvbnRlbnRzUHJvcGVydHldXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWx1ZVRvV3JpdGUgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAoZWxlbUNvbnRlbnRzUHJvcGVydHkgPT09ICdpbm5lckhUTUwnKSB7IHNldEh0bWwodGhpcy5kb21FbGVtZW50LCB2YWx1ZVRvV3JpdGUpOyB9IGVsc2UgeyB0aGlzLmRvbUVsZW1lbnRbZWxlbUNvbnRlbnRzUHJvcGVydHldID0gdmFsdWVUb1dyaXRlOyB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBkYXRhRG9tRGF0YVByZWZpeCA9IG5leHRLZXkoKSArICdfJztcbiAgZG9tRWxlbWVudC5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uIChrZXkgLyosIHZhbHVlVG9Xcml0ZSAqLykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMuZG9tRWxlbWVudCwgZGF0YURvbURhdGFQcmVmaXggKyBrZXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNldCh0aGlzLmRvbUVsZW1lbnQsIGRhdGFEb21EYXRhUHJlZml4ICsga2V5LCBhcmd1bWVudHNbMV0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdGVtcGxhdGVzRG9tRGF0YUtleSA9IG5leHRLZXkoKTtcbiAgZnVuY3Rpb24gZ2V0VGVtcGxhdGVEb21EYXRhIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGdldChlbGVtZW50LCB0ZW1wbGF0ZXNEb21EYXRhS2V5KSB8fCB7fVxuICB9XG4gIGZ1bmN0aW9uIHNldFRlbXBsYXRlRG9tRGF0YSAoZWxlbWVudCwgZGF0YSkge1xuICAgIHNldChlbGVtZW50LCB0ZW1wbGF0ZXNEb21EYXRhS2V5LCBkYXRhKTtcbiAgfVxuXG4gIGRvbUVsZW1lbnQucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24gKC8qIHZhbHVlVG9Xcml0ZSAqLykge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5kb21FbGVtZW50O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlRGF0YSA9IGdldFRlbXBsYXRlRG9tRGF0YShlbGVtZW50KTtcbiAgICAgIGxldCBub2RlcyA9IHRlbXBsYXRlRGF0YS5jb250YWluZXJEYXRhIHx8IChcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVR5cGUgPT09IHRlbXBsYXRlVGVtcGxhdGUgPyBlbGVtZW50LmNvbnRlbnQgOlxuICAgICAgICB0aGlzLnRlbXBsYXRlVHlwZSA9PT0gdGVtcGxhdGVFbGVtZW50ID8gZWxlbWVudCA6XG4gICAgICAgIHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICAgIGlmICghbm9kZXMgfHwgdGVtcGxhdGVEYXRhLmFsd2F5c0NoZWNrVGV4dCkge1xuICAgICAgLy8gSWYgdGhlIHRlbXBsYXRlIGlzIGFzc29jaWF0ZWQgd2l0aCBhbiBlbGVtZW50IHRoYXQgc3RvcmVzIHRoZSB0ZW1wbGF0ZSBhcyB0ZXh0LFxuICAgICAgLy8gcGFyc2UgYW5kIGNhY2hlIHRoZSBub2RlcyB3aGVuZXZlciB0aGVyZSdzIG5ldyB0ZXh0IGNvbnRlbnQgYXZhaWxhYmxlLiBUaGlzIGFsbG93c1xuICAgICAgLy8gdGhlIHVzZXIgdG8gdXBkYXRlIHRoZSB0ZW1wbGF0ZSBjb250ZW50IGJ5IHVwZGF0aW5nIHRoZSB0ZXh0IG9mIHRlbXBsYXRlIG5vZGUuXG4gICAgICAgIGNvbnN0IHRleHQgPSB0aGlzWyd0ZXh0J10oKTtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICBub2RlcyA9IHBhcnNlSHRtbEZvclRlbXBsYXRlTm9kZXModGV4dCwgZWxlbWVudC5vd25lckRvY3VtZW50KTtcbiAgICAgICAgICB0aGlzWyd0ZXh0J10oJycpOyAgIC8vIGNsZWFyIHRoZSB0ZXh0IGZyb20gdGhlIG5vZGVcbiAgICAgICAgICBzZXRUZW1wbGF0ZURvbURhdGEoZWxlbWVudCwge2NvbnRhaW5lckRhdGE6IG5vZGVzLCBhbHdheXNDaGVja1RleHQ6IHRydWV9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZhbHVlVG9Xcml0ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHNldFRlbXBsYXRlRG9tRGF0YShlbGVtZW50LCB7Y29udGFpbmVyRGF0YTogdmFsdWVUb1dyaXRlfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIC0tLS0ga28udGVtcGxhdGVTb3VyY2VzLmFub255bW91c1RlbXBsYXRlIC0tLS0tXG4gIC8vIEFub255bW91cyB0ZW1wbGF0ZXMgYXJlIG5vcm1hbGx5IHNhdmVkL3JldHJpZXZlZCBhcyBET00gbm9kZXMgdGhyb3VnaCBcIm5vZGVzXCIuXG4gIC8vIEZvciBjb21wYXRpYmlsaXR5LCB5b3UgY2FuIGFsc28gcmVhZCBcInRleHRcIjsgaXQgd2lsbCBiZSBzZXJpYWxpemVkIGZyb20gdGhlIG5vZGVzIG9uIGRlbWFuZC5cbiAgLy8gV3JpdGluZyB0byBcInRleHRcIiBpcyBzdGlsbCBzdXBwb3J0ZWQsIGJ1dCB0aGVuIHRoZSB0ZW1wbGF0ZSBkYXRhIHdpbGwgbm90IGJlIGF2YWlsYWJsZSBhcyBET00gbm9kZXMuXG5cbiAgZnVuY3Rpb24gYW5vbnltb3VzVGVtcGxhdGUgKGVsZW1lbnQpIHtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBlbGVtZW50O1xuICB9XG5cbiAgYW5vbnltb3VzVGVtcGxhdGUucHJvdG90eXBlID0gbmV3IGRvbUVsZW1lbnQoKTtcbiAgYW5vbnltb3VzVGVtcGxhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYW5vbnltb3VzVGVtcGxhdGU7XG4gIGFub255bW91c1RlbXBsYXRlLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKC8qIHZhbHVlVG9Xcml0ZSAqLykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcbiAgICAgIHZhciB0ZW1wbGF0ZURhdGEgPSBnZXRUZW1wbGF0ZURvbURhdGEodGhpcy5kb21FbGVtZW50KTtcbiAgICAgIGlmICh0ZW1wbGF0ZURhdGEudGV4dERhdGEgPT09IHVuZGVmaW5lZCAmJiB0ZW1wbGF0ZURhdGEuY29udGFpbmVyRGF0YSkgeyB0ZW1wbGF0ZURhdGEudGV4dERhdGEgPSB0ZW1wbGF0ZURhdGEuY29udGFpbmVyRGF0YS5pbm5lckhUTUw7IH1cbiAgICAgIHJldHVybiB0ZW1wbGF0ZURhdGEudGV4dERhdGFcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZhbHVlVG9Xcml0ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHNldFRlbXBsYXRlRG9tRGF0YSh0aGlzLmRvbUVsZW1lbnQsIHt0ZXh0RGF0YTogdmFsdWVUb1dyaXRlfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIElmIHlvdSB3YW50IHRvIG1ha2UgYSBjdXN0b20gdGVtcGxhdGUgZW5naW5lLFxuXG4gIGZ1bmN0aW9uIHRlbXBsYXRlRW5naW5lICgpIHsgfVxuICBleHRlbmQodGVtcGxhdGVFbmdpbmUucHJvdG90eXBlLCB7XG4gICAgcmVuZGVyVGVtcGxhdGVTb3VyY2U6IGZ1bmN0aW9uICh0ZW1wbGF0ZVNvdXJjZSwgYmluZGluZ0NvbnRleHQsIG9wdGlvbnMkJDEsIHRlbXBsYXRlRG9jdW1lbnQpIHtcbiAgICAgIG9wdGlvbnMkJDEub25FcnJvcignT3ZlcnJpZGUgcmVuZGVyVGVtcGxhdGVTb3VyY2UnKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlSmF2YVNjcmlwdEV2YWx1YXRvckJsb2NrOiBmdW5jdGlvbiAoc2NyaXB0KSB7XG4gICAgICBvcHRpb25zLm9uRXJyb3IoJ092ZXJyaWRlIGNyZWF0ZUphdmFTY3JpcHRFdmFsdWF0b3JCbG9jaycpO1xuICAgIH0sXG5cbiAgICBtYWtlVGVtcGxhdGVTb3VyY2U6IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgdGVtcGxhdGVEb2N1bWVudCkge1xuICAgICAgICAvLyBOYW1lZCB0ZW1wbGF0ZVxuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGVtcGxhdGVEb2N1bWVudCA9IHRlbXBsYXRlRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgICAgIHZhciBlbGVtID0gdGVtcGxhdGVEb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0ZW1wbGF0ZSk7XG4gICAgICAgIGlmICghZWxlbSkgeyBvcHRpb25zLm9uRXJyb3IoJ0Nhbm5vdCBmaW5kIHRlbXBsYXRlIHdpdGggSUQgJyArIHRlbXBsYXRlKTsgfVxuICAgICAgICByZXR1cm4gbmV3IGRvbUVsZW1lbnQoZWxlbSlcbiAgICAgIH0gZWxzZSBpZiAoKHRlbXBsYXRlLm5vZGVUeXBlID09IDEpIHx8ICh0ZW1wbGF0ZS5ub2RlVHlwZSA9PSA4KSkge1xuICAgICAgICAgICAgLy8gQW5vbnltb3VzIHRlbXBsYXRlXG4gICAgICAgIHJldHVybiBuZXcgYW5vbnltb3VzVGVtcGxhdGUodGVtcGxhdGUpXG4gICAgICB9IGVsc2UgeyBvcHRpb25zLm9uRXJyb3IoJ1Vua25vd24gdGVtcGxhdGUgdHlwZTogJyArIHRlbXBsYXRlKTsgfVxuICAgIH0sXG5cbiAgICByZW5kZXJUZW1wbGF0ZTogZnVuY3Rpb24gKHRlbXBsYXRlLCBiaW5kaW5nQ29udGV4dCwgb3B0aW9ucyQkMSwgdGVtcGxhdGVEb2N1bWVudCkge1xuICAgICAgdmFyIHRlbXBsYXRlU291cmNlID0gdGhpc1snbWFrZVRlbXBsYXRlU291cmNlJ10odGVtcGxhdGUsIHRlbXBsYXRlRG9jdW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVGVtcGxhdGVTb3VyY2UodGVtcGxhdGVTb3VyY2UsIGJpbmRpbmdDb250ZXh0LCBvcHRpb25zJCQxLCB0ZW1wbGF0ZURvY3VtZW50KVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIF90ZW1wbGF0ZUVuZ2luZTtcbiAgY29uc3QgY2xlYW5Db250YWluZXJEb21EYXRhS2V5ID0gbmV4dEtleSgpO1xuXG4gIGZ1bmN0aW9uIHNldFRlbXBsYXRlRW5naW5lICh0RW5naW5lKSB7XG4gICAgaWYgKCh0RW5naW5lICE9PSB1bmRlZmluZWQpICYmICEodEVuZ2luZSBpbnN0YW5jZW9mIHRlbXBsYXRlRW5naW5lKSkge1xuICAgICAgICAgIC8vIFRPRE86IGtvLnRlbXBsYXRlRW5naW5lIHRvIGFwcHJvcHJpYXRlIG5hbWVcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGVtcGxhdGVFbmdpbmUgbXVzdCBpbmhlcml0IGZyb20ga28udGVtcGxhdGVFbmdpbmUnKVxuICAgIH1cbiAgICBfdGVtcGxhdGVFbmdpbmUgPSB0RW5naW5lO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRm9yRWFjaE5vZGVJbkNvbnRpbnVvdXNSYW5nZSAoZmlyc3ROb2RlLCBsYXN0Tm9kZSwgYWN0aW9uKSB7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IG5leHRJblF1ZXVlID0gZmlyc3ROb2RlO1xuICAgIGxldCBmaXJzdE91dE9mUmFuZ2VOb2RlID0gbmV4dFNpYmxpbmcobGFzdE5vZGUpO1xuICAgIHdoaWxlIChuZXh0SW5RdWV1ZSAmJiAoKG5vZGUgPSBuZXh0SW5RdWV1ZSkgIT09IGZpcnN0T3V0T2ZSYW5nZU5vZGUpKSB7XG4gICAgICBuZXh0SW5RdWV1ZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgYWN0aW9uKG5vZGUsIG5leHRJblF1ZXVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhY3RpdmF0ZUJpbmRpbmdzT25Db250aW51b3VzTm9kZUFycmF5IChjb250aW51b3VzTm9kZUFycmF5LCBiaW5kaW5nQ29udGV4dCQkMSwgYWZ0ZXJCaW5kaW5nQ2FsbGJhY2spIHtcbiAgICAvLyBUbyBiZSB1c2VkIG9uIGFueSBub2RlcyB0aGF0IGhhdmUgYmVlbiByZW5kZXJlZCBieSBhIHRlbXBsYXRlIGFuZCBoYXZlIGJlZW4gaW5zZXJ0ZWQgaW50byBzb21lIHBhcmVudCBlbGVtZW50XG4gICAgLy8gV2Fsa3MgdGhyb3VnaCBjb250aW51b3VzTm9kZUFycmF5ICh3aGljaCAqbXVzdCogYmUgY29udGludW91cywgaS5lLiwgYW4gdW5pbnRlcnJ1cHRlZCBzZXF1ZW5jZSBvZiBzaWJsaW5nIG5vZGVzLCBiZWNhdXNlXG4gICAgLy8gdGhlIGFsZ29yaXRobSBmb3Igd2Fsa2luZyB0aGVtIHJlbGllcyBvbiB0aGlzKSwgYW5kIGZvciBlYWNoIHRvcC1sZXZlbCBpdGVtIGluIHRoZSB2aXJ0dWFsLWVsZW1lbnQgc2Vuc2UsXG4gICAgLy8gKDEpIERvZXMgYSByZWd1bGFyIFwiYXBwbHlCaW5kaW5nc1wiIHRvIGFzc29jaWF0ZSBiaW5kaW5nQ29udGV4dCB3aXRoIHRoaXMgbm9kZSBhbmQgdG8gYWN0aXZhdGUgYW55IG5vbi1tZW1vaXplZCBiaW5kaW5nc1xuICAgIC8vICgyKSBVbm1lbW9pemVzIGFueSBtZW1vcyBpbiB0aGUgRE9NIHN1YnRyZWUgKGUuZy4sIHRvIGFjdGl2YXRlIGJpbmRpbmdzIHRoYXQgaGFkIGJlZW4gbWVtb2l6ZWQgZHVyaW5nIHRlbXBsYXRlIHJld3JpdGluZylcblxuICAgIGlmIChjb250aW51b3VzTm9kZUFycmF5Lmxlbmd0aCkge1xuICAgICAgdmFyIGZpcnN0Tm9kZSA9IGNvbnRpbnVvdXNOb2RlQXJyYXlbMF07XG4gICAgICB2YXIgbGFzdE5vZGUgPSBjb250aW51b3VzTm9kZUFycmF5W2NvbnRpbnVvdXNOb2RlQXJyYXkubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IGZpcnN0Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgdmFyIHByb3ZpZGVyID0gb3B0aW9ucy5iaW5kaW5nUHJvdmlkZXJJbnN0YW5jZTtcbiAgICAgIHZhciBwcmVwcm9jZXNzTm9kZSA9IHByb3ZpZGVyLnByZXByb2Nlc3NOb2RlO1xuXG4gICAgICBpZiAocHJlcHJvY2Vzc05vZGUpIHtcbiAgICAgICAgaW52b2tlRm9yRWFjaE5vZGVJbkNvbnRpbnVvdXNSYW5nZShmaXJzdE5vZGUsIGxhc3ROb2RlLCBmdW5jdGlvbiAobm9kZSwgbmV4dE5vZGVJblJhbmdlKSB7XG4gICAgICAgICAgdmFyIG5vZGVQcmV2aW91c1NpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICB2YXIgbmV3Tm9kZXMgPSBwcmVwcm9jZXNzTm9kZS5jYWxsKHByb3ZpZGVyLCBub2RlKTtcbiAgICAgICAgICBpZiAobmV3Tm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBmaXJzdE5vZGUpIHsgZmlyc3ROb2RlID0gbmV3Tm9kZXNbMF0gfHwgbmV4dE5vZGVJblJhbmdlOyB9XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gbGFzdE5vZGUpIHsgbGFzdE5vZGUgPSBuZXdOb2Rlc1tuZXdOb2Rlcy5sZW5ndGggLSAxXSB8fCBub2RlUHJldmlvdXNTaWJsaW5nOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBCZWNhdXNlIHByZXByb2Nlc3NOb2RlIGNhbiBjaGFuZ2UgdGhlIG5vZGVzLCBpbmNsdWRpbmcgdGhlIGZpcnN0IGFuZCBsYXN0IG5vZGVzLCB1cGRhdGUgY29udGludW91c05vZGVBcnJheSB0byBtYXRjaC5cbiAgICAgICAgLy8gV2UgbmVlZCB0aGUgZnVsbCBzZXQsIGluY2x1ZGluZyBpbm5lciBub2RlcywgYmVjYXVzZSB0aGUgdW5tZW1vaXplIHN0ZXAgbWlnaHQgcmVtb3ZlIHRoZSBmaXJzdCBub2RlIChhbmQgc28gdGhlIHJlYWxcbiAgICAgICAgLy8gZmlyc3Qgbm9kZSBuZWVkcyB0byBiZSBpbiB0aGUgYXJyYXkpLlxuICAgICAgICBjb250aW51b3VzTm9kZUFycmF5Lmxlbmd0aCA9IDA7XG4gICAgICAgIGlmICghZmlyc3ROb2RlKSB7IC8vIHByZXByb2Nlc3NOb2RlIG1pZ2h0IGhhdmUgcmVtb3ZlZCBhbGwgdGhlIG5vZGVzLCBpbiB3aGljaCBjYXNlIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0Tm9kZSA9PT0gbGFzdE5vZGUpIHtcbiAgICAgICAgICBjb250aW51b3VzTm9kZUFycmF5LnB1c2goZmlyc3ROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250aW51b3VzTm9kZUFycmF5LnB1c2goZmlyc3ROb2RlLCBsYXN0Tm9kZSk7XG4gICAgICAgICAgZml4VXBDb250aW51b3VzTm9kZUFycmF5KGNvbnRpbnVvdXNOb2RlQXJyYXksIHBhcmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5lZWQgdG8gYXBwbHlCaW5kaW5ncyAqYmVmb3JlKiB1bm1lbW96aWF0aW9uLCBiZWNhdXNlIHVubWVtb2l6YXRpb24gbWlnaHQgaW50cm9kdWNlIGV4dHJhIG5vZGVzICh0aGF0IHdlIGRvbid0IHdhbnQgdG8gcmUtYmluZClcbiAgICAgIC8vIHdoZXJlYXMgYSByZWd1bGFyIGFwcGx5QmluZGluZ3Mgd29uJ3QgaW50cm9kdWNlIG5ldyBtZW1vaXplZCBub2Rlc1xuICAgICAgaW52b2tlRm9yRWFjaE5vZGVJbkNvbnRpbnVvdXNSYW5nZShmaXJzdE5vZGUsIGxhc3ROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSB8fCBub2RlLm5vZGVUeXBlID09PSA4KSB7IGFwcGx5QmluZGluZ3MoYmluZGluZ0NvbnRleHQkJDEsIG5vZGUpLnRoZW4oYWZ0ZXJCaW5kaW5nQ2FsbGJhY2spOyB9XG4gICAgICB9KTtcbiAgICAgIGludm9rZUZvckVhY2hOb2RlSW5Db250aW51b3VzUmFuZ2UoZmlyc3ROb2RlLCBsYXN0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgfHwgbm9kZS5ub2RlVHlwZSA9PT0gOCkgeyB1bm1lbW9pemVEb21Ob2RlQW5kRGVzY2VuZGFudHMobm9kZSwgW2JpbmRpbmdDb250ZXh0JCQxXSk7IH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgYW55IGNoYW5nZXMgZG9uZSBieSBhcHBseUJpbmRpbmdzIG9yIHVubWVtb2l6ZSBhcmUgcmVmbGVjdGVkIGluIHRoZSBhcnJheVxuICAgICAgZml4VXBDb250aW51b3VzTm9kZUFycmF5KGNvbnRpbnVvdXNOb2RlQXJyYXksIHBhcmVudE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpcnN0Tm9kZUZyb21Qb3NzaWJsZUFycmF5IChub2RlT3JOb2RlQXJyYXkpIHtcbiAgICByZXR1cm4gbm9kZU9yTm9kZUFycmF5Lm5vZGVUeXBlID8gbm9kZU9yTm9kZUFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbm9kZU9yTm9kZUFycmF5Lmxlbmd0aCA+IDAgPyBub2RlT3JOb2RlQXJyYXlbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBleGVjdXRlVGVtcGxhdGUgKHRhcmdldE5vZGVPck5vZGVBcnJheSwgcmVuZGVyTW9kZSwgdGVtcGxhdGUsIGJpbmRpbmdDb250ZXh0JCQxLCBvcHRpb25zJCQxLCBhZnRlckJpbmRpbmdDYWxsYmFjaykge1xuICAgIG9wdGlvbnMkJDEgPSBvcHRpb25zJCQxIHx8IHt9O1xuICAgIHZhciBmaXJzdFRhcmdldE5vZGUgPSB0YXJnZXROb2RlT3JOb2RlQXJyYXkgJiYgZ2V0Rmlyc3ROb2RlRnJvbVBvc3NpYmxlQXJyYXkodGFyZ2V0Tm9kZU9yTm9kZUFycmF5KTtcbiAgICB2YXIgdGVtcGxhdGVEb2N1bWVudCA9IChmaXJzdFRhcmdldE5vZGUgfHwgdGVtcGxhdGUgfHwge30pLm93bmVyRG9jdW1lbnQ7XG4gICAgdmFyIHRlbXBsYXRlRW5naW5lVG9Vc2UgPSAob3B0aW9ucyQkMS50ZW1wbGF0ZUVuZ2luZSB8fCBfdGVtcGxhdGVFbmdpbmUpO1xuICAgIHZhciByZW5kZXJlZE5vZGVzQXJyYXkgPSB0ZW1wbGF0ZUVuZ2luZVRvVXNlLnJlbmRlclRlbXBsYXRlKHRlbXBsYXRlLCBiaW5kaW5nQ29udGV4dCQkMSwgb3B0aW9ucyQkMSwgdGVtcGxhdGVEb2N1bWVudCk7XG5cbiAgICAgIC8vIExvb3NlbHkgY2hlY2sgcmVzdWx0IGlzIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICAgIGlmICgodHlwZW9mIHJlbmRlcmVkTm9kZXNBcnJheS5sZW5ndGggIT09ICdudW1iZXInKSB8fCAocmVuZGVyZWROb2Rlc0FycmF5Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHJlbmRlcmVkTm9kZXNBcnJheVswXS5ub2RlVHlwZSAhPT0gJ251bWJlcicpKSB7IHRocm93IG5ldyBFcnJvcignVGVtcGxhdGUgZW5naW5lIG11c3QgcmV0dXJuIGFuIGFycmF5IG9mIERPTSBub2RlcycpIH1cblxuICAgIHZhciBoYXZlQWRkZWROb2Rlc1RvUGFyZW50ID0gZmFsc2U7XG4gICAgc3dpdGNoIChyZW5kZXJNb2RlKSB7XG4gICAgICBjYXNlICdyZXBsYWNlQ2hpbGRyZW4nOlxuICAgICAgICBzZXREb21Ob2RlQ2hpbGRyZW4kMSh0YXJnZXROb2RlT3JOb2RlQXJyYXksIHJlbmRlcmVkTm9kZXNBcnJheSk7XG4gICAgICAgIGhhdmVBZGRlZE5vZGVzVG9QYXJlbnQgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncmVwbGFjZU5vZGUnOlxuICAgICAgICByZXBsYWNlRG9tTm9kZXModGFyZ2V0Tm9kZU9yTm9kZUFycmF5LCByZW5kZXJlZE5vZGVzQXJyYXkpO1xuICAgICAgICBoYXZlQWRkZWROb2Rlc1RvUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2lnbm9yZVRhcmdldE5vZGUnOiBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHJlbmRlck1vZGU6ICcgKyByZW5kZXJNb2RlKVxuICAgIH1cblxuICAgIGlmIChoYXZlQWRkZWROb2Rlc1RvUGFyZW50KSB7XG4gICAgICBhY3RpdmF0ZUJpbmRpbmdzT25Db250aW51b3VzTm9kZUFycmF5KHJlbmRlcmVkTm9kZXNBcnJheSwgYmluZGluZ0NvbnRleHQkJDEsIGFmdGVyQmluZGluZ0NhbGxiYWNrKTtcbiAgICAgIGlmIChvcHRpb25zJCQxLmFmdGVyUmVuZGVyKSB7IGlnbm9yZShvcHRpb25zJCQxLmFmdGVyUmVuZGVyLCBudWxsLCBbcmVuZGVyZWROb2Rlc0FycmF5LCBiaW5kaW5nQ29udGV4dCQkMVsnJGRhdGEnXV0pOyB9XG4gICAgICBpZiAocmVuZGVyTW9kZSA9PT0gJ3JlcGxhY2VDaGlsZHJlbicpIHtcbiAgICAgICAgYmluZGluZ0V2ZW50Lm5vdGlmeSh0YXJnZXROb2RlT3JOb2RlQXJyYXksIGJpbmRpbmdFdmVudC5jaGlsZHJlbkNvbXBsZXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyZWROb2Rlc0FycmF5XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlVGVtcGxhdGVOYW1lICh0ZW1wbGF0ZSwgZGF0YSwgY29udGV4dCkge1xuICAgICAgLy8gVGhlIHRlbXBsYXRlIGNhbiBiZSBzcGVjaWZpZWQgYXM6XG4gICAgaWYgKGlzT2JzZXJ2YWJsZSh0ZW1wbGF0ZSkpIHtcbiAgICAgIC8vIDEuIEFuIG9ic2VydmFibGUsIHdpdGggc3RyaW5nIHZhbHVlXG4gICAgICByZXR1cm4gdGVtcGxhdGUoKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyAyLiBBIGZ1bmN0aW9uIG9mIChkYXRhLCBjb250ZXh0KSByZXR1cm5pbmcgYSBzdHJpbmdcbiAgICAgIHJldHVybiB0ZW1wbGF0ZShkYXRhLCBjb250ZXh0KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAzLiBBIHN0cmluZ1xuICAgICAgcmV0dXJuIHRlbXBsYXRlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyVGVtcGxhdGUgKHRlbXBsYXRlLCBkYXRhT3JCaW5kaW5nQ29udGV4dCwgb3B0aW9ucyQkMSwgdGFyZ2V0Tm9kZU9yTm9kZUFycmF5LCByZW5kZXJNb2RlLCBhZnRlckJpbmRpbmdDYWxsYmFjaykge1xuICAgIG9wdGlvbnMkJDEgPSBvcHRpb25zJCQxIHx8IHt9O1xuICAgIGlmICgob3B0aW9ucyQkMS50ZW1wbGF0ZUVuZ2luZSB8fCBfdGVtcGxhdGVFbmdpbmUpID09PSB1bmRlZmluZWQpIHsgdGhyb3cgbmV3IEVycm9yKCdTZXQgYSB0ZW1wbGF0ZSBlbmdpbmUgYmVmb3JlIGNhbGxpbmcgcmVuZGVyVGVtcGxhdGUnKSB9XG4gICAgcmVuZGVyTW9kZSA9IHJlbmRlck1vZGUgfHwgJ3JlcGxhY2VDaGlsZHJlbic7XG5cbiAgICBpZiAodGFyZ2V0Tm9kZU9yTm9kZUFycmF5KSB7XG4gICAgICB2YXIgZmlyc3RUYXJnZXROb2RlID0gZ2V0Rmlyc3ROb2RlRnJvbVBvc3NpYmxlQXJyYXkodGFyZ2V0Tm9kZU9yTm9kZUFycmF5KTtcblxuICAgICAgdmFyIHdoZW5Ub0Rpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoIWZpcnN0VGFyZ2V0Tm9kZSkgfHwgIWRvbU5vZGVJc0F0dGFjaGVkVG9Eb2N1bWVudChmaXJzdFRhcmdldE5vZGUpIH07IC8vIFBhc3NpdmUgZGlzcG9zYWwgKG9uIG5leHQgZXZhbHVhdGlvbilcbiAgICAgIHZhciBhY3RpdmVseURpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCA9IChmaXJzdFRhcmdldE5vZGUgJiYgcmVuZGVyTW9kZSA9PT0gJ3JlcGxhY2VOb2RlJykgPyBmaXJzdFRhcmdldE5vZGUucGFyZW50Tm9kZSA6IGZpcnN0VGFyZ2V0Tm9kZTtcblxuICAgICAgcmV0dXJuIGNvbXB1dGVkKCAvLyBTbyB0aGUgRE9NIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB3aGVuIGFueSBkZXBlbmRlbmN5IGNoYW5nZXNcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIEVuc3VyZSB3ZSd2ZSBnb3QgYSBwcm9wZXIgYmluZGluZyBjb250ZXh0IHRvIHdvcmsgd2l0aFxuICAgICAgICAgIHZhciBiaW5kaW5nQ29udGV4dCQkMSA9IChkYXRhT3JCaW5kaW5nQ29udGV4dCAmJiAoZGF0YU9yQmluZGluZ0NvbnRleHQgaW5zdGFuY2VvZiBiaW5kaW5nQ29udGV4dCkpXG4gICAgICAgICAgICAgICAgPyBkYXRhT3JCaW5kaW5nQ29udGV4dFxuICAgICAgICAgICAgICAgIDogbmV3IGJpbmRpbmdDb250ZXh0KGRhdGFPckJpbmRpbmdDb250ZXh0LCBudWxsLCBudWxsLCBudWxsLCB7ICdleHBvcnREZXBlbmRlbmNpZXMnOiB0cnVlIH0pO1xuXG4gICAgICAgICAgdmFyIHRlbXBsYXRlTmFtZSA9IHJlc29sdmVUZW1wbGF0ZU5hbWUodGVtcGxhdGUsIGJpbmRpbmdDb250ZXh0JCQxLiRkYXRhLCBiaW5kaW5nQ29udGV4dCQkMSk7XG4gICAgICAgICAgY29uc3QgcmVuZGVyZWROb2Rlc0FycmF5ID0gZXhlY3V0ZVRlbXBsYXRlKHRhcmdldE5vZGVPck5vZGVBcnJheSwgcmVuZGVyTW9kZSwgdGVtcGxhdGVOYW1lLCBiaW5kaW5nQ29udGV4dCQkMSwgb3B0aW9ucyQkMSwgYWZ0ZXJCaW5kaW5nQ2FsbGJhY2spO1xuXG4gICAgICAgICAgaWYgKHJlbmRlck1vZGUgPT09ICdyZXBsYWNlTm9kZScpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGVPck5vZGVBcnJheSA9IHJlbmRlcmVkTm9kZXNBcnJheTtcbiAgICAgICAgICAgIGZpcnN0VGFyZ2V0Tm9kZSA9IGdldEZpcnN0Tm9kZUZyb21Qb3NzaWJsZUFycmF5KHRhcmdldE5vZGVPck5vZGVBcnJheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBudWxsLFxuICAgICAgICB7IGRpc3Bvc2VXaGVuOiB3aGVuVG9EaXNwb3NlLCBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGFjdGl2ZWx5RGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkIH1cbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdlIGRvbid0IHlldCBoYXZlIGEgRE9NIG5vZGUgdG8gZXZhbHVhdGUsIHNvIHVzZSBhIG1lbW8gYW5kIHJlbmRlciB0aGUgdGVtcGxhdGUgbGF0ZXIgd2hlbiB0aGVyZSBpcyBhIERPTSBub2RlXG4gICAgICByZXR1cm4gbWVtb2l6ZShmdW5jdGlvbiAoZG9tTm9kZSkge1xuICAgICAgICByZW5kZXJUZW1wbGF0ZSh0ZW1wbGF0ZSwgZGF0YU9yQmluZGluZ0NvbnRleHQsIG9wdGlvbnMkJDEsIGRvbU5vZGUsICdyZXBsYWNlTm9kZScpO1xuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJUZW1wbGF0ZUZvckVhY2ggKHRlbXBsYXRlLCBhcnJheU9yT2JzZXJ2YWJsZUFycmF5LCBvcHRpb25zJCQxLCB0YXJnZXROb2RlLCBwYXJlbnRCaW5kaW5nQ29udGV4dCwgYWZ0ZXJCaW5kaW5nQ2FsbGJhY2spIHtcbiAgICAgIC8vIFNpbmNlIHNldERvbU5vZGVDaGlsZHJlbkZyb21BcnJheU1hcHBpbmcgYWx3YXlzIGNhbGxzIGV4ZWN1dGVUZW1wbGF0ZUZvckFycmF5SXRlbSBhbmQgdGhlblxuICAgICAgLy8gYWN0aXZhdGVCaW5kaW5nc0NhbGxiYWNrIGZvciBhZGRlZCBpdGVtcywgd2UgY2FuIHN0b3JlIHRoZSBiaW5kaW5nIGNvbnRleHQgaW4gdGhlIGZvcm1lciB0byB1c2UgaW4gdGhlIGxhdHRlci5cbiAgICB2YXIgYXJyYXlJdGVtQ29udGV4dDtcblxuICAgICAgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCBieSBzZXREb21Ob2RlQ2hpbGRyZW5Gcm9tQXJyYXlNYXBwaW5nIHRvIGdldCB0aGUgbm9kZXMgdG8gYWRkIHRvIHRhcmdldE5vZGVcbiAgICBmdW5jdGlvbiBleGVjdXRlVGVtcGxhdGVGb3JBcnJheUl0ZW0gKGFycmF5VmFsdWUsIGluZGV4KSB7XG4gICAgICAvLyBTdXBwb3J0IHNlbGVjdGluZyB0ZW1wbGF0ZSBhcyBhIGZ1bmN0aW9uIG9mIHRoZSBkYXRhIGJlaW5nIHJlbmRlcmVkXG4gICAgICBpZiAob3B0aW9ucyQkMS5hcykge1xuICAgICAgICBpZiAob3B0aW9ucy5jcmVhdGVDaGlsZENvbnRleHRXaXRoQXMpIHtcbiAgICAgICAgICBhcnJheUl0ZW1Db250ZXh0ID0gcGFyZW50QmluZGluZ0NvbnRleHQuY3JlYXRlQ2hpbGRDb250ZXh0KFxuICAgICAgICAgICAgYXJyYXlWYWx1ZSwgb3B0aW9ucyQkMS5hcywgY29udGV4dCA9PiB7IGNvbnRleHQuJGluZGV4ID0gaW5kZXg7IH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5SXRlbUNvbnRleHQgPSBwYXJlbnRCaW5kaW5nQ29udGV4dC5leHRlbmQoe1xuICAgICAgICAgICAgW29wdGlvbnMkJDEuYXNdOiBhcnJheVZhbHVlLFxuICAgICAgICAgICAgJGluZGV4OiBpbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheUl0ZW1Db250ZXh0ID0gcGFyZW50QmluZGluZ0NvbnRleHQuY3JlYXRlQ2hpbGRDb250ZXh0KGFycmF5VmFsdWUsIG9wdGlvbnMkJDEuYXMsIGNvbnRleHQgPT4geyBjb250ZXh0LiRpbmRleCA9IGluZGV4OyB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRlbXBsYXRlTmFtZSA9IHJlc29sdmVUZW1wbGF0ZU5hbWUodGVtcGxhdGUsIGFycmF5VmFsdWUsIGFycmF5SXRlbUNvbnRleHQpO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVUZW1wbGF0ZSh0YXJnZXROb2RlLCAnaWdub3JlVGFyZ2V0Tm9kZScsIHRlbXBsYXRlTmFtZSwgYXJyYXlJdGVtQ29udGV4dCwgb3B0aW9ucyQkMSwgYWZ0ZXJCaW5kaW5nQ2FsbGJhY2spXG4gICAgfVxuXG4gICAgICAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHNldERvbU5vZGVDaGlsZHJlbkZyb21BcnJheU1hcHBpbmcgaGFzIGFkZGVkIG5vZGVzIHRvIHRhcmdldE5vZGVcbiAgICB2YXIgYWN0aXZhdGVCaW5kaW5nc0NhbGxiYWNrID0gZnVuY3Rpb24gKGFycmF5VmFsdWUsIGFkZGVkTm9kZXNBcnJheSAvKiwgaW5kZXggKi8pIHtcbiAgICAgIGFjdGl2YXRlQmluZGluZ3NPbkNvbnRpbnVvdXNOb2RlQXJyYXkoYWRkZWROb2Rlc0FycmF5LCBhcnJheUl0ZW1Db250ZXh0LCBhZnRlckJpbmRpbmdDYWxsYmFjayk7XG4gICAgICBpZiAob3B0aW9ucyQkMS5hZnRlclJlbmRlcikgeyBvcHRpb25zJCQxLmFmdGVyUmVuZGVyKGFkZGVkTm9kZXNBcnJheSwgYXJyYXlWYWx1ZSk7IH1cblxuICAgICAgICAgIC8vIHJlbGVhc2UgdGhlIFwiY2FjaGVcIiB2YXJpYWJsZSwgc28gdGhhdCBpdCBjYW4gYmUgY29sbGVjdGVkIGJ5XG4gICAgICAgICAgLy8gdGhlIEdDIHdoZW4gaXRzIHZhbHVlIGlzbid0IHVzZWQgZnJvbSB3aXRoaW4gdGhlIGJpbmRpbmdzIGFueW1vcmUuXG4gICAgICBhcnJheUl0ZW1Db250ZXh0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQ2FsbCBzZXREb21Ob2RlQ2hpbGRyZW5Gcm9tQXJyYXlNYXBwaW5nLCBpZ25vcmluZyBhbnkgb2JzZXJ2YWJsZXMgdW53cmFwcGVkIHdpdGhpbiAobW9zdCBsaWtlbHkgZnJvbSBhIGNhbGxiYWNrIGZ1bmN0aW9uKS5cbiAgICAvLyBJZiB0aGUgYXJyYXkgaXRlbXMgYXJlIG9ic2VydmFibGVzLCB0aG91Z2gsIHRoZXkgd2lsbCBiZSB1bndyYXBwZWQgaW4gZXhlY3V0ZVRlbXBsYXRlRm9yQXJyYXlJdGVtIGFuZCBtYW5hZ2VkIHdpdGhpbiBzZXREb21Ob2RlQ2hpbGRyZW5Gcm9tQXJyYXlNYXBwaW5nLlxuICAgIGZ1bmN0aW9uIGxvY2FsU2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZyAobmV3QXJyYXksIGNoYW5nZUxpc3QpIHtcbiAgICAgIGlnbm9yZShzZXREb21Ob2RlQ2hpbGRyZW5Gcm9tQXJyYXlNYXBwaW5nLCBudWxsLCBbdGFyZ2V0Tm9kZSwgbmV3QXJyYXksIGV4ZWN1dGVUZW1wbGF0ZUZvckFycmF5SXRlbSwgb3B0aW9ucyQkMSwgYWN0aXZhdGVCaW5kaW5nc0NhbGxiYWNrLCBjaGFuZ2VMaXN0XSk7XG4gICAgICBiaW5kaW5nRXZlbnQubm90aWZ5KHRhcmdldE5vZGUsIGJpbmRpbmdFdmVudC5jaGlsZHJlbkNvbXBsZXRlKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaG91bGRIaWRlRGVzdHJveWVkID0gKG9wdGlvbnMkJDEuaW5jbHVkZURlc3Ryb3llZCA9PT0gZmFsc2UpIHx8IChvcHRpb25zLmZvcmVhY2hIaWRlc0Rlc3Ryb3llZCAmJiAhb3B0aW9ucyQkMS5pbmNsdWRlRGVzdHJveWVkKTtcbiAgICBpZiAoIXNob3VsZEhpZGVEZXN0cm95ZWQgJiYgIW9wdGlvbnMkJDEuYmVmb3JlUmVtb3ZlICYmIGlzT2JzZXJ2YWJsZUFycmF5KGFycmF5T3JPYnNlcnZhYmxlQXJyYXkpKSB7XG4gICAgICBsb2NhbFNldERvbU5vZGVDaGlsZHJlbkZyb21BcnJheU1hcHBpbmcoYXJyYXlPck9ic2VydmFibGVBcnJheS5wZWVrKCkpO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IGFycmF5T3JPYnNlcnZhYmxlQXJyYXkuc3Vic2NyaWJlKGZ1bmN0aW9uIChjaGFuZ2VMaXN0KSB7XG4gICAgICAgIGxvY2FsU2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZyhhcnJheU9yT2JzZXJ2YWJsZUFycmF5KCksIGNoYW5nZUxpc3QpO1xuICAgICAgfSwgbnVsbCwgJ2FycmF5Q2hhbmdlJyk7XG4gICAgICBzdWJzY3JpcHRpb24uZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkKHRhcmdldE5vZGUpO1xuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdW53cmFwcGVkQXJyYXkgPSB1bndyYXAoYXJyYXlPck9ic2VydmFibGVBcnJheSkgfHwgW107XG4gICAgICAgIGNvbnN0IHVud3JhcHBlZElzSXRlcmFibGUgPSBTeW1ib2wuaXRlcmF0b3IgaW4gdW53cmFwcGVkQXJyYXk7XG4gICAgICAgIGlmICghdW53cmFwcGVkSXNJdGVyYWJsZSkgeyB1bndyYXBwZWRBcnJheSA9IFt1bndyYXBwZWRBcnJheV07IH1cbiAgICAgICAgaWYgKHNob3VsZEhpZGVEZXN0cm95ZWQpIHtcbiAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFueSBlbnRyaWVzIG1hcmtlZCBhcyBkZXN0cm95ZWRcbiAgICAgICAgICB1bndyYXBwZWRBcnJheSA9IGFycmF5RmlsdGVyKHVud3JhcHBlZEFycmF5LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtID09PSBudWxsIHx8ICF1bndyYXAoaXRlbS5fZGVzdHJveSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxTZXREb21Ob2RlQ2hpbGRyZW5Gcm9tQXJyYXlNYXBwaW5nKHVud3JhcHBlZEFycmF5KTtcbiAgICAgIH0sIG51bGwsIHsgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiB0YXJnZXROb2RlIH0pXG4gICAgfVxuICB9XG5cbiAgbGV0IHRlbXBsYXRlQ29tcHV0ZWREb21EYXRhS2V5ID0gbmV4dEtleSgpO1xuXG4gIGNsYXNzIFRlbXBsYXRlQmluZGluZ0hhbmRsZXIgZXh0ZW5kcyBBc3luY0JpbmRpbmdIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvciAocGFyYW1zKSB7XG4gICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuJGVsZW1lbnQ7XG4gICAgICBjb25zdCBiaW5kaW5nVmFsdWUgPSB1bndyYXAodGhpcy52YWx1ZSk7XG5cbiAgICAgIC8vIEV4cG9zZSAnY29uZGl0aW9uYWwnIGZvciBgZWxzZWAgY2hhaW5pbmcuXG4gICAgICBzZXQoZWxlbWVudCwgJ2NvbmRpdGlvbmFsJywge1xuICAgICAgICBlbHNlQ2hhaW5TYXRpc2ZpZWQ6IG9ic2VydmFibGUodHJ1ZSlcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTdXBwb3J0IGFub255bW91cyB0ZW1wbGF0ZXNcbiAgICAgIGlmICh0eXBlb2YgYmluZGluZ1ZhbHVlID09PSAnc3RyaW5nJyB8fCBiaW5kaW5nVmFsdWUubmFtZSkge1xuICAgICAgICB0aGlzLmJpbmROYW1lZFRlbXBsYXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKCdub2RlcycgaW4gYmluZGluZ1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmluZE5vZGVUZW1wbGF0ZShiaW5kaW5nVmFsdWUubm9kZXMgfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iaW5kQW5vbnltb3VzVGVtcGxhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiaW5kTmFtZWRUZW1wbGF0ZSAoKSB7XG4gICAgICAvLyBJdCdzIGEgbmFtZWQgdGVtcGxhdGUgLSBjbGVhciB0aGUgZWxlbWVudFxuICAgICAgZW1wdHlOb2RlKHRoaXMuJGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIFdlJ3ZlIGJlZW4gZ2l2ZW4gYW4gYXJyYXkgb2YgRE9NIG5vZGVzLiBTYXZlIHRoZW0gYXMgdGhlIHRlbXBsYXRlIHNvdXJjZS5cbiAgICAvLyBUaGVyZSBpcyBubyBrbm93biB1c2UgY2FzZSBmb3IgdGhlIG5vZGUgYXJyYXkgYmVpbmcgYW4gb2JzZXJ2YWJsZSBhcnJheSAoaWYgdGhlIG91dHB1dFxuICAgIC8vIHZhcmllcywgcHV0IHRoYXQgYmVoYXZpb3IgKmludG8qIHlvdXIgdGVtcGxhdGUgLSB0aGF0J3Mgd2hhdCB0ZW1wbGF0ZXMgYXJlIGZvciksIGFuZFxuICAgIC8vIHRoZSBpbXBsZW1lbnRhdGlvbiB3b3VsZCBiZSBhIG1lc3MsIHNvIGFzc2VydCB0aGF0IGl0J3Mgbm90IG9ic2VydmFibGUuXG4gICAgYmluZE5vZGVUZW1wbGF0ZSAobm9kZXMpIHtcbiAgICAgIGlmIChpc09ic2VydmFibGUobm9kZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwibm9kZXNcIiBvcHRpb24gbXVzdCBiZSBhIHBsYWluLCBub24tb2JzZXJ2YWJsZSBhcnJheS4nKVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgbm9kZXMgYXJlIGFscmVhZHkgYXR0YWNoZWQgdG8gYSBLTy1nZW5lcmF0ZWQgY29udGFpbmVyLCB3ZSByZXVzZSB0aGF0IGNvbnRhaW5lciB3aXRob3V0IG1vdmluZyB0aGVcbiAgICAgIC8vIGVsZW1lbnRzIHRvIGEgbmV3IG9uZSAod2UgY2hlY2sgb25seSB0aGUgZmlyc3Qgbm9kZSwgYXMgdGhlIG5vZGVzIGFyZSBhbHdheXMgbW92ZWQgdG9nZXRoZXIpXG4gICAgICBsZXQgY29udGFpbmVyID0gbm9kZXNbMF0gJiYgbm9kZXNbMF0ucGFyZW50Tm9kZTtcbiAgICAgIGlmICghY29udGFpbmVyIHx8ICFnZXQoY29udGFpbmVyLCBjbGVhbkNvbnRhaW5lckRvbURhdGFLZXkpKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IG1vdmVDbGVhbmVkTm9kZXNUb0NvbnRhaW5lckVsZW1lbnQobm9kZXMpO1xuICAgICAgICBzZXQoY29udGFpbmVyLCBjbGVhbkNvbnRhaW5lckRvbURhdGFLZXksIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBuZXcgYW5vbnltb3VzVGVtcGxhdGUodGhpcy4kZWxlbWVudCkubm9kZXMoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBiaW5kQW5vbnltb3VzVGVtcGxhdGUgKCkge1xuICAgICAgLy8gSXQncyBhbiBhbm9ueW1vdXMgdGVtcGxhdGUgLSBzdG9yZSB0aGUgZWxlbWVudCBjb250ZW50cywgdGhlbiBjbGVhciB0aGUgZWxlbWVudFxuICAgICAgY29uc3QgdGVtcGxhdGVOb2RlcyA9IGNoaWxkTm9kZXModGhpcy4kZWxlbWVudCk7XG4gICAgICBpZiAodGVtcGxhdGVOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbm9ueW1vdXMgdGVtcGxhdGUgZGVmaW5lZCwgYnV0IG5vIHRlbXBsYXRlIGNvbnRlbnQgd2FzIHByb3ZpZGVkLicpXG4gICAgICB9XG4gICAgICBjb25zdCBjb250YWluZXIgPSBtb3ZlQ2xlYW5lZE5vZGVzVG9Db250YWluZXJFbGVtZW50KHRlbXBsYXRlTm9kZXMpOyAvLyBUaGlzIGFsc28gcmVtb3ZlcyB0aGUgbm9kZXMgZnJvbSB0aGVpciBjdXJyZW50IHBhcmVudFxuICAgICAgbmV3IGFub255bW91c1RlbXBsYXRlKHRoaXMuJGVsZW1lbnQpLm5vZGVzKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgb25WYWx1ZUNoYW5nZSAoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy4kZWxlbWVudDtcbiAgICAgIGNvbnN0IGJpbmRpbmdDb250ZXh0JCQxID0gdGhpcy4kY29udGV4dDtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB2YXIgb3B0aW9ucyQkMSA9IHVud3JhcCh2YWx1ZSk7XG4gICAgICB2YXIgc2hvdWxkRGlzcGxheSA9IHRydWU7XG4gICAgICB2YXIgdGVtcGxhdGVDb21wdXRlZCA9IG51bGw7XG4gICAgICB2YXIgZWxzZUNoYWluU2F0aXNmaWVkID0gZ2V0KGVsZW1lbnQsICdjb25kaXRpb25hbCcpLmVsc2VDaGFpblNhdGlzZmllZDtcbiAgICAgIHZhciB0ZW1wbGF0ZU5hbWU7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGVtcGxhdGVOYW1lID0gdmFsdWU7XG4gICAgICAgIG9wdGlvbnMkJDEgPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlTmFtZSA9IG9wdGlvbnMkJDEubmFtZTtcblxuICAgICAgICAvLyBTdXBwb3J0IFwiaWZcIi9cImlmbm90XCIgY29uZGl0aW9uc1xuICAgICAgICBpZiAoJ2lmJyBpbiBvcHRpb25zJCQxKSB7XG4gICAgICAgICAgc2hvdWxkRGlzcGxheSA9IHVud3JhcChvcHRpb25zJCQxLmlmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGREaXNwbGF5ICYmICdpZm5vdCcgaW4gb3B0aW9ucyQkMSkge1xuICAgICAgICAgIHNob3VsZERpc3BsYXkgPSAhdW53cmFwKG9wdGlvbnMkJDEuaWZub3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgnZm9yZWFjaCcgaW4gb3B0aW9ucyQkMSkge1xuICAgICAgICAvLyBSZW5kZXIgb25jZSBmb3IgZWFjaCBkYXRhIHBvaW50ICh0cmVhdGluZyBkYXRhIHNldCBhcyBlbXB0eSBpZiBzaG91bGREaXNwbGF5PT1mYWxzZSlcbiAgICAgICAgdmFyIGRhdGFBcnJheSA9IChzaG91bGREaXNwbGF5ICYmIG9wdGlvbnMkJDEuZm9yZWFjaCkgfHwgW107XG4gICAgICAgIHRlbXBsYXRlQ29tcHV0ZWQgPSByZW5kZXJUZW1wbGF0ZUZvckVhY2godGVtcGxhdGVOYW1lIHx8IGVsZW1lbnQsIGRhdGFBcnJheSwgb3B0aW9ucyQkMSwgZWxlbWVudCwgYmluZGluZ0NvbnRleHQkJDEsIHRoaXMuY29tcGxldGVCaW5kaW5nKTtcblxuICAgICAgICBlbHNlQ2hhaW5TYXRpc2ZpZWQoKHVud3JhcChkYXRhQXJyYXkpIHx8IFtdKS5sZW5ndGggIT09IDApO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGREaXNwbGF5KSB7XG4gICAgICAgIC8vIFJlbmRlciBvbmNlIGZvciB0aGlzIHNpbmdsZSBkYXRhIHBvaW50IChvciB1c2UgdGhlIHZpZXdNb2RlbCBpZiBubyBkYXRhIHdhcyBwcm92aWRlZClcbiAgICAgICAgdmFyIGlubmVyQmluZGluZ0NvbnRleHQgPSAoJ2RhdGEnIGluIG9wdGlvbnMkJDEpXG4gICAgICAgICAgPyBiaW5kaW5nQ29udGV4dCQkMS5jcmVhdGVTdGF0aWNDaGlsZENvbnRleHQob3B0aW9ucyQkMS5kYXRhLCBvcHRpb25zJCQxLmFzKSAgLy8gR2l2ZW4gYW4gZXhwbGljaXQgJ2RhdGEnIHZhbHVlLCB3ZSBjcmVhdGUgYSBjaGlsZCBiaW5kaW5nIGNvbnRleHQgZm9yIGl0XG4gICAgICAgICAgOiBiaW5kaW5nQ29udGV4dCQkMTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdpdmVuIG5vIGV4cGxpY2l0ICdkYXRhJyB2YWx1ZSwgd2UgcmV0YWluIHRoZSBzYW1lIGJpbmRpbmcgY29udGV4dFxuICAgICAgICB0ZW1wbGF0ZUNvbXB1dGVkID0gcmVuZGVyVGVtcGxhdGUodGVtcGxhdGVOYW1lIHx8IGVsZW1lbnQsIGlubmVyQmluZGluZ0NvbnRleHQsIG9wdGlvbnMkJDEsIGVsZW1lbnQsIHVuZGVmaW5lZCwgdGhpcy5jb21wbGV0ZUJpbmRpbmcpO1xuICAgICAgICBlbHNlQ2hhaW5TYXRpc2ZpZWQodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbXB0eU5vZGUoZWxlbWVudCk7XG4gICAgICAgIGVsc2VDaGFpblNhdGlzZmllZChmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEl0IG9ubHkgbWFrZXMgc2Vuc2UgdG8gaGF2ZSBhIHNpbmdsZSB0ZW1wbGF0ZSBjb21wdXRlZCBwZXIgZWxlbWVudCAob3RoZXJ3aXNlIHdoaWNoIG9uZSBzaG91bGQgaGF2ZSBpdHMgb3V0cHV0IGRpc3BsYXllZD8pXG4gICAgICB0aGlzLmRpc3Bvc2VPbGRDb21wdXRlZEFuZFN0b3JlTmV3T25lKGVsZW1lbnQsIHRlbXBsYXRlQ29tcHV0ZWQpO1xuICAgIH1cblxuICAgIGRpc3Bvc2VPbGRDb21wdXRlZEFuZFN0b3JlTmV3T25lIChlbGVtZW50LCBuZXdDb21wdXRlZCkge1xuICAgICAgbGV0IG9sZENvbXB1dGVkID0gZ2V0KGVsZW1lbnQsIHRlbXBsYXRlQ29tcHV0ZWREb21EYXRhS2V5KTtcbiAgICAgIGlmIChvbGRDb21wdXRlZCAmJiAodHlwZW9mIG9sZENvbXB1dGVkLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicpKSB7IG9sZENvbXB1dGVkLmRpc3Bvc2UoKTsgfVxuICAgICAgc2V0KGVsZW1lbnQsIHRlbXBsYXRlQ29tcHV0ZWREb21EYXRhS2V5LCAobmV3Q29tcHV0ZWQgJiYgKCFuZXdDb21wdXRlZC5pc0FjdGl2ZSB8fCBuZXdDb21wdXRlZC5pc0FjdGl2ZSgpKSkgPyBuZXdDb21wdXRlZCA6IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgZ2V0IGNvbnRyb2xzRGVzY2VuZGFudHMgKCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgc3RhdGljIGdldCBhbGxvd1ZpcnR1YWxFbGVtZW50cyAoKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5hdGl2ZVRlbXBsYXRlRW5naW5lICgpIHtcbiAgfVxuXG4gIG5hdGl2ZVRlbXBsYXRlRW5naW5lLnByb3RvdHlwZSA9IG5ldyB0ZW1wbGF0ZUVuZ2luZSgpO1xuICBuYXRpdmVUZW1wbGF0ZUVuZ2luZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBuYXRpdmVUZW1wbGF0ZUVuZ2luZTtcbiAgbmF0aXZlVGVtcGxhdGVFbmdpbmUucHJvdG90eXBlLnJlbmRlclRlbXBsYXRlU291cmNlID0gZnVuY3Rpb24gKHRlbXBsYXRlU291cmNlLCBiaW5kaW5nQ29udGV4dCwgb3B0aW9ucyQkMSwgdGVtcGxhdGVEb2N1bWVudCkge1xuICAgIHZhciB1c2VOb2Rlc0lmQXZhaWxhYmxlID0gIShpZVZlcnNpb24gPCA5KSwgLy8gSUU8OSBjbG9uZU5vZGUgZG9lc24ndCB3b3JrIHByb3Blcmx5XG4gICAgICB0ZW1wbGF0ZU5vZGVzRnVuYyA9IHVzZU5vZGVzSWZBdmFpbGFibGUgPyB0ZW1wbGF0ZVNvdXJjZS5ub2RlcyA6IG51bGwsXG4gICAgICB0ZW1wbGF0ZU5vZGVzID0gdGVtcGxhdGVOb2Rlc0Z1bmMgPyB0ZW1wbGF0ZVNvdXJjZS5ub2RlcygpIDogbnVsbDtcblxuICAgIGlmICh0ZW1wbGF0ZU5vZGVzKSB7XG4gICAgICByZXR1cm4gbWFrZUFycmF5KHRlbXBsYXRlTm9kZXMuY2xvbmVOb2RlKHRydWUpLmNoaWxkTm9kZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0ZW1wbGF0ZVRleHQgPSB0ZW1wbGF0ZVNvdXJjZS50ZXh0KCk7XG4gICAgICByZXR1cm4gcGFyc2VIdG1sRnJhZ21lbnQodGVtcGxhdGVUZXh0LCB0ZW1wbGF0ZURvY3VtZW50KVxuICAgIH1cbiAgfTtcblxuICBuYXRpdmVUZW1wbGF0ZUVuZ2luZS5pbnN0YW5jZSA9IG5ldyBuYXRpdmVUZW1wbGF0ZUVuZ2luZSgpO1xuICBzZXRUZW1wbGF0ZUVuZ2luZShuYXRpdmVUZW1wbGF0ZUVuZ2luZS5pbnN0YW5jZSk7XG5cbiAgLy8gXCJmb3JlYWNoOiBzb21lRXhwcmVzc2lvblwiIGlzIGVxdWl2YWxlbnQgdG8gXCJ0ZW1wbGF0ZTogeyBmb3JlYWNoOiBzb21lRXhwcmVzc2lvbiB9XCJcbiAgLy8gXCJmb3JlYWNoOiB7IGRhdGE6IHNvbWVFeHByZXNzaW9uLCBhZnRlckFkZDogbXlmbiB9XCIgaXMgZXF1aXZhbGVudCB0byBcInRlbXBsYXRlOiB7IGZvcmVhY2g6IHNvbWVFeHByZXNzaW9uLCBhZnRlckFkZDogbXlmbiB9XCJcbiAgY2xhc3MgVGVtcGxhdGVGb3JFYWNoQmluZGluZ0hhbmRsZXIgZXh0ZW5kcyBUZW1wbGF0ZUJpbmRpbmdIYW5kbGVyIHtcbiAgICBnZXQgdmFsdWUgKCkge1xuICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IHRoaXMudmFsdWVBY2Nlc3NvcigpO1xuICAgICAgY29uc3QgdW53cmFwcGVkVmFsdWUgPSBwZWVrKG1vZGVsVmFsdWUpOyAgICAvLyBVbndyYXAgd2l0aG91dCBzZXR0aW5nIGEgZGVwZW5kZW5jeSBoZXJlXG5cbiAgICAgICAgICAvLyBJZiB1bndyYXBwZWRWYWx1ZSBpcyB0aGUgYXJyYXksIHBhc3MgaW4gdGhlIHdyYXBwZWQgdmFsdWUgb24gaXRzIG93blxuICAgICAgICAgIC8vIFRoZSB2YWx1ZSB3aWxsIGJlIHVud3JhcHBlZCBhbmQgdHJhY2tlZCB3aXRoaW4gdGhlIHRlbXBsYXRlIGJpbmRpbmdcbiAgICAgICAgICAvLyAoU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9pc3N1ZXMvNTIzKVxuICAgICAgaWYgKCF1bndyYXBwZWRWYWx1ZSB8fCB0eXBlb2YgdW53cmFwcGVkVmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4geyBmb3JlYWNoOiBtb2RlbFZhbHVlLCB0ZW1wbGF0ZUVuZ2luZTogbmF0aXZlVGVtcGxhdGVFbmdpbmUuaW5zdGFuY2UgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB1bndyYXBwZWRWYWx1ZS5kYXRhIGlzIHRoZSBhcnJheSwgcHJlc2VydmUgYWxsIHJlbGV2YW50IG9wdGlvbnMgYW5kIHVud3JhcCBhZ2FpbiB2YWx1ZSBzbyB3ZSBnZXQgdXBkYXRlc1xuICAgICAgdW53cmFwKG1vZGVsVmFsdWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm9yZWFjaDogdW53cmFwcGVkVmFsdWUuZGF0YSxcbiAgICAgICAgYXM6IHVud3JhcHBlZFZhbHVlLmFzLFxuICAgICAgICBpbmNsdWRlRGVzdHJveWVkOiB1bndyYXBwZWRWYWx1ZS5pbmNsdWRlRGVzdHJveWVkLFxuICAgICAgICBhZnRlckFkZDogdW53cmFwcGVkVmFsdWUuYWZ0ZXJBZGQsXG4gICAgICAgIGJlZm9yZVJlbW92ZTogdW53cmFwcGVkVmFsdWUuYmVmb3JlUmVtb3ZlLFxuICAgICAgICBhZnRlclJlbmRlcjogdW53cmFwcGVkVmFsdWUuYWZ0ZXJSZW5kZXIsXG4gICAgICAgIGJlZm9yZU1vdmU6IHVud3JhcHBlZFZhbHVlLmJlZm9yZU1vdmUsXG4gICAgICAgIGFmdGVyTW92ZTogdW53cmFwcGVkVmFsdWUuYWZ0ZXJNb3ZlLFxuICAgICAgICB0ZW1wbGF0ZUVuZ2luZTogbmF0aXZlVGVtcGxhdGVFbmdpbmUuaW5zdGFuY2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAgICAnbGV0JzogbGV0QmluZGluZyxcbiAgLy8gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuXG4gIGNvbnN0IGJpbmRpbmdzID0ge1xuICAgIGZvcmVhY2g6IFRlbXBsYXRlRm9yRWFjaEJpbmRpbmdIYW5kbGVyLFxuICAgIHRlbXBsYXRlOiBUZW1wbGF0ZUJpbmRpbmdIYW5kbGVyXG4gIH07XG5cbiAgLyoqXG4gICAqIEEgY2xhc3MgdG8gY3JlYXRlIHRoZSBnbG9iYWwga25vY2tvdXQgaW5zdGFuY2UgKGtvKS5cbiAgICovXG5cbiAgY29uc3QgZG9tTm9kZURpc3Bvc2FsID0ge1xuICAgIGFkZERpc3Bvc2VDYWxsYmFjayxcbiAgICByZW1vdmVEaXNwb3NlQ2FsbGJhY2ssXG4gICAgcmVtb3ZlTm9kZSxcbiAgICBhZGRDbGVhbmVyLFxuICAgIHJlbW92ZUNsZWFuZXIsXG4gICAgZ2V0IGNsZWFuRXh0ZXJuYWxEYXRhICgpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmNsZWFuRXh0ZXJuYWxEYXRhXG4gICAgfSxcbiAgICBzZXQgY2xlYW5FeHRlcm5hbERhdGEgKGNsZWFuZXJGbikge1xuICAgICAgb3B0aW9ucy5zZXQoJ2NsZWFuRXh0ZXJuYWxEYXRhJywgY2xlYW5lckZuKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdXRpbHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBhZGRPclJlbW92ZUl0ZW0sXG4gICAgYXJyYXlGaWx0ZXIsXG4gICAgYXJyYXlGaXJzdCxcbiAgICBhcnJheUZvckVhY2gsXG4gICAgYXJyYXlHZXREaXN0aW5jdFZhbHVlcyxcbiAgICBhcnJheUluZGV4T2YsXG4gICAgYXJyYXlNYXAsXG4gICAgYXJyYXlQdXNoQWxsLFxuICAgIGFycmF5UmVtb3ZlSXRlbSxcbiAgICBjbG9uZU5vZGVzLFxuICAgIGNvbXBhcmVBcnJheXMsXG4gICAgY3JlYXRlU3ltYm9sT3JTdHJpbmcsXG4gICAgZG9tRGF0YSxcbiAgICBkb21Ob2RlRGlzcG9zYWwsXG4gICAgZXh0ZW5kLFxuICAgIGZpbHRlcnM6IG9wdGlvbnMuZmlsdGVycyxcbiAgICBvYmplY3RGb3JFYWNoLFxuICAgIG9iamVjdE1hcCxcbiAgICBwYXJzZUh0bWxGcmFnbWVudCxcbiAgICBwYXJzZUpzb24sXG4gICAgcGFyc2VPYmplY3RMaXRlcmFsLFxuICAgIHBlZWtPYnNlcnZhYmxlOiBwZWVrLFxuICAgIHJhbmdlLFxuICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVyLFxuICAgIHNldERvbU5vZGVDaGlsZHJlbkZyb21BcnJheU1hcHBpbmcsXG4gICAgc2V0SHRtbCxcbiAgICBzZXRUZXh0Q29udGVudCxcbiAgICB0b2dnbGVEb21Ob2RlQ3NzQ2xhc3MsXG4gICAgdHJpZ2dlckV2ZW50LFxuICAgIHVud3JhcE9ic2VydmFibGU6IHVud3JhcFxuICB9KTtcblxuICBjb25zdCBrbm9ja291dCA9IHtcbiAgICAvLyAtLS0gVXRpbGl0aWVzIC0tLVxuICAgIGNsZWFuTm9kZSxcbiAgICBkZXBlbmRlbmN5RGV0ZWN0aW9uLFxuICAgIGNvbXB1dGVkQ29udGV4dDogZGVwZW5kZW5jeURldGVjdGlvbixcbiAgICBmaWx0ZXJzOiBvcHRpb25zLmZpbHRlcnMsXG4gICAgaWdub3JlRGVwZW5kZW5jaWVzOiBpZ25vcmUsXG4gICAgbWVtb2l6YXRpb24sXG4gICAgb3B0aW9ucyxcbiAgICByZW1vdmVOb2RlLFxuICAgIHNlbGVjdEV4dGVuc2lvbnMsXG4gICAgdGFza3MsXG4gICAgdXRpbHMsXG4gICAgTGlmZUN5Y2xlLFxuXG4gICAgICAvLyAtLSBPYnNlcnZhYmxlIC0tLVxuICAgIGlzT2JzZXJ2YWJsZSxcbiAgICBpc1N1YnNjcmliYWJsZSxcbiAgICBpc1dyaXRlYWJsZU9ic2VydmFibGUsXG4gICAgaXNXcml0YWJsZU9ic2VydmFibGU6IGlzV3JpdGVhYmxlT2JzZXJ2YWJsZSxcbiAgICBvYnNlcnZhYmxlLFxuICAgIG9ic2VydmFibGVBcnJheSxcbiAgICBpc09ic2VydmFibGVBcnJheSxcbiAgICBwZWVrLFxuICAgIHN1YnNjcmliYWJsZSxcbiAgICB1bndyYXAsXG4gICAgdG9KUyxcbiAgICB0b0pTT04sXG4gICAgcHJveHksXG5cbiAgICAgIC8vIC4uLiBDb21wdXRlZCAuLi5cbiAgICBjb21wdXRlZCxcbiAgICBkZXBlbmRlbnRPYnNlcnZhYmxlOiBjb21wdXRlZCxcbiAgICBpc0NvbXB1dGVkLFxuICAgIGlzUHVyZUNvbXB1dGVkLFxuICAgIHB1cmVDb21wdXRlZCxcbiAgICB3aGVuOiB3aGVuLFxuXG4gICAgICAvLyAtLS0gVGVtcGxhdGVzIC0tLVxuICAgIG5hdGl2ZVRlbXBsYXRlRW5naW5lLFxuICAgIHJlbmRlclRlbXBsYXRlLFxuICAgIHNldFRlbXBsYXRlRW5naW5lLFxuICAgIHRlbXBsYXRlRW5naW5lLFxuICAgIHRlbXBsYXRlU291cmNlczogeyBkb21FbGVtZW50LCBhbm9ueW1vdXNUZW1wbGF0ZSB9LFxuXG4gICAgICAvLyAtLS0gQmluZGluZyAtLS1cbiAgICBhcHBseUJpbmRpbmdBY2Nlc3NvcnNUb05vZGUsXG4gICAgYXBwbHlCaW5kaW5ncyxcbiAgICBhcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50cyxcbiAgICBhcHBseUJpbmRpbmdzVG9Ob2RlLFxuICAgIGNvbnRleHRGb3IsXG4gICAgZGF0YUZvcixcbiAgICBCaW5kaW5nSGFuZGxlcixcbiAgICBBc3luY0JpbmRpbmdIYW5kbGVyLFxuICAgIHZpcnR1YWxFbGVtZW50cyxcbiAgICBkb21Ob2RlRGlzcG9zYWwsXG4gICAgYmluZGluZ0V2ZW50LFxuICB9O1xuXG4gIGNsYXNzIEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yICh7IHByb3ZpZGVyLCBiaW5kaW5nczogYmluZGluZ3MkJDEsIGV4dGVuZGVyczogZXh0ZW5kZXJzJCQxLCBmaWx0ZXJzLCBvcHRpb25zOiBvcHRpb25zJCQxIH0pIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oa25vY2tvdXQub3B0aW9ucywgb3B0aW9ucyQkMSwge1xuICAgICAgICBmaWx0ZXJzLFxuICAgICAgICBiaW5kaW5nUHJvdmlkZXJJbnN0YW5jZTogcHJvdmlkZXJcbiAgICAgIH0pO1xuXG4gICAgICBwcm92aWRlci5zZXRHbG9iYWxzKGtub2Nrb3V0Lm9wdGlvbnMuYmluZGluZ0dsb2JhbHMpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5ncyQkMSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBiaW5kaW5nc09iamVjdCBvZiBiaW5kaW5ncyQkMSkge1xuICAgICAgICAgIHByb3ZpZGVyLmJpbmRpbmdIYW5kbGVycy5zZXQoYmluZGluZ3NPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm92aWRlci5iaW5kaW5nSGFuZGxlcnMuc2V0KGJpbmRpbmdzJCQxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm92aWRlZFByb3BlcnRpZXMgPSB7XG4gICAgICAgIGV4dGVuZGVyczogT2JqZWN0LmFzc2lnbihleHRlbmRlcnMsIGV4dGVuZGVycyQkMSksXG4gICAgICAgIGJpbmRpbmdIYW5kbGVyczogcHJvdmlkZXIuYmluZGluZ0hhbmRsZXJzLFxuICAgICAgICBiaW5kaW5nUHJvdmlkZXI6IHByb3ZpZGVyXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gaW5zdGFuY2Ugb2YgS25vY2tvdXQuXG4gICAgICovXG4gICAgY3JlYXRlICguLi5hZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgZ2V0IGdldEJpbmRpbmdIYW5kbGVyICgpIHsgcmV0dXJuIG9wdGlvbnMuZ2V0QmluZGluZ0hhbmRsZXIgfSxcbiAgICAgICAgc2V0IGdldEJpbmRpbmdIYW5kbGVyIChmbikgeyBvcHRpb25zLnNldCgnZ2V0QmluZGluZ0hhbmRsZXInLCBmbik7IH1cbiAgICAgIH0sXG4gICAgICBrbm9ja291dCxcbiAgICAgIHRoaXMucHJvdmlkZWRQcm9wZXJ0aWVzLFxuICAgICAgLi4uYWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICAgICAgaW5zdGFuY2Uub3B0aW9ucy5rbm9ja291dEluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICByZXR1cm4gaW5zdGFuY2VcbiAgICB9XG4gIH1cblxuICBjbGFzcyBCaW5kaW5nSGFuZGxlck9iamVjdCB7XG4gICAgc2V0IChuYW1lT3JPYmplY3QsIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWVPck9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpc1tuYW1lT3JPYmplY3RdID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lT3JPYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy5vbkVycm9yKFxuICAgICAgICAgICAgbmV3IEVycm9yKCdHaXZlbiBleHRyYW5lb3VzIGB2YWx1ZWAgcGFyYW1ldGVyIChmaXJzdCBwYXJhbSBzaG91bGQgYmUgYSBzdHJpbmcsIGJ1dCBpdCB3YXMgYW4gb2JqZWN0KS4nICsgbmFtZU9yT2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBuYW1lT3JPYmplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5vbkVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcignR2l2ZW4gYSBiYWQgYmluZGluZyBoYW5kbGVyIHR5cGU6ICcgKyBuYW1lT3JPYmplY3QpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBtYXkgaGF2ZSBhIGAuYCBpbiBpdCwgZS5nLiBgYXR0ci50aXRsZWAsIGluIHdoaWNoIGNhc2UgdGhlXG4gICAgICogaGFuZGxlciBpcyBgYXR0cmAuICBPdGhlcndpc2UgaXQncyB0aGUgbmFtZSBnaXZlblxuICAgICAqL1xuICAgIGdldCAobmFtZU9yRG90dGVkKSB7XG4gICAgICBjb25zdCBbbmFtZV0gPSBuYW1lT3JEb3R0ZWQuc3BsaXQoJy4nKTtcbiAgICAgIHJldHVybiB0aGlzW25hbWVdXG4gICAgfVxuICB9XG5cbiAgY2xhc3MgUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yIChwYXJhbXMgPSB7fSkge1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IFByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZXIgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcy4nKVxuICAgICAgfVxuICAgICAgaWYgKCEoJ0ZPUl9OT0RFX1RZUEVTJyBpbiB0aGlzKSkge1xuICAgICAgICAvLyBGT1JfTk9ERV9UWVBFUyBtdXN0IHJldHVybiBhIGxpc3Qgb2YgaW50ZWdlcnMgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgICAgLy8gbm9kZS5ub2RlVHlwZSdzIHRoYXQgdGhlIHByb3ZpZGVyIGhhbmRsZXMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZXJzIG11c3QgaGF2ZSBGT1JfTk9ERV9UWVBFUyBwcm9wZXJ0eScpXG4gICAgICB9XG4gICAgICB0aGlzLmJpbmRpbmdIYW5kbGVycyA9IHBhcmFtcy5iaW5kaW5nSGFuZGxlcnMgfHwgbmV3IEJpbmRpbmdIYW5kbGVyT2JqZWN0KCk7XG4gICAgICB0aGlzLmdsb2JhbHMgPSBwYXJhbXMuZ2xvYmFscyB8fCB7fTtcbiAgICB9XG5cbiAgICBzZXRHbG9iYWxzIChnbG9iYWxzKSB7XG4gICAgICB0aGlzLmdsb2JhbHMgPSBnbG9iYWxzO1xuICAgIH1cbiAgICBnZXQgcHJlZW1wdGl2ZSAoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgbm9kZUhhc0JpbmRpbmdzICgvKiBub2RlICovKSB7fVxuICAgIGdldEJpbmRpbmdBY2Nlc3NvcnMgKC8qIG5vZGUsIGNvbnRleHQgKi8pIHt9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwcm9jZXNzIGEgZ2l2ZW4gbm9kZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICogQHJldHVybnMge1tIVE1MRWxlbWVudF18dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHByZXByb2Nlc3NOb2RlIChub2RlKSB7fVxuICAgIHBvc3RQcm9jZXNzICgvKiBub2RlICovKSB7fVxuXG4gICAgLyoqIEZvciBsZWdhY3kgYmluZGluZyBwcm92aWRlciBhc3NpZ25tZW50cyB0b1xuICAgICAqICBrby5iaW5kaW5nUHJvdmlkZXIuaW5zdGFuY2UgPSAuLi4gKi9cbiAgICBnZXQgaW5zdGFuY2UgKCkgeyByZXR1cm4gdGhpcy5fb3ZlcmxvYWRJbnN0YW5jZSB8fCB0aGlzIH1cbiAgICBzZXQgaW5zdGFuY2UgKHByb3ZpZGVyKSB7XG4gICAgICBpZiAoIXByb3ZpZGVyIHx8IHByb3ZpZGVyID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX292ZXJsb2FkSW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vdmVybG9hZEluc3RhbmNlID0gbmV3IExlZ2FjeVByb3ZpZGVyKHByb3ZpZGVyLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHaXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBiaW5kaW5ncywgY3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgb2JqZWN0IHRoYXQgY29udGFpbnNcbiAgICAvLyBiaW5kaW5nIHZhbHVlLWFjY2Vzc29ycyBmdW5jdGlvbnMuIEVhY2ggYWNjZXNzb3IgZnVuY3Rpb24gY2FsbHMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uXG4gICAgLy8gc28gdGhhdCBpdCBhbHdheXMgZ2V0cyB0aGUgbGF0ZXN0IHZhbHVlIGFuZCBhbGwgZGVwZW5kZW5jaWVzIGFyZSBjYXB0dXJlZC4gVGhpcyBpcyB1c2VkXG4gICAgLy8gYnkga28uYXBwbHlCaW5kaW5nc1RvTm9kZSBhbmQgZ2V0QmluZGluZ3NBbmRNYWtlQWNjZXNzb3JzLlxuICAgIG1ha2VBY2Nlc3NvcnNGcm9tRnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gb2JqZWN0TWFwKGlnbm9yZShjYWxsYmFjayksXG4gICAgICAgICh2YWx1ZSwga2V5KSA9PiAoKSA9PiBjYWxsYmFjaygpW2tleV1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRoZSB2YWx1ZUFjY2Vzc29yIGZ1bmN0aW9uIGZvciBhIGJpbmRpbmcgdmFsdWVcbiAgICBtYWtlVmFsdWVBY2Nlc3NvciAodmFsdWUpIHtcbiAgICAgIHJldHVybiAoKSA9PiB2YWx1ZVxuICAgIH1cblxuICAgIC8vIEdpdmVuIGEgYmluZGluZ3MgZnVuY3Rpb24gb3Igb2JqZWN0LCBjcmVhdGUgYW5kIHJldHVybiBhIG5ldyBvYmplY3QgdGhhdCBjb250YWluc1xuICAgIC8vIGJpbmRpbmcgdmFsdWUtYWNjZXNzb3JzIGZ1bmN0aW9ucy4gVGhpcyBpcyB1c2VkIGJ5IGtvLmFwcGx5QmluZGluZ3NUb05vZGUuXG4gICAgbWFrZUJpbmRpbmdBY2Nlc3NvcnMgKGJpbmRpbmdzLCBjb250ZXh0LCBub2RlKSB7XG4gICAgICBpZiAodHlwZW9mIGJpbmRpbmdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VBY2Nlc3NvcnNGcm9tRnVuY3Rpb24oYmluZGluZ3MuYmluZChudWxsLCBjb250ZXh0LCBub2RlKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmplY3RNYXAoYmluZGluZ3MsIHRoaXMubWFrZVZhbHVlQWNjZXNzb3IpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExlZ2FjeVByb3ZpZGVyIGNsYXNzIGlzIGNyZWF0ZWQgd2hlbiBrby5iaW5kaW5nUHJvdmlkZXIuaW5zdGFuY2UgYXNzaWduZWQgdG9cbiAgICogYW4gb2JqZWN0IHRoYXQgd2VyZSBvbmNlIHVzZWQgZm9yIGJpbmRpbmcgcHJlLTQuMCBiaW5kaW5nIHByb3ZpZGVycyBlLmcuXG4gICAqIHsgIGdldEJpbmRpbmdzOiBmdW5jdGlvbiAoKSB7IC4uLiB9LFxuICAgKiAgICBub2RlSGFzQmluZGluZ3M6IGZ1bmN0aW9uICgpIHsgLi4uIH1cbiAgICogICAgcHJlcHJvY2Vzc05vZGU6IGZ1bmN0aW9uICgpIHsgLi4uIH1cbiAgICogfVxuICAgKi9cbiAgY2xhc3MgTGVnYWN5UHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlciB7XG4gICAgZ2V0IEZPUl9OT0RFX1RZUEVTICgpIHsgcmV0dXJuIFsxLCAzLCA4XSB9XG5cbiAgICBjb25zdHJ1Y3RvciAocHJvdmlkZXJPYmplY3QsIHBhcmVudFByb3ZpZGVyKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7cHJvdmlkZXJPYmplY3R9KTtcbiAgICAgIHRoaXMuYmluZGluZ0hhbmRsZXJzID0gcHJvdmlkZXJPYmplY3QuYmluZGluZ0hhbmRsZXJzIHx8IHBhcmVudFByb3ZpZGVyLmJpbmRpbmdIYW5kbGVycztcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaWYgdGhlIGJpbmRpbmcgcHJvdmlkZXIgZG9lc24ndCBpbmNsdWRlIGEgZ2V0QmluZGluZ0FjY2Vzc29ycyBmdW5jdGlvbi5cbiAgICAvLyBJdCBtdXN0IGJlIGNhbGxlZCB3aXRoICd0aGlzJyBzZXQgdG8gdGhlIHByb3ZpZGVyIGluc3RhbmNlLlxuICAgIGdldEJpbmRpbmdzQW5kTWFrZUFjY2Vzc29ycyAobm9kZSwgY29udGV4dCkge1xuICAgICAgY29uc3QgYmluZGluZ3NGbiA9IHRoaXMucHJvdmlkZXJPYmplY3QuZ2V0QmluZGluZ3MuYmluZCh0aGlzLnByb3ZpZGVyT2JqZWN0LCBub2RlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiB0aGlzLm1ha2VBY2Nlc3NvcnNGcm9tRnVuY3Rpb24oYmluZGluZ3NGbilcbiAgICB9XG5cbiAgICBnZXRCaW5kaW5nQWNjZXNzb3JzIChub2RlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm92aWRlck9iamVjdC5nZXRCaW5kaW5nQWNjZXNzb3JzXG4gICAgICAgID8gdGhpcy5wcm92aWRlck9iamVjdC5nZXRCaW5kaW5nQWNjZXNzb3JzKG5vZGUsIGNvbnRleHQpXG4gICAgICAgIDogdGhpcy5nZXRCaW5kaW5nc0FuZE1ha2VBY2Nlc3NvcnMobm9kZSwgY29udGV4dClcbiAgICB9XG5cbiAgICBub2RlSGFzQmluZGluZ3MgKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT2JqZWN0Lm5vZGVIYXNCaW5kaW5ncyhub2RlKVxuICAgIH1cblxuICAgIHByZXByb2Nlc3NOb2RlIChub2RlKSB7XG4gICAgICBpZiAodGhpcy5wcm92aWRlck9iamVjdC5wcmVwcm9jZXNzTm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlck9iamVjdC5wcmVwcm9jZXNzTm9kZShub2RlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kaW5nU3RyaW5nUHJvdmlkZXIgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyBwYXJzZXMgYSBiaW5kaW5nIHN0cmluZy5cbiAgICpcbiAgICogQ2hpbGRyZW4gbXVzdCBpbXBsZW1lbnQgYG5vZGVIYXNCaW5kaW5nc2AgYW5kIGBnZXRCaW5kaW5nU3RyaW5nYC5cbiAgICovXG4gIGNsYXNzIEJpbmRpbmdTdHJpbmdQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyIHtcbiAgICAvKiogQ2FsbCBiaW5kaW5nSGFuZGxlci5wcmVwcm9jZXNzIG9uIGVhY2ggcmVzcGVjdGl2ZSBiaW5kaW5nIHN0cmluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgcHJlcHJvY2Vzc2AgcHJvcGVydHkgb2YgYmluZGluZ0hhbmRsZXIgbXVzdCBiZSBhIHN0YXRpY1xuICAgICAqIGZ1bmN0aW9uIChpLmUuIG9uIHRoZSBvYmplY3Qgb3IgY29uc3RydWN0b3IpLlxuICAgICAqL1xuICAgICogcHJvY2Vzc0JpbmRpbmcgKGtleSwgdmFsdWUpIHtcbiAgICAgIC8vIEdldCB0aGUgXCJvblwiIGJpbmRpbmcgZnJvbSBcIm9uLmNsaWNrXCJcbiAgICAgIGNvbnN0IFtoYW5kbGVyTmFtZSwgcHJvcGVydHldID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5iaW5kaW5nSGFuZGxlcnMuZ2V0KGhhbmRsZXJOYW1lKTtcblxuICAgICAgaWYgKGhhbmRsZXIgJiYgaGFuZGxlci5wcmVwcm9jZXNzKSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzQWRkZWRCeUhhbmRsZXIgPSBbXTtcbiAgICAgICAgY29uc3QgY2hhaW5GbiA9ICguLi5hcmdzKSA9PiBiaW5kaW5nc0FkZGVkQnlIYW5kbGVyLnB1c2goYXJncyk7XG4gICAgICAgIHZhbHVlID0gaGFuZGxlci5wcmVwcm9jZXNzKHZhbHVlLCBrZXksIGNoYWluRm4pO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBiaW5kaW5nc0FkZGVkQnlIYW5kbGVyKSB7XG4gICAgICAgICAgeWllbGQgKiB0aGlzLnByb2Nlc3NCaW5kaW5nKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5KSB7XG4gICAgICAgIHZhbHVlID0gYHske3Byb3BlcnR5fToke3ZhbHVlfX1gO1xuICAgICAgfVxuXG4gICAgICB5aWVsZCBgJyR7aGFuZGxlck5hbWV9Jzoke3ZhbHVlfWA7XG4gICAgfVxuXG4gICAgKiBnZW5lcmF0ZUJpbmRpbmdTdHJpbmcgKGJpbmRpbmdTdHJpbmdPck9iamVjdHMpIHtcbiAgICAgIGNvbnN0IGJpbmRpbmdPYmplY3RzQXJyYXkgPSB0eXBlb2YgYmluZGluZ1N0cmluZ09yT2JqZWN0cyA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBwYXJzZU9iamVjdExpdGVyYWwoYmluZGluZ1N0cmluZ09yT2JqZWN0cykgOiBiaW5kaW5nU3RyaW5nT3JPYmplY3RzO1xuICAgICAgZm9yIChjb25zdCB7a2V5LCB1bmtub3duLCB2YWx1ZX0gb2YgYmluZGluZ09iamVjdHNBcnJheSkge1xuICAgICAgICB5aWVsZCAqIHRoaXMucHJvY2Vzc0JpbmRpbmcoa2V5IHx8IHVua25vd24sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmVQcm9jZXNzQmluZGluZ3MgKGJpbmRpbmdTdHJpbmdPck9iamVjdHMpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZ2VuZXJhdGVCaW5kaW5nU3RyaW5nKGJpbmRpbmdTdHJpbmdPck9iamVjdHMpKVxuICAgICAgICAuam9pbignLCcpXG4gICAgfVxuXG4gICAgZ2V0QmluZGluZ0FjY2Vzc29ycyAobm9kZSwgY29udGV4dCkge1xuICAgICAgY29uc3QgYmluZGluZ1N0cmluZyA9IG5vZGUgJiYgdGhpcy5nZXRCaW5kaW5nU3RyaW5nKG5vZGUpO1xuICAgICAgaWYgKCFiaW5kaW5nU3RyaW5nKSB7IHJldHVybiB9XG4gICAgICBjb25zdCBwcm9jZXNzZWQgPSB0aGlzLnByZVByb2Nlc3NCaW5kaW5ncyhiaW5kaW5nU3RyaW5nKTtcbiAgICAgIHJldHVybiBuZXcgUGFyc2VyKCkucGFyc2UocHJvY2Vzc2VkLCBjb250ZXh0LCB0aGlzLmdsb2JhbHMsIG5vZGUpXG4gICAgfVxuXG4gICAgZ2V0QmluZGluZ1N0cmluZyAoKSB7IHRocm93IG5ldyBFcnJvcignT3ZlcmxvYWQgZ2V0QmluZGluZ1N0cmluZy4nKSB9XG4gIH1cblxuICBjbGFzcyBWaXJ0dWFsUHJvdmlkZXIgZXh0ZW5kcyBCaW5kaW5nU3RyaW5nUHJvdmlkZXIge1xuICAgIGdldCBGT1JfTk9ERV9UWVBFUyAoKSB7IHJldHVybiBbIDEsIDggXSB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IDxrbyBiaW5kaW5nPScuLi4nPiBpbnRvIDwhLS0ga28gYmluZGluZzogLi4uIC0tPlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgKi9cbiAgICBwcmVwcm9jZXNzTm9kZSAobm9kZSkge1xuICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ0tPJykge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMkJDEgPSBbLi4ubm9kZS5jaGlsZE5vZGVzXTtcbiAgICAgICAgY29uc3QgdmlydHVhbEJpbmRpbmdTdHJpbmcgPSBbLi4udGhpcy5nZW5FbGVtZW50QmluZGluZ1N0cmluZ3Mobm9kZSldLmpvaW4oJywnKTtcbiAgICAgICAgY29uc3Qgb3Blbk5vZGUgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCdrbyAnICsgdmlydHVhbEJpbmRpbmdTdHJpbmcpO1xuICAgICAgICBjb25zdCBjbG9zZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCcva28nKTtcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShvcGVuTm9kZSwgbm9kZSk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGROb2RlcyQkMSkge1xuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvc2VOb2RlLCBub2RlKTtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIFtvcGVuTm9kZSwgLi4uY2hpbGROb2RlcyQkMSwgY2xvc2VOb2RlXVxuICAgICAgfVxuICAgIH1cblxuICAgICogZ2VuRWxlbWVudEJpbmRpbmdTdHJpbmdzIChub2RlKSB7XG4gICAgICBmb3IgKGNvbnN0IHtuYW1lLCB2YWx1ZX0gb2Ygbm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHlpZWxkIGAke25hbWUucmVwbGFjZSgvXmtvLS8sICcnKX06ICR7dmFsdWV9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRCaW5kaW5nU3RyaW5nIChub2RlKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gZG9jdW1lbnQuQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiB2aXJ0dWFsTm9kZUJpbmRpbmdWYWx1ZShub2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGVIYXNCaW5kaW5ncyAobm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IGRvY3VtZW50LkNPTU1FTlRfTk9ERSkge1xuICAgICAgICByZXR1cm4gaXNTdGFydENvbW1lbnQobm9kZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbGFzcyBEYXRhQmluZFByb3ZpZGVyIGV4dGVuZHMgQmluZGluZ1N0cmluZ1Byb3ZpZGVyIHtcbiAgICBnZXQgRk9SX05PREVfVFlQRVMgKCkgeyByZXR1cm4gWyAxIF0gfSAvLyBkb2N1bWVudC5FTEVNRU5UX05PREVcblxuICAgIGdldCBCSU5EX0FUVFJJQlVURSAoKSB7XG4gICAgICByZXR1cm4gJ2RhdGEtYmluZCdcbiAgICB9XG5cbiAgICBnZXRCaW5kaW5nU3RyaW5nIChub2RlKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gZG9jdW1lbnQuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSh0aGlzLkJJTkRfQVRUUklCVVRFKVxuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGVIYXNCaW5kaW5ncyAobm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IGRvY3VtZW50LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICByZXR1cm4gbm9kZS5oYXNBdHRyaWJ1dGUodGhpcy5CSU5EX0FUVFJJQlVURSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbG9hZGluZ1N1YnNjcmliYWJsZXNDYWNoZSA9IHt9LCAvLyBUcmFja3MgY29tcG9uZW50IGxvYWRzIHRoYXQgYXJlIGN1cnJlbnRseSBpbiBmbGlnaHRcbiAgICBsb2FkZWREZWZpbml0aW9uc0NhY2hlID0ge307ICAgIC8vIFRyYWNrcyBjb21wb25lbnQgbG9hZHMgdGhhdCBoYXZlIGFscmVhZHkgY29tcGxldGVkXG5cbiAgZnVuY3Rpb24gbG9hZENvbXBvbmVudEFuZE5vdGlmeSAoY29tcG9uZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3N1YnNjcmliYWJsZSA9IGdldE9iamVjdE93blByb3BlcnR5KGxvYWRpbmdTdWJzY3JpYmFibGVzQ2FjaGUsIGNvbXBvbmVudE5hbWUpLFxuICAgICAgY29tcGxldGVkQXN5bmM7XG4gICAgaWYgKCFfc3Vic2NyaWJhYmxlKSB7XG4gICAgICAgICAgLy8gSXQncyBub3Qgc3RhcnRlZCBsb2FkaW5nIHlldC4gU3RhcnQgbG9hZGluZywgYW5kIHdoZW4gaXQncyBkb25lLCBtb3ZlIGl0IHRvIGxvYWRlZERlZmluaXRpb25zQ2FjaGUuXG4gICAgICBfc3Vic2NyaWJhYmxlID0gbG9hZGluZ1N1YnNjcmliYWJsZXNDYWNoZVtjb21wb25lbnROYW1lXSA9IG5ldyBzdWJzY3JpYmFibGUoKTtcbiAgICAgIF9zdWJzY3JpYmFibGUuc3Vic2NyaWJlKGNhbGxiYWNrKTtcblxuICAgICAgYmVnaW5Mb2FkaW5nQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGZ1bmN0aW9uIChkZWZpbml0aW9uLCBjb25maWcpIHtcbiAgICAgICAgdmFyIGlzU3luY2hyb25vdXNDb21wb25lbnQgPSAhIShjb25maWcgJiYgY29uZmlnLnN5bmNocm9ub3VzKTtcbiAgICAgICAgbG9hZGVkRGVmaW5pdGlvbnNDYWNoZVtjb21wb25lbnROYW1lXSA9IHsgZGVmaW5pdGlvbjogZGVmaW5pdGlvbiwgaXNTeW5jaHJvbm91c0NvbXBvbmVudDogaXNTeW5jaHJvbm91c0NvbXBvbmVudCB9O1xuICAgICAgICBkZWxldGUgbG9hZGluZ1N1YnNjcmliYWJsZXNDYWNoZVtjb21wb25lbnROYW1lXTtcblxuICAgICAgICAgICAgICAvLyBGb3IgQVBJIGNvbnNpc3RlbmN5LCBhbGwgbG9hZHMgY29tcGxldGUgYXN5bmNocm9ub3VzbHkuIEhvd2V2ZXIgd2Ugd2FudCB0byBhdm9pZFxuICAgICAgICAgICAgICAvLyBhZGRpbmcgYW4gZXh0cmEgdGFzayBzY2hlZHVsZSBpZiBpdCdzIHVubmVjZXNzYXJ5IChpLmUuLCB0aGUgY29tcGxldGlvbiBpcyBhbHJlYWR5XG4gICAgICAgICAgICAgIC8vIGFzeW5jKS5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBieXBhc3MgdGhlICdhbHdheXMgYXN5bmNocm9ub3VzJyBmZWF0dXJlIGJ5IHB1dHRpbmcgdGhlIHN5bmNocm9ub3VzOnRydWVcbiAgICAgICAgICAgICAgLy8gZmxhZyBvbiB5b3VyIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIHdoZW4geW91IHJlZ2lzdGVyIGl0LlxuICAgICAgICBpZiAoY29tcGxldGVkQXN5bmMgfHwgaXNTeW5jaHJvbm91c0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG5vdGlmeVN1YnNjcmliZXJzIGlnbm9yZXMgYW55IGRlcGVuZGVuY2llcyByZWFkIHdpdGhpbiB0aGUgY2FsbGJhY2suXG4gICAgICAgICAgICAgICAgICAvLyBTZWUgY29tbWVudCBpbiBsb2FkZXJSZWdpc3RyeUJlaGF2aW9ycy5qcyBmb3IgcmVhc29uaW5nXG4gICAgICAgICAgX3N1YnNjcmliYWJsZS5ub3RpZnlTdWJzY3JpYmVycyhkZWZpbml0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfc3Vic2NyaWJhYmxlLm5vdGlmeVN1YnNjcmliZXJzKGRlZmluaXRpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbXBsZXRlZEFzeW5jID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3N1YnNjcmliYWJsZS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luTG9hZGluZ0NvbXBvbmVudCAoY29tcG9uZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICBnZXRGaXJzdFJlc3VsdEZyb21Mb2FkZXJzKCdnZXRDb25maWcnLCBbY29tcG9uZW50TmFtZV0sIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGNvbmZpZywgc28gbm93IGxvYWQgaXRzIGRlZmluaXRpb25cbiAgICAgICAgZ2V0Rmlyc3RSZXN1bHRGcm9tTG9hZGVycygnbG9hZENvbXBvbmVudCcsIFtjb21wb25lbnROYW1lLCBjb25maWddLCBmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgIGNhbGxiYWNrKGRlZmluaXRpb24sIGNvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVGhlIGNvbXBvbmVudCBoYXMgbm8gY29uZmlnIC0gaXQncyB1bmtub3duIHRvIGFsbCB0aGUgbG9hZGVycy5cbiAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgbm90IGFuIGVycm9yIChlLmcuLCBhIG1vZHVsZSBsb2FkaW5nIGVycm9yKSAtIHRoYXQgd291bGQgYWJvcnQgdGhlXG4gICAgICAgICAgICAgIC8vIHByb2Nlc3MgYW5kIHRoaXMgY2FsbGJhY2sgd291bGQgbm90IHJ1bi4gRm9yIHRoaXMgY2FsbGJhY2sgdG8gcnVuLCBhbGwgbG9hZGVycyBtdXN0XG4gICAgICAgICAgICAgIC8vIGhhdmUgY29uZmlybWVkIHRoZXkgZG9uJ3Qga25vdyBhYm91dCB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGaXJzdFJlc3VsdEZyb21Mb2FkZXJzIChtZXRob2ROYW1lLCBhcmdzRXhjZXB0Q2FsbGJhY2ssIGNhbGxiYWNrLCBjYW5kaWRhdGVMb2FkZXJzKSB7XG4gICAgICAvLyBPbiB0aGUgZmlyc3QgY2FsbCBpbiB0aGUgc3RhY2ssIHN0YXJ0IHdpdGggdGhlIGZ1bGwgc2V0IG9mIGxvYWRlcnNcbiAgICBpZiAoIWNhbmRpZGF0ZUxvYWRlcnMpIHtcbiAgICAgIGNhbmRpZGF0ZUxvYWRlcnMgPSByZWdpc3RyeS5sb2FkZXJzLnNsaWNlKDApOyAvLyBVc2UgYSBjb3B5LCBiZWNhdXNlIHdlJ2xsIGJlIG11dGF0aW5nIHRoaXMgYXJyYXlcbiAgICB9XG5cbiAgICAgIC8vIFRyeSB0aGUgbmV4dCBjYW5kaWRhdGVcbiAgICB2YXIgY3VycmVudENhbmRpZGF0ZUxvYWRlciA9IGNhbmRpZGF0ZUxvYWRlcnMuc2hpZnQoKTtcbiAgICBpZiAoY3VycmVudENhbmRpZGF0ZUxvYWRlcikge1xuICAgICAgdmFyIG1ldGhvZEluc3RhbmNlID0gY3VycmVudENhbmRpZGF0ZUxvYWRlclttZXRob2ROYW1lXTtcbiAgICAgIGlmIChtZXRob2RJbnN0YW5jZSkge1xuICAgICAgICB2YXIgd2FzQWJvcnRlZCA9IGZhbHNlLFxuICAgICAgICAgIHN5bmNocm9ub3VzUmV0dXJuVmFsdWUgPSBtZXRob2RJbnN0YW5jZS5hcHBseShjdXJyZW50Q2FuZGlkYXRlTG9hZGVyLCBhcmdzRXhjZXB0Q2FsbGJhY2suY29uY2F0KGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh3YXNBYm9ydGVkKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjYW5kaWRhdGUgcmV0dXJuZWQgYSB2YWx1ZS4gVXNlIGl0LlxuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRoZSBuZXh0IGNhbmRpZGF0ZVxuICAgICAgICAgICAgICBnZXRGaXJzdFJlc3VsdEZyb21Mb2FkZXJzKG1ldGhvZE5hbWUsIGFyZ3NFeGNlcHRDYWxsYmFjaywgY2FsbGJhY2ssIGNhbmRpZGF0ZUxvYWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAvLyBDdXJyZW50bHksIGxvYWRlcnMgbWF5IG5vdCByZXR1cm4gYW55dGhpbmcgc3luY2hyb25vdXNseS4gVGhpcyBsZWF2ZXMgb3BlbiB0aGUgcG9zc2liaWxpdHlcbiAgICAgICAgICAgICAgLy8gdGhhdCB3ZSdsbCBleHRlbmQgdGhlIEFQSSB0byBzdXBwb3J0IHN5bmNocm9ub3VzIHJldHVybiB2YWx1ZXMgaW4gdGhlIGZ1dHVyZS4gSXQgd29uJ3QgYmVcbiAgICAgICAgICAgICAgLy8gYSBicmVha2luZyBjaGFuZ2UsIGJlY2F1c2UgY3VycmVudGx5IG5vIGxvYWRlciBpcyBhbGxvd2VkIHRvIHJldHVybiBhbnl0aGluZyBleGNlcHQgdW5kZWZpbmVkLlxuICAgICAgICBpZiAoc3luY2hyb25vdXNSZXR1cm5WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgd2FzQWJvcnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgIC8vIE1ldGhvZCB0byBzdXBwcmVzcyBleGNlcHRpb25zIHdpbGwgcmVtYWluIHVuZG9jdW1lbnRlZC4gVGhpcyBpcyBvbmx5IHRvIGtlZXBcbiAgICAgICAgICAgICAgICAgIC8vIEtPJ3Mgc3BlY3MgcnVubmluZyB0aWRpbHksIHNpbmNlIHdlIGNhbiBvYnNlcnZlIHRoZSBsb2FkaW5nIGdvdCBhYm9ydGVkIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAgIC8vIGhhdmluZyBleGNlcHRpb25zIGNsdXR0ZXJpbmcgdXAgdGhlIGNvbnNvbGUgdG9vLlxuICAgICAgICAgIGlmICghY3VycmVudENhbmRpZGF0ZUxvYWRlci5zdXBwcmVzc0xvYWRlckV4Y2VwdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IGxvYWRlcnMgbXVzdCBzdXBwbHkgdmFsdWVzIGJ5IGludm9raW5nIHRoZSBjYWxsYmFjaywgbm90IGJ5IHJldHVybmluZyB2YWx1ZXMgc3luY2hyb25vdXNseS4nKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBjYW5kaWRhdGUgZG9lc24ndCBoYXZlIHRoZSByZWxldmFudCBoYW5kbGVyLiBTeW5jaHJvbm91c2x5IG1vdmUgb24gdG8gdGhlIG5leHQgb25lLlxuICAgICAgICBnZXRGaXJzdFJlc3VsdEZyb21Mb2FkZXJzKG1ldGhvZE5hbWUsIGFyZ3NFeGNlcHRDYWxsYmFjaywgY2FsbGJhY2ssIGNhbmRpZGF0ZUxvYWRlcnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gY2FuZGlkYXRlcyByZXR1cm5lZCBhIHZhbHVlXG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVnaXN0cnkgPSB7XG4gICAgZ2V0IChjb21wb25lbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGNhY2hlZERlZmluaXRpb24gPSBnZXRPYmplY3RPd25Qcm9wZXJ0eShsb2FkZWREZWZpbml0aW9uc0NhY2hlLCBjb21wb25lbnROYW1lKTtcbiAgICAgIGlmIChjYWNoZWREZWZpbml0aW9uKSB7XG4gICAgICAgIC8vIEl0J3MgYWxyZWFkeSBsb2FkZWQgYW5kIGNhY2hlZC4gUmV1c2UgdGhlIHNhbWUgZGVmaW5pdGlvbiBvYmplY3QuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBmb3IgQVBJIGNvbnNpc3RlbmN5LCBldmVuIGNhY2hlIGhpdHMgY29tcGxldGUgYXN5bmNocm9ub3VzbHkgYnkgZGVmYXVsdC5cbiAgICAgICAgLy8gWW91IGNhbiBieXBhc3MgdGhpcyBieSBwdXR0aW5nIHN5bmNocm9ub3VzOnRydWUgb24geW91ciBjb21wb25lbnQgY29uZmlnLlxuICAgICAgICBpZiAoY2FjaGVkRGVmaW5pdGlvbi5pc1N5bmNocm9ub3VzQ29tcG9uZW50KSB7XG4gICAgICAgICAgaWdub3JlKGZ1bmN0aW9uICgpIHsgLy8gU2VlIGNvbW1lbnQgaW4gbG9hZGVyUmVnaXN0cnlCZWhhdmlvcnMuanMgZm9yIHJlYXNvbmluZ1xuICAgICAgICAgICAgY2FsbGJhY2soY2FjaGVkRGVmaW5pdGlvbi5kZWZpbml0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2hlZHVsZShmdW5jdGlvbiAoKSB7IGNhbGxiYWNrKGNhY2hlZERlZmluaXRpb24uZGVmaW5pdGlvbik7IH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBKb2luIHRoZSBsb2FkaW5nIHByb2Nlc3MgdGhhdCBpcyBhbHJlYWR5IHVuZGVyd2F5LCBvciBzdGFydCBhIG5ldyBvbmUuXG4gICAgICAgIGxvYWRDb21wb25lbnRBbmROb3RpZnkoY29tcG9uZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjbGVhckNhY2hlZERlZmluaXRpb24gKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGRlbGV0ZSBsb2FkZWREZWZpbml0aW9uc0NhY2hlW2NvbXBvbmVudE5hbWVdO1xuICAgIH0sXG5cbiAgICBfZ2V0Rmlyc3RSZXN1bHRGcm9tTG9hZGVyczogZ2V0Rmlyc3RSZXN1bHRGcm9tTG9hZGVycyxcblxuICAgIGxvYWRlcnM6IFtdXG4gIH07XG5cbiAgLy8gVGhlIGRlZmF1bHQgbG9hZGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0d28gdGhpbmdzOlxuICAvLyAxLiBNYWludGFpbmluZyB0aGUgZGVmYXVsdCBpbi1tZW1vcnkgcmVnaXN0cnkgb2YgY29tcG9uZW50IGNvbmZpZ3VyYXRpb24gb2JqZWN0c1xuICAvLyAgICAoaS5lLiwgdGhlIHRoaW5nIHlvdSdyZSB3cml0aW5nIHRvIHdoZW4geW91IGNhbGwga28uY29tcG9uZW50cy5yZWdpc3Rlcihzb21lTmFtZSwgLi4uKSlcbiAgLy8gMi4gQW5zd2VyaW5nIHJlcXVlc3RzIGZvciBjb21wb25lbnRzIGJ5IGZldGNoaW5nIGNvbmZpZ3VyYXRpb24gb2JqZWN0c1xuICAvLyAgICBmcm9tIHRoYXQgZGVmYXVsdCBpbi1tZW1vcnkgcmVnaXN0cnkgYW5kIHJlc29sdmluZyB0aGVtIGludG8gc3RhbmRhcmRcbiAgLy8gICAgY29tcG9uZW50IGRlZmluaXRpb24gb2JqZWN0cyAob2YgdGhlIGZvcm0geyBjcmVhdGVWaWV3TW9kZWw6IC4uLiwgdGVtcGxhdGU6IC4uLiB9KVxuICAvLyBDdXN0b20gbG9hZGVycyBtYXkgb3ZlcnJpZGUgZWl0aGVyIG9mIHRoZXNlIGZhY2lsaXRpZXMsIGkuZS4sXG4gIC8vIDEuIFRvIHN1cHBseSBjb25maWd1cmF0aW9uIG9iamVjdHMgZnJvbSBzb21lIG90aGVyIHNvdXJjZSAoZS5nLiwgY29udmVudGlvbnMpXG4gIC8vIDIuIE9yLCB0byByZXNvbHZlIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyBieSBsb2FkaW5nIHZpZXdtb2RlbHMvdGVtcGxhdGVzIHZpYSBhcmJpdHJhcnkgbG9naWMuXG5cbiAgdmFyIGRlZmF1bHRDb25maWdSZWdpc3RyeSA9IHt9O1xuICBjb25zdCBWSUVXX01PREVMX0ZBQ1RPUlkgPSBTeW1ib2woJ0tub2Nrb3V0IFZpZXcgTW9kZWwgVmlld01vZGVsIGZhY3RvcnknKTtcblxuICBmdW5jdGlvbiByZWdpc3RlciAoY29tcG9uZW50TmFtZSwgY29uZmlnKSB7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb25maWd1cmF0aW9uIGZvciAnICsgY29tcG9uZW50TmFtZSlcbiAgICB9XG5cbiAgICBpZiAoaXNSZWdpc3RlcmVkKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCAnICsgY29tcG9uZW50TmFtZSArICcgaXMgYWxyZWFkeSByZWdpc3RlcmVkJylcbiAgICB9XG5cbiAgICBjb25zdCBjZW9rID0gY29tcG9uZW50TmFtZS5pbmNsdWRlcygnLScpICYmIGNvbXBvbmVudE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gY29tcG9uZW50TmFtZTtcblxuICAgIGlmICghY29uZmlnLmlnbm9yZUN1c3RvbUVsZW1lbnRXYXJuaW5nICYmICFjZW9rKSB7XG4gICAgICBjb25zb2xlLmxvZyhgXG7wn6WKICBLbm9ja291dCB3YXJuaW5nOiBjb21wb25lbnRzIGZvciBjdXN0b20gZWxlbWVudHMgbXVzdCBiZSBsb3dlcmNhc2UgYW5kIGNvbnRhaW4gYSBkYXNoLiAgVG8gaWdub3JlIHRoaXMgd2FybmluZywgYWRkIHRvIHRoZSAnY29uZmlnJyBvZiAucmVnaXN0ZXIoY29tcG9uZW50TmFtZSwgY29uZmlnKTpcblxuICAgICAgICAgIGlnbm9yZUN1c3RvbUVsZW1lbnRXYXJuaW5nOiB0cnVlXG4gICAgYCk7XG4gICAgfVxuXG4gICAgZGVmYXVsdENvbmZpZ1JlZ2lzdHJ5W2NvbXBvbmVudE5hbWVdID0gY29uZmlnO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSZWdpc3RlcmVkIChjb21wb25lbnROYW1lKSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5KGRlZmF1bHRDb25maWdSZWdpc3RyeSwgY29tcG9uZW50TmFtZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXIgKGNvbXBvbmVudE5hbWUpIHtcbiAgICBkZWxldGUgZGVmYXVsdENvbmZpZ1JlZ2lzdHJ5W2NvbXBvbmVudE5hbWVdO1xuICAgIHJlZ2lzdHJ5LmNsZWFyQ2FjaGVkRGVmaW5pdGlvbihjb21wb25lbnROYW1lKTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0TG9hZGVyID0ge1xuICAgIGdldENvbmZpZzogZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gaGFzT3duUHJvcGVydHkoZGVmYXVsdENvbmZpZ1JlZ2lzdHJ5LCBjb21wb25lbnROYW1lKVxuICAgICAgICAgICAgICA/IGRlZmF1bHRDb25maWdSZWdpc3RyeVtjb21wb25lbnROYW1lXVxuICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgIH0sXG5cbiAgICBsb2FkQ29tcG9uZW50OiBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSwgY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGVycm9yQ2FsbGJhY2sgPSBtYWtlRXJyb3JDYWxsYmFjayhjb21wb25lbnROYW1lKTtcbiAgICAgIHBvc3NpYmx5R2V0Q29uZmlnRnJvbUFtZChlcnJvckNhbGxiYWNrLCBjb25maWcsIGZ1bmN0aW9uIChsb2FkZWRDb25maWcpIHtcbiAgICAgICAgcmVzb2x2ZUNvbmZpZyhjb21wb25lbnROYW1lLCBlcnJvckNhbGxiYWNrLCBsb2FkZWRDb25maWcsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBsb2FkVGVtcGxhdGU6IGZ1bmN0aW9uIChjb21wb25lbnROYW1lLCB0ZW1wbGF0ZUNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgIHJlc29sdmVUZW1wbGF0ZShtYWtlRXJyb3JDYWxsYmFjayhjb21wb25lbnROYW1lKSwgdGVtcGxhdGVDb25maWcsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgbG9hZFZpZXdNb2RlbDogZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIHZpZXdNb2RlbENvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgIHJlc29sdmVWaWV3TW9kZWwobWFrZUVycm9yQ2FsbGJhY2soY29tcG9uZW50TmFtZSksIHZpZXdNb2RlbENvbmZpZywgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3JlYXRlVmlld01vZGVsS2V5ID0gJ2NyZWF0ZVZpZXdNb2RlbCc7XG5cbiAgLy8gVGFrZXMgYSBjb25maWcgb2JqZWN0IG9mIHRoZSBmb3JtIHsgdGVtcGxhdGU6IC4uLiwgdmlld01vZGVsOiAuLi4gfSwgYW5kIGFzeW5jaHJvbm91c2x5IGNvbnZlcnQgaXRcbiAgLy8gaW50byB0aGUgc3RhbmRhcmQgY29tcG9uZW50IGRlZmluaXRpb24gZm9ybWF0OlxuICAvLyAgICB7IHRlbXBsYXRlOiA8QXJyYXlPZkRvbU5vZGVzPiwgY3JlYXRlVmlld01vZGVsOiBmdW5jdGlvbihwYXJhbXMsIGNvbXBvbmVudEluZm8pIHsgLi4uIH0gfS5cbiAgLy8gU2luY2UgYm90aCB0ZW1wbGF0ZSBhbmQgdmlld01vZGVsIG1heSBuZWVkIHRvIGJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5LCBib3RoIHRhc2tzIGFyZSBwZXJmb3JtZWRcbiAgLy8gaW4gcGFyYWxsZWwsIGFuZCB0aGUgcmVzdWx0cyBqb2luZWQgd2hlbiBib3RoIGFyZSByZWFkeS4gV2UgZG9uJ3QgZGVwZW5kIG9uIGFueSBwcm9taXNlcyBpbmZyYXN0cnVjdHVyZSxcbiAgLy8gc28gdGhpcyBpcyBpbXBsZW1lbnRlZCBtYW51YWxseSBiZWxvdy5cbiAgZnVuY3Rpb24gcmVzb2x2ZUNvbmZpZyAoY29tcG9uZW50TmFtZSwgZXJyb3JDYWxsYmFjaywgY29uZmlnLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgIG1ha2VDYWxsQmFja1doZW5aZXJvID0gMixcbiAgICAgIHRyeUlzc3VlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgtLW1ha2VDYWxsQmFja1doZW5aZXJvID09PSAwKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRlbXBsYXRlQ29uZmlnID0gY29uZmlnWyd0ZW1wbGF0ZSddLFxuICAgICAgdmlld01vZGVsQ29uZmlnID0gY29uZmlnWyd2aWV3TW9kZWwnXTtcblxuICAgIGlmICh0ZW1wbGF0ZUNvbmZpZykge1xuICAgICAgcG9zc2libHlHZXRDb25maWdGcm9tQW1kKGVycm9yQ2FsbGJhY2ssIHRlbXBsYXRlQ29uZmlnLCBmdW5jdGlvbiAobG9hZGVkQ29uZmlnKSB7XG4gICAgICAgIHJlZ2lzdHJ5Ll9nZXRGaXJzdFJlc3VsdEZyb21Mb2FkZXJzKCdsb2FkVGVtcGxhdGUnLCBbY29tcG9uZW50TmFtZSwgbG9hZGVkQ29uZmlnXSwgZnVuY3Rpb24gKHJlc29sdmVkVGVtcGxhdGUpIHtcbiAgICAgICAgICByZXN1bHRbJ3RlbXBsYXRlJ10gPSByZXNvbHZlZFRlbXBsYXRlO1xuICAgICAgICAgIHRyeUlzc3VlQ2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5SXNzdWVDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGlmICh2aWV3TW9kZWxDb25maWcpIHtcbiAgICAgIHBvc3NpYmx5R2V0Q29uZmlnRnJvbUFtZChlcnJvckNhbGxiYWNrLCB2aWV3TW9kZWxDb25maWcsIGZ1bmN0aW9uIChsb2FkZWRDb25maWcpIHtcbiAgICAgICAgcmVnaXN0cnkuX2dldEZpcnN0UmVzdWx0RnJvbUxvYWRlcnMoJ2xvYWRWaWV3TW9kZWwnLCBbY29tcG9uZW50TmFtZSwgbG9hZGVkQ29uZmlnXSwgZnVuY3Rpb24gKHJlc29sdmVkVmlld01vZGVsKSB7XG4gICAgICAgICAgcmVzdWx0W2NyZWF0ZVZpZXdNb2RlbEtleV0gPSByZXNvbHZlZFZpZXdNb2RlbDtcbiAgICAgICAgICB0cnlJc3N1ZUNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeUlzc3VlQ2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlVGVtcGxhdGUgKGVycm9yQ2FsbGJhY2ssIHRlbXBsYXRlQ29uZmlnLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgdGVtcGxhdGVDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gTWFya3VwIC0gcGFyc2UgaXRcbiAgICAgIGNhbGxiYWNrKHBhcnNlSHRtbEZyYWdtZW50KHRlbXBsYXRlQ29uZmlnKSk7XG4gICAgfSBlbHNlIGlmICh0ZW1wbGF0ZUNvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgLy8gQXNzdW1lIGFscmVhZHkgYW4gYXJyYXkgb2YgRE9NIG5vZGVzIC0gcGFzcyB0aHJvdWdoIHVuY2hhbmdlZFxuICAgICAgY2FsbGJhY2sodGVtcGxhdGVDb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNEb2N1bWVudEZyYWdtZW50KHRlbXBsYXRlQ29uZmlnKSkge1xuICAgICAgICAgIC8vIERvY3VtZW50IGZyYWdtZW50IC0gdXNlIGl0cyBjaGlsZCBub2Rlc1xuICAgICAgY2FsbGJhY2sobWFrZUFycmF5KHRlbXBsYXRlQ29uZmlnLmNoaWxkTm9kZXMpKTtcbiAgICB9IGVsc2UgaWYgKHRlbXBsYXRlQ29uZmlnLmVsZW1lbnQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGVtcGxhdGVDb25maWcuZWxlbWVudDtcbiAgICAgIGlmIChpc0RvbUVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgLy8gRWxlbWVudCBpbnN0YW5jZSAtIGNvcHkgaXRzIGNoaWxkIG5vZGVzXG4gICAgICAgIGNhbGxiYWNrKGNsb25lTm9kZXNGcm9tVGVtcGxhdGVTb3VyY2VFbGVtZW50KGVsZW1lbnQpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIC8vIEVsZW1lbnQgSUQgLSBmaW5kIGl0LCB0aGVuIGNvcHkgaXRzIGNoaWxkIG5vZGVzXG4gICAgICAgIHZhciBlbGVtSW5zdGFuY2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1JbnN0YW5jZSkge1xuICAgICAgICAgIGNhbGxiYWNrKGNsb25lTm9kZXNGcm9tVGVtcGxhdGVTb3VyY2VFbGVtZW50KGVsZW1JbnN0YW5jZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yQ2FsbGJhY2soJ0Nhbm5vdCBmaW5kIGVsZW1lbnQgd2l0aCBJRCAnICsgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soJ1Vua25vd24gZWxlbWVudCB0eXBlOiAnICsgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0ZW1wbGF0ZUNvbmZpZy5lbGVtZW50TmFtZSkge1xuICAgICAgLy8gSlNYIGluIHRoZSBzdHlsZSBvZiBiYWJlbC1wbHVnaW4tdHJhbnNmb3JtLWpzeFxuICAgICAgY2FsbGJhY2sodGVtcGxhdGVDb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckNhbGxiYWNrKCdVbmtub3duIHRlbXBsYXRlIHZhbHVlOiAnICsgdGVtcGxhdGVDb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVWaWV3TW9kZWwgKGVycm9yQ2FsbGJhY2ssIHZpZXdNb2RlbENvbmZpZywgY2FsbGJhY2spIHtcbiAgICBpZiAodmlld01vZGVsQ29uZmlnW1ZJRVdfTU9ERUxfRkFDVE9SWV0pIHtcbiAgICAgIGNhbGxiYWNrKCguLi5hcmdzKSA9PiB2aWV3TW9kZWxDb25maWdbVklFV19NT0RFTF9GQUNUT1JZXSguLi5hcmdzKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygdmlld01vZGVsQ29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gQ29uc3RydWN0b3IgLSBjb252ZXJ0IHRvIHN0YW5kYXJkIGZhY3RvcnkgZnVuY3Rpb24gZm9ybWF0XG4gICAgICAgICAgLy8gQnkgZGVzaWduLCB0aGlzIGRvZXMgKm5vdCogc3VwcGx5IGNvbXBvbmVudEluZm8gdG8gdGhlIGNvbnN0cnVjdG9yLCBhcyB0aGUgaW50ZW50IGlzIHRoYXRcbiAgICAgICAgICAvLyBjb21wb25lbnRJbmZvIGNvbnRhaW5zIG5vbi12aWV3bW9kZWwgZGF0YSAoZS5nLiwgdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQpIHRoYXQgc2hvdWxkIG9ubHlcbiAgICAgICAgICAvLyBiZSB1c2VkIGluIGZhY3RvcnkgZnVuY3Rpb25zLCBub3Qgdmlld21vZGVsIGNvbnN0cnVjdG9ycy5cbiAgICAgIGNhbGxiYWNrKGZ1bmN0aW9uIChwYXJhbXMgLyosIGNvbXBvbmVudEluZm8gKi8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyB2aWV3TW9kZWxDb25maWcocGFyYW1zKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygdmlld01vZGVsQ29uZmlnW2NyZWF0ZVZpZXdNb2RlbEtleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBBbHJlYWR5IGEgZmFjdG9yeSBmdW5jdGlvbiAtIHVzZSBpdCBhcy1pc1xuICAgICAgY2FsbGJhY2sodmlld01vZGVsQ29uZmlnW2NyZWF0ZVZpZXdNb2RlbEtleV0pO1xuICAgIH0gZWxzZSBpZiAoJ2luc3RhbmNlJyBpbiB2aWV3TW9kZWxDb25maWcpIHtcbiAgICAgICAgICAvLyBGaXhlZCBvYmplY3QgaW5zdGFuY2UgLSBwcm9tb3RlIHRvIGNyZWF0ZVZpZXdNb2RlbCBmb3JtYXQgZm9yIEFQSSBjb25zaXN0ZW5jeVxuICAgICAgdmFyIGZpeGVkSW5zdGFuY2UgPSB2aWV3TW9kZWxDb25maWdbJ2luc3RhbmNlJ107XG4gICAgICBjYWxsYmFjayhmdW5jdGlvbiAoLyogcGFyYW1zLCBjb21wb25lbnRJbmZvICovKSB7XG4gICAgICAgIHJldHVybiBmaXhlZEluc3RhbmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCd2aWV3TW9kZWwnIGluIHZpZXdNb2RlbENvbmZpZykge1xuICAgICAgICAgIC8vIFJlc29sdmVkIEFNRCBtb2R1bGUgd2hvc2UgdmFsdWUgaXMgb2YgdGhlIGZvcm0geyB2aWV3TW9kZWw6IC4uLiB9XG4gICAgICByZXNvbHZlVmlld01vZGVsKGVycm9yQ2FsbGJhY2ssIHZpZXdNb2RlbENvbmZpZ1sndmlld01vZGVsJ10sIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JDYWxsYmFjaygnVW5rbm93biB2aWV3TW9kZWwgdmFsdWU6ICcgKyB2aWV3TW9kZWxDb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lTm9kZXNGcm9tVGVtcGxhdGVTb3VyY2VFbGVtZW50IChlbGVtSW5zdGFuY2UpIHtcbiAgICBzd2l0Y2ggKHRhZ05hbWVMb3dlcihlbGVtSW5zdGFuY2UpKSB7XG4gICAgICBjYXNlICdzY3JpcHQnOlxuICAgICAgICByZXR1cm4gcGFyc2VIdG1sRnJhZ21lbnQoZWxlbUluc3RhbmNlLnRleHQpXG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIHJldHVybiBwYXJzZUh0bWxGcmFnbWVudChlbGVtSW5zdGFuY2UudmFsdWUpXG4gICAgICBjYXNlICd0ZW1wbGF0ZSc6XG4gICAgICAgICAgLy8gRm9yIGJyb3dzZXJzIHdpdGggcHJvcGVyIDx0ZW1wbGF0ZT4gZWxlbWVudCBzdXBwb3J0IChpLmUuLCB3aGVyZSB0aGUgLmNvbnRlbnQgcHJvcGVydHlcbiAgICAgICAgICAvLyBnaXZlcyBhIGRvY3VtZW50IGZyYWdtZW50KSwgdXNlIHRoYXQgZG9jdW1lbnQgZnJhZ21lbnQuXG4gICAgICAgIGlmIChpc0RvY3VtZW50RnJhZ21lbnQoZWxlbUluc3RhbmNlLmNvbnRlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lTm9kZXMoZWxlbUluc3RhbmNlLmNvbnRlbnQuY2hpbGROb2RlcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgICAgLy8gUmVndWxhciBlbGVtZW50cyBzdWNoIGFzIDxkaXY+LCBhbmQgPHRlbXBsYXRlPiBlbGVtZW50cyBvbiBvbGQgYnJvd3NlcnMgdGhhdCBkb24ndCByZWFsbHlcbiAgICAgIC8vIHVuZGVyc3RhbmQgPHRlbXBsYXRlPiBhbmQganVzdCB0cmVhdCBpdCBhcyBhIHJlZ3VsYXIgY29udGFpbmVyXG4gICAgcmV0dXJuIGNsb25lTm9kZXMoZWxlbUluc3RhbmNlLmNoaWxkTm9kZXMpXG4gIH1cblxuICBmdW5jdGlvbiBwb3NzaWJseUdldENvbmZpZ0Zyb21BbWQgKGVycm9yQ2FsbGJhY2ssIGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZXF1aXJlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIFRoZSBjb25maWcgaXMgdGhlIHZhbHVlIG9mIGFuIEFNRCBtb2R1bGVcbiAgICAgIGlmICh3aW5kb3cuYW1kUmVxdWlyZSB8fCB3aW5kb3cucmVxdWlyZSkge1xuICAgICAgICAod2luZG93LmFtZFJlcXVpcmUgfHwgd2luZG93LnJlcXVpcmUpKFtjb25maWcucmVxdWlyZV0sIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soJ1VzZXMgcmVxdWlyZSwgYnV0IG5vIEFNRCBsb2FkZXIgaXMgcHJlc2VudCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhjb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VFcnJvckNhbGxiYWNrIChjb21wb25lbnROYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCBcXCcnICsgY29tcG9uZW50TmFtZSArICdcXCc6ICcgKyBtZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIC8vIEJ5IGRlZmF1bHQsIHRoZSBkZWZhdWx0IGxvYWRlciBpcyB0aGUgb25seSByZWdpc3RlcmVkIGNvbXBvbmVudCBsb2FkZXJcbiAgcmVnaXN0cnkubG9hZGVycy5wdXNoKGRlZmF1bHRMb2FkZXIpO1xuXG4gIC8qKlxuICAgKiBDb21wb25lbnQgLS0tIEFic3RyYWN0IEJhc2UgQ2xhc3NcbiAgICpcbiAgICogVGhpcyBzaW1wbGlmaWVzIGFuZCBjb21wYXJ0bWVudGFsaXplcyBDb21wb25lbnRzLiAgVXNlIHRoaXM6XG4gICAqXG4gICAqICAgIGNsYXNzIENvbXBYIGV4dGVuZHMgQ29tcG9uZW50QUJDIHtcbiAgICogICAgXHRzdGF0aWMgZ2V0IGVsZW1lbnQgKCkgeyByZXR1cm4gJ2NvbXAteC1pZCcgfVxuICAgKiAgICBcdHN0YXRpYyBnZXQgc3luYyAoKSB7IHJldHVybiBmYWxzZSB9XG4gICAqICAgIFx0c3RhdGljIGdldCBlbGVtZW50TmFtZSAoKSB7IHJldHVybiAnY29tcC14JyB9XG4gICAqICAgIH1cbiAgICogICAgQ29tcFgucmVnaXN0ZXIoKVxuICAgKlxuICAgKiBpbnN0ZWFkIG9mOlxuICAgKlxuICAgKiAgIGNsYXNzIENvbXBYIHt9XG4gICAqXG4gICAqICAga28uY29tcG9uZW50cy5yZWdpc3RlcignY29tcC14Jywge1xuICAgKiAgICAgdmlld01vZGVsOiBDb21wWCxcbiAgICogICAgIHN5bmNocm9ub3VzOiBmYWxzZSxcbiAgICogICAgIHRlbXBsYXRlOiB7IGVsZW1lbnQ6ICdjb21wLXgnIH1cbiAgICogICB9KVxuICAgKlxuICAgKiBBcyB3ZWxsLCBnYWluIGFsbCB0aGUgYmVuZWZpdHMgb2YgYSBMaWZlQ3ljbGUsIG5hbWVseSBhdXRvbWF0ZWRcbiAgICogZXZlbnQgYW5kIHN1YnNjcmlwdGlvbiBhZGRpdGlvbi9yZW1vdmFsLlxuICAgKlxuICAgKiBOT1RFOiBBIENvbXBvbmVudCBjcmVhdGVkIHRoaXMgd2F5IGNhbiBhZGQgZXZlbnRzIHRvIHRoZSBjb21wb25lbnQgbm9kZVxuICAgKiB3aXRoIGB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgYWN0aW9uKWAuXG4gICAqL1xuXG4gIGNsYXNzIENvbXBvbmVudEFCQyBleHRlbmRzIExpZmVDeWNsZSB7XG4gIFx0LyoqXG4gICAgICogVGhlIHRhZyBuYW1lIG9mIHRoZSBjdXN0b20gZWxlbWVudC4gIEZvciBleGFtcGxlICdteS1jb21wb25lbnQnLlxuICAgICAqIEJ5IGRlZmF1bHQgY29udmVydHMgdGhlIGNsYXNzIG5hbWUgZnJvbSBjYW1lbCBjYXNlIHRvIGtlYmFiIGNhc2UuXG4gIFx0ICogQHJldHVybiB7c3RyaW5nfSBUaGUgY3VzdG9tIG5vZGUgbmFtZSBvZiB0aGlzIGNvbXBvbmVudC5cbiAgXHQgKi9cbiAgICBzdGF0aWMgZ2V0IGN1c3RvbUVsZW1lbnROYW1lICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWUucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKVxuICAgIH1cblxuICBcdC8qKlxuICBcdCAqIE92ZXJsb2FkIHRoaXMgdG8gcmV0dXJuOlxuICBcdCAqIDEuIEEgc3RyaW5nIG9mIG1hcmt1cFxuICBcdCAqIDIuIEFuIGFycmF5IG9mIERPTSBub2Rlc1xuICBcdCAqIDMuIEEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgXHQgKiA0LiBBbiBBTUQgbW9kdWxlICh3aXRoIGB7cmVxdWlyZTogJ3NvbWUvdGVtcGxhdGUnfWApXG4gIFx0ICogQHJldHVybiB7bWl4ZWR9IE9uZSBvZiB0aGUgYWNjZXB0ZWQgdGVtcGxhdGUgdHlwZXMgZm9yIHRoZSBDb21wb25lbnRCaW5kaW5nLlxuICBcdCAqL1xuICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUgKCkge1xuICAgICAgaWYgKCd0ZW1wbGF0ZScgaW4gdGhpcy5wcm90b3R5cGUpIHsgcmV0dXJuIH1cbiAgICAgIHJldHVybiB7IGVsZW1lbnQ6IHRoaXMuZWxlbWVudCB9XG4gICAgfVxuXG4gIFx0LyoqXG4gIFx0ICogVGhpcyBpcyBjYWxsZWQgYnkgdGhlIGRlZmF1bHQgYHRlbXBsYXRlYC4gIE92ZXJsb2FkIHRoaXMgdG8gcmV0dXJuOlxuICBcdCAqIDEuIFRoZSBlbGVtZW50IElEXG4gIFx0ICogMi4gQSBET00gbm9kZSBpdHNlbGZcbiAgXHQgKiBAcmV0dXJuIHtzdHJpbmd8SFRNTEVsZW1lbnR9IGVpdGhlciB0aGUgZWxlbWVudCBJRCBvciBhY3R1YWwgZWxlbWVudC5cbiAgXHQgKi9cbiAgICBzdGF0aWMgZ2V0IGVsZW1lbnQgKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbQ29tcG9uZW50QUJDXSBgZWxlbWVudGAgbXVzdCBiZSBvdmVybG9hZGVkLicpXG4gICAgfVxuXG4gIFx0LyoqXG4gIFx0ICogQHJldHVybiB7Ym9vbH0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNoYWxsIGxvYWQgc3luY2hyb25vdXNseVxuICBcdCAqL1xuICAgIHN0YXRpYyBnZXQgc3luYyAoKSB7IHJldHVybiB0cnVlIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgbW9kZWwuICBXaGVuIHVzaW5nIENvbXBvbmVudEFCQyBhcyBhXG4gICAgICogYmFzZSBjbGFzcywgd2UgZG8gcGFzcyBpbiB0aGUgJGVsZW1lbnQgYW5kICRjb21wb25lbnRUZW1wbGF0ZU5vZGVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3tlbGVtZW50OiBIVE1MRWxlbWVudCwgdGVtcGxhdGVOb2RlczogW0hUTUxFbGVtZW50XX19IGNvbXBvbmVudEluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgW1ZJRVdfTU9ERUxfRkFDVE9SWV0gKHBhcmFtcywgY29tcG9uZW50SW5mbykge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKHBhcmFtcywgY29tcG9uZW50SW5mbylcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVnaXN0ZXIgKG5hbWUgPSB0aGlzLmN1c3RvbUVsZW1lbnROYW1lKSB7XG4gICAgICBjb25zdCB2aWV3TW9kZWwgPSB0aGlzO1xuICAgICAgY29uc3Qge3RlbXBsYXRlfSA9IHRoaXM7XG4gICAgICBjb25zdCBzeW5jaHJvbm91cyA9IHRoaXMuc3luYztcbiAgICAgIHJlZ2lzdGVyKG5hbWUsIHsgdmlld01vZGVsLCB0ZW1wbGF0ZSwgc3luY2hyb25vdXMgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZ2lzdHJ5JDEgPSB7XG4gICAgQ29tcG9uZW50QUJDLFxuICAgIC8vIC0tIFJlZ2lzdHJ5IC0tXG4gICAgZ2V0OiByZWdpc3RyeS5nZXQsXG4gICAgY2xlYXJDYWNoZWREZWZpbml0aW9uOiByZWdpc3RyeS5jbGVhckNhY2hlZERlZmluaXRpb24sXG5cbiAgICAvLyAtLSBMb2FkZXIgLS1cbiAgICByZWdpc3RlcixcbiAgICBpc1JlZ2lzdGVyZWQsXG4gICAgdW5yZWdpc3RlcixcbiAgICBkZWZhdWx0TG9hZGVyLFxuICAgIC8vIFwiUHJpdmF0ZWx5XCIgZXhwb3NlIHRoZSB1bmRlcmx5aW5nIGNvbmZpZyByZWdpc3RyeSBmb3IgdXNlIGluIG9sZC1JRSBzaGltXG4gICAgX2FsbFJlZ2lzdGVyZWRDb21wb25lbnRzOiBkZWZhdWx0Q29uZmlnUmVnaXN0cnksXG5cbiAgICBnZXQgbG9hZGVycyAoKSB7IHJldHVybiByZWdpc3RyeS5sb2FkZXJzIH0sXG4gICAgc2V0IGxvYWRlcnMgKGxvYWRlcnMpIHsgcmVnaXN0cnkubG9hZGVycyA9IGxvYWRlcnM7IH1cbiAgfVxuXG4gIGNsYXNzIENvbXBvbmVudFByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXIge1xuICAgIGdldCBGT1JfTk9ERV9UWVBFUyAoKSB7IHJldHVybiBbIDEgXSB9IC8vIGRvY3VtZW50LkVMRU1FTlRfTk9ERVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCA8c2xvdCBuYW1lPSdYJz4gdG8gPCEtLSBrbyBzbG90OiAnWCcgLS0+PCEtLSAva28gLS0+XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgICAqL1xuICAgIHByZXByb2Nlc3NOb2RlIChub2RlKSB7XG4gICAgICBpZiAobm9kZS50YWdOYW1lID09PSAnU0xPVCcpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCBzbG90TmFtZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCduYW1lJykgfHwgJyc7XG4gICAgICAgIGNvbnN0IG9wZW5Ob2RlID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChga28gc2xvdDogXCIke3Nsb3ROYW1lfVwiYCk7XG4gICAgICAgIGNvbnN0IGNsb3NlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJy9rbycpO1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG9wZW5Ob2RlLCBub2RlKTtcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjbG9zZU5vZGUsIG5vZGUpO1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIHJldHVybiBbb3Blbk5vZGUsIGNsb3NlTm9kZV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlSGFzQmluZGluZ3MgKG5vZGUpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZ2V0Q29tcG9uZW50TmFtZUZvck5vZGUobm9kZSkpXG4gICAgfVxuXG4gICAgZ2V0QmluZGluZ0FjY2Vzc29ycyAobm9kZSwgY29udGV4dCkge1xuICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRoaXMuZ2V0Q29tcG9uZW50TmFtZUZvck5vZGUobm9kZSk7XG4gICAgICBpZiAoIWNvbXBvbmVudE5hbWUpIHsgcmV0dXJuIH1cbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9ICgpID0+ICh7XG4gICAgICAgIG5hbWU6IGNvbXBvbmVudE5hbWUsXG4gICAgICAgIHBhcmFtczogdGhpcy5nZXRDb21wb25lbnRQYXJhbXMobm9kZSwgY29udGV4dClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgY29tcG9uZW50IH1cbiAgICB9XG5cbiAgICBnZXRDb21wb25lbnROYW1lRm9yTm9kZSAobm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IG5vZGUuRUxFTUVOVF9OT0RFKSB7IHJldHVybiB9XG4gICAgICBjb25zdCB0YWdOYW1lID0gdGFnTmFtZUxvd2VyKG5vZGUpO1xuICAgICAgaWYgKHJlZ2lzdHJ5JDEuaXNSZWdpc3RlcmVkKHRhZ05hbWUpKSB7XG4gICAgICAgIGNvbnN0IGhhc0Rhc2ggPSB0YWdOYW1lLmluY2x1ZGVzKCctJyk7XG4gICAgICAgIGNvbnN0IGlzVW5rbm93bkVudGl0eSA9ICgnJyArIG5vZGUpID09PSAnW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdJztcbiAgICAgICAgaWYgKGhhc0Rhc2ggfHwgaXNVbmtub3duRW50aXR5KSB7IHJldHVybiB0YWdOYW1lIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDb21wb25lbnRQYXJhbXMgKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobm9kZSwgY29udGV4dCwgdGhpcy5nbG9iYWxzKTtcbiAgICAgIGNvbnN0IHBhcmFtc1N0cmluZyA9IChub2RlLmdldEF0dHJpYnV0ZSgncGFyYW1zJykgfHwgJycpLnRyaW0oKTtcbiAgICAgIGNvbnN0IGFjY2Vzc29ycyA9IHBhcnNlci5wYXJzZShwYXJhbXNTdHJpbmcsIGNvbnRleHQsIG5vZGUpO1xuICAgICAgaWYgKCFhY2Nlc3NvcnMgfHwgT2JqZWN0LmtleXMoYWNjZXNzb3JzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgJHJhdzoge30gfVxuICAgICAgfVxuICAgICAgY29uc3QgJHJhdyA9IG9iamVjdE1hcChhY2Nlc3NvcnMsXG4gICAgICAgICh2YWx1ZSkgPT4gY29tcHV0ZWQodmFsdWUsIG51bGwsIHsgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBub2RlIH0pXG4gICAgICApO1xuICAgICAgY29uc3QgcGFyYW1zID0gb2JqZWN0TWFwKCRyYXcsICh2KSA9PiB0aGlzLm1ha2VQYXJhbVZhbHVlKG5vZGUsIHYpKTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgJHJhdyB9LCBwYXJhbXMpXG4gICAgfVxuXG4gICAgbWFrZVBhcmFtVmFsdWUgKG5vZGUsIHBhcmFtVmFsdWVDb21wdXRlZCkge1xuICAgICAgY29uc3QgcGFyYW1WYWx1ZSA9IHBhcmFtVmFsdWVDb21wdXRlZC5wZWVrKCk7XG4gICAgICAvLyBEb2VzIHRoZSBldmFsdWF0aW9uIG9mIHRoZSBwYXJhbWV0ZXIgdmFsdWUgdW53cmFwIGFueSBvYnNlcnZhYmxlcz9cbiAgICAgIGlmICghcGFyYW1WYWx1ZUNvbXB1dGVkLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgLy8gTm8gaXQgZG9lc24ndCwgc28gdGhlcmUncyBubyBuZWVkIGZvciBhbnkgY29tcHV0ZWQgd3JhcHBlci4gSnVzdCBwYXNzIHRocm91Z2ggdGhlIHN1cHBsaWVkIHZhbHVlIGRpcmVjdGx5LlxuICAgICAgICAvLyBFeGFtcGxlOiBcInNvbWVWYWw6IGZpcnN0TmFtZSwgYWdlOiAxMjNcIiAod2hldGhlciBvciBub3QgZmlyc3ROYW1lIGlzIGFuIG9ic2VydmFibGUvY29tcHV0ZWQpXG4gICAgICAgIHJldHVybiBwYXJhbVZhbHVlXG4gICAgICB9XG4gICAgICAvLyBZZXMgaXQgZG9lcy4gU3VwcGx5IGEgY29tcHV0ZWQgcHJvcGVydHkgdGhhdCB1bndyYXBzIGJvdGggdGhlIG91dGVyIChiaW5kaW5nIGV4cHJlc3Npb24pXG4gICAgICAvLyBsZXZlbCBvZiBvYnNlcnZhYmlsaXR5LCBhbmQgYW55IGlubmVyIChyZXN1bHRpbmcgbW9kZWwgdmFsdWUpIGxldmVsIG9mIG9ic2VydmFiaWxpdHkuXG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBjb21wb25lbnQgZG9lc24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IG11bHRpcGxlIHVud3JhcHBpbmcuIElmIHRoZSB2YWx1ZSBpcyBhXG4gICAgICAvLyB3cml0YWJsZSBvYnNlcnZhYmxlLCB0aGUgY29tcHV0ZWQgd2lsbCBhbHNvIGJlIHdyaXRhYmxlIGFuZCBwYXNzIHRoZSB2YWx1ZSBvbiB0byB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgIGNvbnN0IGlzV3JpdGVhYmxlID0gaXNXcml0ZWFibGVPYnNlcnZhYmxlKHBhcmFtVmFsdWUpO1xuXG4gICAgICByZXR1cm4gY29tcHV0ZWQoe1xuICAgICAgICByZWFkOiAoKSA9PiB1bndyYXAocGFyYW1WYWx1ZUNvbXB1dGVkKCkpLFxuICAgICAgICB3cml0ZTogaXNXcml0ZWFibGUgPyAodikgPT4gcGFyYW1WYWx1ZUNvbXB1dGVkKCkodikgOiBudWxsLFxuICAgICAgICBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IG5vZGVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYXR0cmlidXRlcyB3aXRoIGtvLSogdG8gYmluZGluZ3MuXG4gICAqXG4gICAqIGUuZy5cbiAgICogPGRpdiBrby12aXNpYmxlPSd2YWx1ZSc+PC9kaXY+XG4gICAqL1xuICBjbGFzcyBBdHRyUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlciB7XG4gICAgZ2V0IEZPUl9OT0RFX1RZUEVTICgpIHsgcmV0dXJuIFsgMSBdIH0gLy8gZG9jdW1lbnQuRUxFTUVOVF9OT0RFXG5cbiAgICBnZXQgUFJFRklYICgpIHsgcmV0dXJuICdrby0nIH1cblxuICAgIGdldEJpbmRpbmdBdHRyaWJ1dGVzTGlzdCAobm9kZSkge1xuICAgICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZXMoKSkgeyByZXR1cm4gW10gfVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKVxuICAgICAgICAuZmlsdGVyKGF0dHIgPT4gYXR0ci5uYW1lLnN0YXJ0c1dpdGgodGhpcy5QUkVGSVgpKVxuICAgIH1cblxuICAgIG5vZGVIYXNCaW5kaW5ncyAobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QmluZGluZ0F0dHJpYnV0ZXNMaXN0KG5vZGUpLmxlbmd0aCA+IDBcbiAgICB9XG5cbiAgICBnZXRCaW5kaW5nQWNjZXNzb3JzIChub2RlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgLi4udGhpcy5oYW5kbGVyc0Zyb21BdHRyaWJ1dGVzKG5vZGUsIGNvbnRleHQpKVxuICAgIH1cblxuICAgICogaGFuZGxlcnNGcm9tQXR0cmlidXRlcyAobm9kZSwgY29udGV4dCkge1xuICAgICAgZm9yIChjb25zdCBhdHRyIG9mIHRoaXMuZ2V0QmluZGluZ0F0dHJpYnV0ZXNMaXN0KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBhdHRyLm5hbWUuc3Vic3RyKHRoaXMuUFJFRklYLmxlbmd0aCk7XG4gICAgICAgIHlpZWxkIHtbbmFtZV06ICgpID0+IHRoaXMuZ2V0VmFsdWUoYXR0ci52YWx1ZSwgY29udGV4dCwgbm9kZSl9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldFZhbHVlICh0b2tlbiwgJGNvbnRleHQsIG5vZGUpIHtcbiAgICAgIC8qIEZJWE1FOiBUaGlzIGR1cGxpY2F0ZXMgSWRlbnRpZmllci5wcm90b3R5cGUubG9va3VwX3ZhbHVlOyBpdCBzaG91bGRcbiAgICAgICAgIGJlIHJlZmFjdG9yZWQgaW50byBlLmcuIGEgQmluZGluZ0NvbnRleHQgbWV0aG9kICovXG4gICAgICBpZiAoIXRva2VuKSB7IHJldHVybiB9XG4gICAgICBjb25zdCAkZGF0YSA9ICRjb250ZXh0LiRkYXRhO1xuXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJyRlbGVtZW50JzogcmV0dXJuIG5vZGVcbiAgICAgICAgY2FzZSAnJGNvbnRleHQnOiByZXR1cm4gJGNvbnRleHRcbiAgICAgICAgY2FzZSAndGhpcyc6IGNhc2UgJyRkYXRhJzogcmV0dXJuICRjb250ZXh0LiRkYXRhXG4gICAgICB9XG5cbiAgICAgIGlmICgkZGF0YSBpbnN0YW5jZW9mIE9iamVjdCAmJiB0b2tlbiBpbiAkZGF0YSkgeyByZXR1cm4gJGRhdGFbdG9rZW5dIH1cbiAgICAgIGlmICh0b2tlbiBpbiAkY29udGV4dCkgeyByZXR1cm4gJGNvbnRleHRbdG9rZW5dIH1cbiAgICAgIGlmICh0b2tlbiBpbiB0aGlzLmdsb2JhbHMpIHsgcmV0dXJuIHRoaXMuZ2xvYmFsc1t0b2tlbl0gfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB2YXJpYWJsZSAnJHt0b2tlbn0gbm90IGZvdW5kLmApXG4gICAgfVxuICB9XG5cbiAgY2xhc3MgTXVsdGlQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyIHtcbiAgICBnZXQgRk9SX05PREVfVFlQRVMgKCkgeyByZXR1cm4gdGhpcy5ub2RlVHlwZXMgfVxuXG4gICAgY29uc3RydWN0b3IgKHBhcmFtcyA9IHt9KSB7XG4gICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgY29uc3QgcHJvdmlkZXJzID0gcGFyYW1zLnByb3ZpZGVycyB8fCBbXTtcbiAgICAgIHRoaXMubm9kZVR5cGVNYXAgPSB7fTtcbiAgICAgIHRoaXMubm9kZVR5cGVzID0gW107XG4gICAgICB0aGlzLnByb3ZpZGVycyA9IFtdO1xuICAgICAgcHJvdmlkZXJzLmZvckVhY2gocCA9PiB0aGlzLmFkZFByb3ZpZGVyKHApKTtcbiAgICB9XG5cbiAgICBzZXRHbG9iYWxzIChnbG9iYWxzKSB7XG4gICAgICBbdGhpcywgLi4udGhpcy5wcm92aWRlcnNdLmZvckVhY2gocCA9PiAocC5nbG9iYWxzID0gZ2xvYmFscykpO1xuICAgIH1cblxuICAgIGFkZFByb3ZpZGVyIChwcm92aWRlcikge1xuICAgICAgdGhpcy5wcm92aWRlcnMucHVzaChwcm92aWRlcik7XG4gICAgICBwcm92aWRlci5iaW5kaW5nSGFuZGxlcnMgPSB0aGlzLmJpbmRpbmdIYW5kbGVycztcbiAgICAgIHByb3ZpZGVyLmdsb2JhbHMgPSB0aGlzLmdsb2JhbHM7XG4gICAgICBjb25zdCBub2RlVHlwZU1hcCA9IHRoaXMubm9kZVR5cGVNYXA7XG4gICAgICBmb3IgKGNvbnN0IG5vZGVUeXBlIG9mIHByb3ZpZGVyLkZPUl9OT0RFX1RZUEVTKSB7XG4gICAgICAgIGlmICghbm9kZVR5cGVNYXBbbm9kZVR5cGVdKSB7IG5vZGVUeXBlTWFwW25vZGVUeXBlXSA9IFtdOyB9XG4gICAgICAgIG5vZGVUeXBlTWFwW25vZGVUeXBlXS5wdXNoKHByb3ZpZGVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm9kZVR5cGVzID0gT2JqZWN0LmtleXModGhpcy5ub2RlVHlwZU1hcCkubWFwKGsgPT4gcGFyc2VJbnQoaywgMTApKTtcbiAgICB9XG5cbiAgICBwcm92aWRlcnNGb3IgKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVUeXBlTWFwW25vZGUubm9kZVR5cGVdIHx8IFtdXG4gICAgfVxuXG4gICAgbm9kZUhhc0JpbmRpbmdzIChub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm92aWRlcnNGb3Iobm9kZSkuc29tZShwID0+IHAubm9kZUhhc0JpbmRpbmdzKG5vZGUpKVxuICAgIH1cblxuICAgIHByZXByb2Nlc3NOb2RlIChub2RlKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIG9mIHRoaXMucHJvdmlkZXJzRm9yKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IG5ld05vZGVzID0gcHJvdmlkZXIucHJlcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgIGlmIChuZXdOb2RlcykgeyByZXR1cm4gbmV3Tm9kZXMgfVxuICAgICAgfVxuICAgIH1cblxuICAgICogZW51bWVyYXRlUHJvdmlkZXJCaW5kaW5ncyAobm9kZSwgY3R4KSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIG9mIHRoaXMucHJvdmlkZXJzRm9yKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gcHJvdmlkZXIuZ2V0QmluZGluZ0FjY2Vzc29ycyhub2RlLCBjdHgpO1xuICAgICAgICBpZiAoIWJpbmRpbmdzKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgeWllbGQgKiBPYmplY3QuZW50cmllcyhiaW5kaW5ncyB8fCB7fSk7XG4gICAgICAgIGlmIChwcm92aWRlci5wcmVlbXB0aXZlKSB7IHJldHVybiB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2V0QmluZGluZ0FjY2Vzc29ycyAobm9kZSwgY3R4KSB7XG4gICAgICBjb25zdCBiaW5kaW5ncyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBba2V5LCBhY2Nlc3Nvcl0gb2YgdGhpcy5lbnVtZXJhdGVQcm92aWRlckJpbmRpbmdzKG5vZGUsIGN0eCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiBiaW5kaW5ncykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGJpbmRpbmcgXCIke2tleX1cIiBpcyBkdXBsaWNhdGVkIGJ5IG11bHRpcGxlIHByb3ZpZGVyc2ApXG4gICAgICAgIH1cbiAgICAgICAgYmluZGluZ3Nba2V5XSA9IGFjY2Vzc29yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmRpbmdzXG4gICAgfVxuICB9XG5cbiAgY29uc3QgSU5ORVJfRVhQUkVTU0lPTiA9IC9eKFtcXHNcXFNdKil9fShbXFxzXFxTXSo/KVxce1xceyhbXFxzXFxTXSopJC87XG4gIGNvbnN0IE9VVEVSX0VYUFJFU1NJT04gPSAvXihbXFxzXFxTXSo/KVxce1xceyhbXFxzXFxTXSopfX0oW1xcc1xcU10qKSQvO1xuICBjb25zdCBCSU5ESU5HX0VYUFJFU1NJT04gPSAvXihbXixcIid7fSgpLzpbXFxdXFxzXSspXFxzKyhbXlxcczpdLiopLztcblxuICBjbGFzcyBJbnRlcnBvbGF0ZWQge1xuICAgIGNvbnN0cnVjdG9yICh0ZXh0KSB7XG4gICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cblxuICAgIHRyaW0gKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyA9PT0gbnVsbCA/ICcnIDogc3RyaW5nLnRyaW0oKVxuICAgIH1cbiAgfVxuXG4gIGNsYXNzIEV4cHJlc3Npb24kMSBleHRlbmRzIEludGVycG9sYXRlZCB7XG4gICAgYXNBdHRyIChjb250ZXh0LCBnbG9iYWxzLCBub2RlKSB7XG4gICAgICByZXR1cm4gbmV3IFBhcnNlcigpLnBhcnNlRXhwcmVzc2lvbih0aGlzLnRleHQsIGNvbnRleHQsIGdsb2JhbHMsIG5vZGUpKClcbiAgICB9XG5cbiAgICAqIHRleHROb2RlUmVwbGFjZW1lbnQgKHRleHROb2RlKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gdGhpcy50cmltKHRoaXMudGV4dCk7XG4gICAgICBjb25zdCBvd25lckRvY3VtZW50ID0gdGV4dE5vZGUgPyB0ZXh0Tm9kZS5vd25lckRvY3VtZW50IDogZG9jdW1lbnQ7XG4gICAgICBjb25zdCBmaXJzdENoYXIgPSB0ZXh0WzBdO1xuICAgICAgY29uc3QgbGFzdENoYXIgPSB0ZXh0W3RleHQubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgY2xvc2VDb21tZW50ID0gdHJ1ZTtcbiAgICAgIHZhciBiaW5kaW5nO1xuXG4gICAgICBpZiAoZmlyc3RDaGFyID09PSAnIycpIHtcbiAgICAgICAgaWYgKGxhc3RDaGFyID09PSAnLycpIHtcbiAgICAgICAgICBiaW5kaW5nID0gdGV4dC5zbGljZSgxLCAtMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmluZGluZyA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgICAgY2xvc2VDb21tZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGJpbmRpbmcubWF0Y2goQklORElOR19FWFBSRVNTSU9OKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICBiaW5kaW5nID0gbWF0Y2hlc1sxXSArICc6JyArIG1hdGNoZXNbMl07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGFyID09PSAnLycpIDsgZWxzZSBpZiAoZmlyc3RDaGFyID09PSAneycgJiYgbGFzdENoYXIgPT09ICd9Jykge1xuICAgICAgICBiaW5kaW5nID0gJ2h0bWw6JyArIHRoaXMudHJpbSh0ZXh0LnNsaWNlKDEsIC0xKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaW5kaW5nID0gJ3RleHQ6JyArIHRoaXMudHJpbSh0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgeWllbGQgb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KCdrbyAnICsgYmluZGluZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2xvc2VDb21tZW50KSB7XG4gICAgICAgIHlpZWxkIG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnL2tvJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgVGV4dCBleHRlbmRzIEludGVycG9sYXRlZCB7XG4gICAgYXNBdHRyICgpIHsgcmV0dXJuIHRoaXMudGV4dCB9XG5cbiAgICAqIHRleHROb2RlUmVwbGFjZW1lbnQgKCkge1xuICAgICAgeWllbGQgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0LnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICAgICAgICAgIEludGVycG9sYXRpb24gUGFyc2luZ1xuICAgKi9cbiAgZnVuY3Rpb24gKiBpbm5lclBhcnNlICh0ZXh0KSB7XG4gICAgY29uc3QgaW5uZXJNYXRjaCA9IHRleHQubWF0Y2goSU5ORVJfRVhQUkVTU0lPTik7XG4gICAgaWYgKGlubmVyTWF0Y2gpIHtcbiAgICAgIGNvbnN0IFtwcmUsIGlubmVyLCBwb3N0XSA9IGlubmVyTWF0Y2guc2xpY2UoMSk7XG4gICAgICB5aWVsZCAqIGlubmVyUGFyc2UocHJlKTtcbiAgICAgIHlpZWxkIG5ldyBUZXh0KGlubmVyKTtcbiAgICAgIHlpZWxkIG5ldyBFeHByZXNzaW9uJDEocG9zdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlpZWxkIG5ldyBFeHByZXNzaW9uJDEodGV4dCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gKiBwYXJzZU91dGVyTWF0Y2ggKG91dGVyTWF0Y2gpIHtcbiAgICBpZiAoIW91dGVyTWF0Y2gpIHsgcmV0dXJuIH1cbiAgICBsZXQgW3ByZSwgaW5uZXIsIHBvc3RdID0gb3V0ZXJNYXRjaC5zbGljZSgxKTtcbiAgICB5aWVsZCBuZXcgVGV4dChwcmUpO1xuICAgIHlpZWxkICogaW5uZXJQYXJzZShpbm5lcik7XG4gICAgeWllbGQgbmV3IFRleHQocG9zdCk7XG4gIH1cblxuICBmdW5jdGlvbiAqIHBhcnNlSW50ZXJwb2xhdGlvbiAodGV4dCkge1xuICAgIGZvciAoY29uc3QgdGV4dE9yRXhwciBvZiBwYXJzZU91dGVyTWF0Y2godGV4dC5tYXRjaChPVVRFUl9FWFBSRVNTSU9OKSkpIHtcbiAgICAgIGlmICh0ZXh0T3JFeHByLnRleHQpIHsgeWllbGQgdGV4dE9yRXhwcjsgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgYmluZGluZ3MgdGhhdCBhcmUgbWFwcGVkIHNwZWNpZmljIGF0dHJpYnV0ZXMsIHN1Y2ggYXNcbiAgICogdHdvLXdheSBjb21tdW5pY2F0aW9uICh2YWx1ZS9jaGVja2VkKSBvciB3aGljaCBoYXZlIGFudGktY29sbGlzaW9uXG4gICAqIHByb3BlcnRpZXMgKGNzcykuXG4gICAqL1xuICBjb25zdCBERUZBVUxUX0FUVFJJQlVURV9CSU5ESU5HX01BUCA9IHtcbiAgICB2YWx1ZTogJ3ZhbHVlJyxcbiAgICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gICAgY2xhc3M6ICdjc3MnXG4gIH07XG5cbiAgLyoqXG4gICAqICBJbnRlcnByZXQge3sgfX0gaW5zaWRlIERPTSBhdHRyaWJ1dGVzIGUuZy4gPGRpdiBjbGFzcz0ne3sgY2xhc3NlcyB9fSc+XG4gICAqL1xuICBjbGFzcyBBdHRyaWJ1dGVNdXN0YWNoZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXIge1xuICAgIGdldCBGT1JfTk9ERV9UWVBFUyAoKSB7IHJldHVybiBbIDEgXSB9IC8vIGRvY3VtZW50LkVMRU1FTlRfTk9ERVxuXG4gICAgY29uc3RydWN0b3IgKHBhcmFtcyA9IHt9KSB7XG4gICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgdGhpcy5BVFRSSUJVVEVTX1RPX1NLSVAgPSBuZXcgU2V0KHBhcmFtcy5hdHRyaWJ1dGVzVG9Ta2lwIHx8IFsnZGF0YS1iaW5kJ10pO1xuICAgICAgdGhpcy5BVFRSSUJVVEVTX0JJTkRJTkdfTUFQID0gcGFyYW1zLmF0dHJpYnV0ZXNCaW5kaW5nTWFwIHx8IERFRkFVTFRfQVRUUklCVVRFX0JJTkRJTkdfTUFQO1xuICAgIH1cblxuICAgICogYXR0cmlidXRlc1RvSW50ZXJwb2xhdGUgKGF0dHJpYnV0ZXMpIHtcbiAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBBcnJheS5mcm9tKGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGlmICh0aGlzLkFUVFJJQlVURVNfVE9fU0tJUC5oYXMoYXR0ci5uYW1lKSkgeyBjb250aW51ZSB9XG4gICAgICAgIGlmIChhdHRyLnNwZWNpZmllZCAmJiBhdHRyLnZhbHVlLmluY2x1ZGVzKCd7eycpKSB7IHlpZWxkIGF0dHI7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlSGFzQmluZGluZ3MgKG5vZGUpIHtcbiAgICAgIHJldHVybiAhdGhpcy5hdHRyaWJ1dGVzVG9JbnRlcnBvbGF0ZShub2RlLmF0dHJpYnV0ZXMpLm5leHQoKS5kb25lXG4gICAgfVxuXG4gICAgcGFydHNUb2dldGhlciAocGFydHMsIGNvbnRleHQsIG5vZGUsIC4uLnZhbHVlVG9Xcml0ZSkge1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzXG4gICAgICAgICAgLm1hcChwID0+IHVud3JhcChwLmFzQXR0cihjb250ZXh0LCB0aGlzLmdsb2JhbHMsIG5vZGUpKSkuam9pbignJylcbiAgICAgIH1cbiAgICAgIC8vIEl0IG1heSBiZSBhIHdyaXRlYWJsZSBvYnNlcnZhYmxlIGUuZy4gdmFsdWU9XCJ7eyB2YWx1ZSB9fVwiLlxuICAgICAgY29uc3QgcGFydCA9IHBhcnRzWzBdLmFzQXR0cihjb250ZXh0LCB0aGlzLmdsb2JhbHMpO1xuICAgICAgaWYgKHZhbHVlVG9Xcml0ZS5sZW5ndGgpIHsgcGFydCh2YWx1ZVRvV3JpdGVbMF0pOyB9XG4gICAgICByZXR1cm4gcGFydFxuICAgIH1cblxuICAgIGF0dHJpYnV0ZUJpbmRpbmcgKG5hbWUsIHBhcnRzKSB7XG4gICAgICByZXR1cm4gW25hbWUsIHBhcnRzXVxuICAgIH1cblxuICAgICogYmluZGluZ1BhcnRzIChub2RlLCBjb250ZXh0KSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgdGhpcy5hdHRyaWJ1dGVzVG9JbnRlcnBvbGF0ZShub2RlLmF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gQXJyYXkuZnJvbShwYXJzZUludGVycG9sYXRpb24oYXR0ci52YWx1ZSkpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoKSB7IHlpZWxkIHRoaXMuYXR0cmlidXRlQmluZGluZyhhdHRyLm5hbWUsIHBhcnRzKTsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGdldFBvc3NpYmxlRGlyZWN0QmluZGluZyAoYXR0ck5hbWUpIHtcbiAgICAgIGNvbnN0IGJpbmRpbmdOYW1lID0gdGhpcy5BVFRSSUJVVEVTX0JJTkRJTkdfTUFQW2F0dHJOYW1lXTtcbiAgICAgIHJldHVybiBiaW5kaW5nTmFtZSAmJiB0aGlzLmJpbmRpbmdIYW5kbGVycy5nZXQoYXR0ck5hbWUpXG4gICAgfVxuXG4gICAgKiBiaW5kaW5nT2JqZWN0cyAobm9kZSwgY29udGV4dCkge1xuICAgICAgZm9yIChjb25zdCBbYXR0ck5hbWUsIHBhcnRzXSBvZiB0aGlzLmJpbmRpbmdQYXJ0cyhub2RlLCBjb250ZXh0KSkge1xuICAgICAgICBjb25zdCBiaW5kaW5nRm9yQXR0cmlidXRlID0gdGhpcy5nZXRQb3NzaWJsZURpcmVjdEJpbmRpbmcoYXR0ck5hbWUpO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gYmluZGluZ0ZvckF0dHJpYnV0ZSA/IGF0dHJOYW1lIDogYGF0dHIuJHthdHRyTmFtZX1gO1xuICAgICAgICBjb25zdCBhY2Nlc3NvckZuID0gYmluZGluZ0ZvckF0dHJpYnV0ZVxuICAgICAgICAgID8gKC4uLnYpID0+IHRoaXMucGFydHNUb2dldGhlcihwYXJ0cywgY29udGV4dCwgbm9kZSwgLi4udilcbiAgICAgICAgICA6ICguLi52KSA9PiAoe1thdHRyTmFtZV06IHRoaXMucGFydHNUb2dldGhlcihwYXJ0cywgY29udGV4dCwgbm9kZSwgLi4udil9KTtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICB5aWVsZCB7IFtoYW5kbGVyXTogYWNjZXNzb3JGbiB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldEJpbmRpbmdBY2Nlc3NvcnMgKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAuLi50aGlzLmJpbmRpbmdPYmplY3RzKG5vZGUsIGNvbnRleHQpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcnByZXQge3sgfX0sIHt7eyB9fX0sIHt7IyAvfX0sIGFuZCB7eyMgfX0gLi4uIHt7LyB9fSBpbnNpZGUgdGV4dCBub2Rlcy5cbiAgICpcbiAgICogVGhpcyBiaW5kaW5nIG11c3QgY29tZSBiZWZvcmUgdGhlIFZpcnR1YWxQcm92aWRlci5cbiAgICovXG4gIGNsYXNzIFRleHRNdXN0YWNoZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXIge1xuICAgIGdldCBGT1JfTk9ERV9UWVBFUyAoKSB7IHJldHVybiBbIDMgXSB9IC8vIGRvY3VtZW50LlRFWFRfTk9ERVxuXG4gICAgKiB0ZXh0VG9Ob2RlcyAodGV4dE5vZGUpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRleHROb2RlLnBhcmVudE5vZGU7XG4gICAgICBjb25zdCBpc1RleHRhcmVhID0gcGFyZW50ICYmIHBhcmVudC5ub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJztcbiAgICAgIGNvbnN0IGhhc1N0YXNoID0gdGV4dE5vZGUubm9kZVZhbHVlICYmIHRleHROb2RlLm5vZGVWYWx1ZS5pbmNsdWRlcygne3snKTtcblxuICAgICAgaWYgKCFoYXNTdGFzaCB8fCBpc1RleHRhcmVhKSB7IHJldHVybiB9XG5cbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZUludGVycG9sYXRpb24odGV4dE5vZGUubm9kZVZhbHVlKSkge1xuICAgICAgICB5aWVsZCAqIHBhcnQudGV4dE5vZGVSZXBsYWNlbWVudCh0ZXh0Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGV4dEludGVycG9sYXRpb24gKHRleHROb2RlKSB7XG4gICAgICBjb25zdCBuZXdOb2RlcyA9IEFycmF5LmZyb20odGhpcy50ZXh0VG9Ob2Rlcyh0ZXh0Tm9kZSkpO1xuXG4gICAgICBpZiAobmV3Tm9kZXMubGVuZ3RoID09PSAwKSB7IHJldHVybiB9XG5cbiAgICAgIGlmICh0ZXh0Tm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRleHROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGNvbnN0IG4gPSBuZXdOb2Rlcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShuZXdOb2Rlc1tpXSwgdGV4dE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdOb2Rlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIGNvbnZlcnQgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqICAge3sjIC4uLiB9fSBpbnRvIDwhLS0ga28gLi4uIC0tPlxuICAgICAqICAge3svIC4uLiB9fSBpbnRvIDwhLS0gL2tvIC0tPlxuICAgICAqICAge3sjIC4uLiAvfX0gaW50byA8IS0tIGtvIC4uLiAtLT48IS0tIC9rbyAtLT5cbiAgICAgKiAgIHt7IC4uLiB9fSBpbnRvIDwhLS0ga28gdGV4dDogLi4uIC0tPjwhLS0gL2tvIC0tPlxuICAgICAqICAge3t7IC4uLiB9fX0gaW50byA8IS0tIGtvIGh0bWw6IC4uLiAtLT48IS0tIC9rbyAtLT5cbiAgICAgKlxuICAgICAqIFZpcnR1YWxQcm92aWRlciBjYW4gdGhlbiBwaWNrIHVwIGFuZCBkbyB0aGUgYWN0dWFsIGJpbmRpbmcuXG4gICAgICovXG4gICAgcHJlcHJvY2Vzc05vZGUgKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHRJbnRlcnBvbGF0aW9uKG5vZGUpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgTkFUSVZFX0JJTkRJTkdTID0gU3ltYm9sKCdLbm9ja291dCBuYXRpdmUgYmluZGluZ3MnKTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGJpbmRpbmcgYWNjZXNzb3JzIHRoYXQgYXJlIGFscmVhZHkgYXR0YWNoZWQgdG9cbiAgICogYSBub2RlIHVuZGVyIHRoZSBgTkFUSVZFX0JJTkRJTkdTYCBzeW1ib2wuXG4gICAqXG4gICAqIFVzZWQgYnkgdGhlIGpzeFRvTm9kZSBmdW5jdGlvbi5cbiAgICovXG4gIGNsYXNzIE5hdGl2ZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXIge1xuICAgIGdldCBGT1JfTk9ERV9UWVBFUyAoKSB7IHJldHVybiBbIDEsIDMgXSB9XG4gICAgZ2V0IHByZWVtcHRpdmUgKCkgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgICBub2RlSGFzQmluZGluZ3MgKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZVtOQVRJVkVfQklORElOR1NdKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMobm9kZVtOQVRJVkVfQklORElOR1NdIHx8IHt9KVxuICAgICAgICAuc29tZShrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2tvLScpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZXJlIGNhbiBiZSBvbmx5IG9uZSBwcmVwcm9jZXNzb3I7IHdoZW4gdGhlcmUgYXJlIG5hdGl2ZSBiaW5kaW5ncyxcbiAgICAgKiBwcmV2ZW50IHJlLWVudHJhbmNlIChhbmQgbGlrZWx5IFhTUykgZnJvbSB0aGUgYHt7IH19YCBwcm92aWRlci5cbiAgICAgKi9cbiAgICBwcmVwcm9jZXNzTm9kZSAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGVbTkFUSVZFX0JJTkRJTkdTXSA/IG5vZGUgOiBudWxsXG4gICAgfVxuXG4gICAgb25seUJpbmRpbmdzIChbbmFtZV0pIHtcbiAgICAgIHJldHVybiBuYW1lLnN0YXJ0c1dpdGgoJ2tvLScpXG4gICAgfVxuXG4gICAgdmFsdWVBc0FjY2Vzc29yIChbbmFtZSwgdmFsdWVdKSB7XG4gICAgICBjb25zdCBiaW5kaW5nTmFtZSA9IG5hbWUucmVwbGFjZSgvXmtvLS8sICcnKTtcbiAgICAgIGNvbnN0IHZhbHVlRm4gPSBpc09ic2VydmFibGUodmFsdWUpID8gdmFsdWUgOiAoKSA9PiB2YWx1ZTtcbiAgICAgIHJldHVybiB7W2JpbmRpbmdOYW1lXTogdmFsdWVGbn1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYXMgdmFsdWVBY2Nlc3NvciBmdW5jdGlvbiBhbGwgdGhlIGVudHJpZXMgbWF0Y2hpbmcgYGtvLSpgXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgICAqL1xuICAgIGdldEJpbmRpbmdBY2Nlc3NvcnMgKG5vZGUpIHtcbiAgICAgIGNvbnN0IGJpbmRpbmdzID0gT2JqZWN0LmVudHJpZXMobm9kZVtOQVRJVkVfQklORElOR1NdIHx8IHt9KVxuICAgICAgICAuZmlsdGVyKHRoaXMub25seUJpbmRpbmdzKTtcbiAgICAgIGlmICghYmluZGluZ3MubGVuZ3RoKSB7IHJldHVybiBudWxsIH1cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAuLi5iaW5kaW5ncy5tYXAodGhpcy52YWx1ZUFzQWNjZXNzb3IpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5hbWVkLXZhbHVlIHRvIHRoZSBnaXZlbiBub2RlLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWYWx1ZVRvTm9kZSAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IG9iaiA9IG5vZGVbTkFUSVZFX0JJTkRJTkdTXSB8fCAobm9kZVtOQVRJVkVfQklORElOR1NdID0ge30pO1xuICAgICAgb2JqW25hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICogQHJldHVybiB7b2JqZWN0fSB0aGUgc3RvcmVkIHZhbHVlc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXROb2RlVmFsdWVzIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZVtOQVRJVkVfQklORElOR1NdXG4gICAgfVxuICB9XG5cbiAgdmFyIGF0dHIgPSB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHVud3JhcCh2YWx1ZUFjY2Vzc29yKCkpIHx8IHt9O1xuICAgICAgb2JqZWN0Rm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKGF0dHJOYW1lLCBhdHRyVmFsdWUpIHtcbiAgICAgICAgYXR0clZhbHVlID0gdW53cmFwKGF0dHJWYWx1ZSk7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgbmFtZXNwYWNlIG9mIHRoaXMgYXR0cmlidXRlLCBpZiBhbnkuXG4gICAgICAgIHZhciBwcmVmaXhMZW4gPSBhdHRyTmFtZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcmVmaXhMZW4gPiAwICYmIGVsZW1lbnQubG9va3VwTmFtZXNwYWNlVVJJKGF0dHJOYW1lLnN1YnN0cigwLCBwcmVmaXhMZW4pKTtcblxuICAgICAgICAvLyBUbyBjb3ZlciBjYXNlcyBsaWtlIFwiYXR0cjogeyBjaGVja2VkOnNvbWVQcm9wIH1cIiwgd2Ugd2FudCB0byByZW1vdmUgdGhlIGF0dHJpYnV0ZSBlbnRpcmVseVxuICAgICAgICAvLyB3aGVuIHNvbWVQcm9wIGlzIGEgXCJubyB2YWx1ZVwiLWxpa2UgdmFsdWUgKHN0cmljdGx5IG51bGwsIGZhbHNlLCBvciB1bmRlZmluZWQpXG4gICAgICAgIC8vIChiZWNhdXNlIHRoZSBhYnNlbmNlIG9mIHRoZSBcImNoZWNrZWRcIiBhdHRyIGlzIGhvdyB0byBtYXJrIGFuIGVsZW1lbnQgYXMgbm90IGNoZWNrZWQsIGV0Yy4pXG4gICAgICAgIGNvbnN0IHRvUmVtb3ZlID0gYXR0clZhbHVlID09PSBmYWxzZSB8fCBhdHRyVmFsdWUgPT09IG51bGwgfHwgYXR0clZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHRvUmVtb3ZlKSB7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHJOYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyVmFsdWUgPSBhdHRyVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyZWF0IFwibmFtZVwiIHNwZWNpYWxseSAtIGFsdGhvdWdoIHlvdSBjYW4gdGhpbmsgb2YgaXQgYXMgYW4gYXR0cmlidXRlLCBpdCBhbHNvIG5lZWRzXG4gICAgICAgIC8vIHNwZWNpYWwgaGFuZGxpbmcgb24gb2xkZXIgdmVyc2lvbnMgb2YgSUUgKGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9wdWxsLzMzMylcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGJlaW5nIGNhc2Utc2Vuc2l0aXZlIGhlcmUgYmVjYXVzZSBYSFRNTCB3b3VsZCByZWdhcmQgXCJOYW1lXCIgYXMgYSBkaWZmZXJlbnQgdGhpbmdcbiAgICAgICAgLy8gZW50aXJlbHksIGFuZCB0aGVyZSdzIG5vIHN0cm9uZyByZWFzb24gdG8gYWxsb3cgZm9yIHN1Y2ggY2FzaW5nIGluIEhUTUwuXG4gICAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ25hbWUnKSB7XG4gICAgICAgICAgc2V0RWxlbWVudE5hbWUoZWxlbWVudCwgdG9SZW1vdmUgPyAnJyA6IGF0dHJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY2hlY2tlZCA9IHtcbiAgICBhZnRlcjogWyd2YWx1ZScsICdhdHRyJ10sXG4gICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzKSB7XG4gICAgICB2YXIgY2hlY2tlZFZhbHVlID0gcHVyZUNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVHJlYXQgXCJ2YWx1ZVwiIGxpa2UgXCJjaGVja2VkVmFsdWVcIiB3aGVuIGl0IGlzIGluY2x1ZGVkIHdpdGggXCJjaGVja2VkXCIgYmluZGluZ1xuICAgICAgICBpZiAoYWxsQmluZGluZ3MuaGFzKCdjaGVja2VkVmFsdWUnKSkge1xuICAgICAgICAgIHJldHVybiB1bndyYXAoYWxsQmluZGluZ3MuZ2V0KCdjaGVja2VkVmFsdWUnKSlcbiAgICAgICAgfSBlbHNlIGlmICh1c2VFbGVtZW50VmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxsQmluZGluZ3MuaGFzKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW53cmFwKGFsbEJpbmRpbmdzLmdldCgndmFsdWUnKSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQudmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiB1cGRhdGVNb2RlbCAoKSB7XG4gICAgICAgIC8vIFRoaXMgdXBkYXRlcyB0aGUgbW9kZWwgdmFsdWUgZnJvbSB0aGUgdmlldyB2YWx1ZS5cbiAgICAgICAgLy8gSXQgcnVucyBpbiByZXNwb25zZSB0byBET00gZXZlbnRzIChjbGljaykgYW5kIGNoYW5nZXMgaW4gY2hlY2tlZFZhbHVlLlxuICAgICAgICB2YXIgaXNDaGVja2VkID0gZWxlbWVudC5jaGVja2VkLFxuICAgICAgICAgIGVsZW1WYWx1ZSA9IGNoZWNrZWRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIFdoZW4gd2UncmUgZmlyc3Qgc2V0dGluZyB1cCB0aGlzIGNvbXB1dGVkLCBkb24ndCBjaGFuZ2UgYW55IG1vZGVsIHN0YXRlLlxuICAgICAgICBpZiAoaXNJbml0aWFsKCkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGNhbiBpZ25vcmUgdW5jaGVja2VkIHJhZGlvIGJ1dHRvbnMsIGJlY2F1c2Ugc29tZSBvdGhlciByYWRpb1xuICAgICAgICAvLyBidXR0b24gd2lsbCBiZSBjaGVja2VkLCBhbmQgdGhhdCBvbmUgY2FuIHRha2UgY2FyZSBvZiB1cGRhdGluZyBzdGF0ZS5cbiAgICAgICAgLy8gYnV0dG9uIHdpbGwgYmUgY2hlY2tlZCwgYW5kIHRoYXQgb25lIGNhbiB0YWtlIGNhcmUgb2YgdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgaWYgKCFpc0NoZWNrZWQgJiYgKGlzUmFkaW8gfHwgZ2V0RGVwZW5kZW5jaWVzQ291bnQoKSkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb2RlbFZhbHVlID0gaWdub3JlKHZhbHVlQWNjZXNzb3IpO1xuICAgICAgICBpZiAodmFsdWVJc0FycmF5KSB7XG4gICAgICAgICAgdmFyIHdyaXRhYmxlVmFsdWUgPSByYXdWYWx1ZUlzTm9uQXJyYXlPYnNlcnZhYmxlID8gbW9kZWxWYWx1ZS5wZWVrKCkgOiBtb2RlbFZhbHVlLFxuICAgICAgICAgICAgc2F2ZU9sZFZhbHVlID0gb2xkRWxlbVZhbHVlO1xuICAgICAgICAgIG9sZEVsZW1WYWx1ZSA9IGVsZW1WYWx1ZTtcblxuICAgICAgICAgIGlmIChzYXZlT2xkVmFsdWUgIT09IGVsZW1WYWx1ZSkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSdyZSByZXNwb25kaW5nIHRvIHRoZSBjaGVja2VkVmFsdWUgY2hhbmdpbmcsIGFuZCB0aGUgZWxlbWVudCBpc1xuICAgICAgICAgICAgLy8gY3VycmVudGx5IGNoZWNrZWQsIHJlcGxhY2UgdGhlIG9sZCBlbGVtIHZhbHVlIHdpdGggdGhlIG5ldyBlbGVtIHZhbHVlXG4gICAgICAgICAgICAvLyBpbiB0aGUgbW9kZWwgYXJyYXkuXG4gICAgICAgICAgICBpZiAoaXNDaGVja2VkKSB7XG4gICAgICAgICAgICAgIGFkZE9yUmVtb3ZlSXRlbSh3cml0YWJsZVZhbHVlLCBlbGVtVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICBhZGRPclJlbW92ZUl0ZW0od3JpdGFibGVWYWx1ZSwgc2F2ZU9sZFZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9sZEVsZW1WYWx1ZSA9IGVsZW1WYWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSdyZSByZXNwb25kaW5nIHRvIHRoZSB1c2VyIGhhdmluZyBjaGVja2VkL3VuY2hlY2tlZCBhIGNoZWNrYm94LFxuICAgICAgICAgICAgLy8gYWRkL3JlbW92ZSB0aGUgZWxlbWVudCB2YWx1ZSB0byB0aGUgbW9kZWwgYXJyYXkuXG4gICAgICAgICAgICBhZGRPclJlbW92ZUl0ZW0od3JpdGFibGVWYWx1ZSwgZWxlbVZhbHVlLCBpc0NoZWNrZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmF3VmFsdWVJc05vbkFycmF5T2JzZXJ2YWJsZSAmJiBpc1dyaXRlYWJsZU9ic2VydmFibGUobW9kZWxWYWx1ZSkpIHtcbiAgICAgICAgICAgIG1vZGVsVmFsdWUod3JpdGFibGVWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0NoZWNrYm94KSB7XG4gICAgICAgICAgICBpZiAoZWxlbVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZWxlbVZhbHVlID0gaXNDaGVja2VkO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNDaGVja2VkKSB7XG4gICAgICAgICAgICAgIGVsZW1WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWVBY2Nlc3NvcihlbGVtVmFsdWUsIHtvbmx5SWZDaGFuZ2VkOiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVZpZXcgKCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZXMgdGhlIHZpZXcgdmFsdWUgZnJvbSB0aGUgbW9kZWwgdmFsdWUuXG4gICAgICAgICAgICAgIC8vIEl0IHJ1bnMgaW4gcmVzcG9uc2UgdG8gY2hhbmdlcyBpbiB0aGUgYm91bmQgKGNoZWNrZWQpIHZhbHVlLlxuICAgICAgICB2YXIgbW9kZWxWYWx1ZSA9IG1vZGVsVmFsdWUgPSB1bndyYXAodmFsdWVBY2Nlc3NvcigpKTtcbiAgICAgICAgdmFyIGVsZW1WYWx1ZSA9IGNoZWNrZWRWYWx1ZSgpO1xuXG4gICAgICAgIGlmICh2YWx1ZUlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdoZW4gYSBjaGVja2JveCBpcyBib3VuZCB0byBhbiBhcnJheSwgYmVpbmcgY2hlY2tlZCByZXByZXNlbnRzIGl0cyB2YWx1ZSBiZWluZyBwcmVzZW50IGluIHRoYXQgYXJyYXlcbiAgICAgICAgICBlbGVtZW50LmNoZWNrZWQgPSBhcnJheUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbVZhbHVlKSA+PSAwO1xuICAgICAgICAgIG9sZEVsZW1WYWx1ZSA9IGVsZW1WYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0NoZWNrYm94ICYmIGVsZW1WYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gYSBjaGVja2JveCBpcyBib3VuZCB0byBhbnkgb3RoZXIgdmFsdWUgKG5vdCBhbiBhcnJheSkgYW5kIFwiY2hlY2tlZFZhbHVlXCIgaXMgbm90IGRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlaW5nIGNoZWNrZWQgcmVwcmVzZW50cyB0aGUgdmFsdWUgYmVpbmcgdHJ1ZWlzaFxuICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9ICEhbW9kZWxWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGJlaW5nIGNoZWNrZWQgbWVhbnMgdGhhdCB0aGUgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uJ3MgdmFsdWUgY29ycmVzcG9uZHMgdG8gdGhlIG1vZGVsIHZhbHVlXG4gICAgICAgICAgZWxlbWVudC5jaGVja2VkID0gKGNoZWNrZWRWYWx1ZSgpID09PSBtb2RlbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGlzQ2hlY2tib3ggPSBlbGVtZW50LnR5cGUgPT0gJ2NoZWNrYm94JyxcbiAgICAgICAgaXNSYWRpbyA9IGVsZW1lbnQudHlwZSA9PSAncmFkaW8nO1xuXG4gICAgICAgICAgLy8gT25seSBiaW5kIHRvIGNoZWNrIGJveGVzIGFuZCByYWRpbyBidXR0b25zXG4gICAgICBpZiAoIWlzQ2hlY2tib3ggJiYgIWlzUmFkaW8pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciByYXdWYWx1ZSA9IHZhbHVlQWNjZXNzb3IoKSxcbiAgICAgICAgdmFsdWVJc0FycmF5ID0gaXNDaGVja2JveCAmJiAodW53cmFwKHJhd1ZhbHVlKSBpbnN0YW5jZW9mIEFycmF5KSxcbiAgICAgICAgcmF3VmFsdWVJc05vbkFycmF5T2JzZXJ2YWJsZSA9ICEodmFsdWVJc0FycmF5ICYmIHJhd1ZhbHVlLnB1c2ggJiYgcmF3VmFsdWUuc3BsaWNlKSxcbiAgICAgICAgdXNlRWxlbWVudFZhbHVlID0gaXNSYWRpbyB8fCB2YWx1ZUlzQXJyYXksXG4gICAgICAgIG9sZEVsZW1WYWx1ZSA9IHZhbHVlSXNBcnJheSA/IGNoZWNrZWRWYWx1ZSgpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgLy8gU2V0IHVwIHR3byBjb21wdXRlZHMgdG8gdXBkYXRlIHRoZSBiaW5kaW5nOlxuXG4gICAgICAgICAgLy8gVGhlIGZpcnN0IHJlc3BvbmRzIHRvIGNoYW5nZXMgaW4gdGhlIGNoZWNrZWRWYWx1ZSB2YWx1ZSBhbmQgdG8gZWxlbWVudCBjbGlja3NcbiAgICAgIGNvbXB1dGVkKHVwZGF0ZU1vZGVsLCBudWxsLCB7IGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbWVudCB9KTtcbiAgICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsICdjbGljaycsIHVwZGF0ZU1vZGVsKTtcblxuICAgICAgICAgIC8vIFRoZSBzZWNvbmQgcmVzcG9uZHMgdG8gY2hhbmdlcyBpbiB0aGUgbW9kZWwgdmFsdWUgKHRoZSBvbmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGVja2VkIGJpbmRpbmcpXG4gICAgICBjb21wdXRlZCh1cGRhdGVWaWV3LCBudWxsLCB7IGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbWVudCB9KTtcblxuICAgICAgcmF3VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjaGVja2VkVmFsdWUgPSB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgZWxlbWVudC52YWx1ZSA9IHVud3JhcCh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBGb3IgY2VydGFpbiBjb21tb24gZXZlbnRzIChjdXJyZW50bHkganVzdCAnY2xpY2snKSwgYWxsb3cgYSBzaW1wbGlmaWVkIGRhdGEtYmluZGluZyBzeW50YXhcbiAgLy8gZS5nLiBjbGljazpoYW5kbGVyIGluc3RlYWQgb2YgdGhlIHVzdWFsIGZ1bGwtbGVuZ3RoIGV2ZW50OntjbGljazpoYW5kbGVyfVxuICBmdW5jdGlvbiBtYWtlRXZlbnRIYW5kbGVyU2hvcnRjdXQgKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlQWNjZXNzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgIHJlc3VsdFtldmVudE5hbWVdID0gdmFsdWVBY2Nlc3NvcigpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnRIYW5kbGVyLmluaXQuY2FsbCh0aGlzLCBlbGVtZW50LCBuZXdWYWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZURlc2NyaXB0b3IgKGhhbmRsZXJPck9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2YgaGFuZGxlck9yT2JqZWN0ID09PSAnZnVuY3Rpb24nID8geyBoYW5kbGVyOiBoYW5kbGVyT3JPYmplY3QgfSA6IGhhbmRsZXJPck9iamVjdCB8fCB7fVxuICB9XG5cbiAgY29uc3QgZXZlbnRIYW5kbGVyID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgdmFyIGV2ZW50c1RvSGFuZGxlID0gdmFsdWVBY2Nlc3NvcigpIHx8IHt9O1xuICAgICAgb2JqZWN0Rm9yRWFjaChldmVudHNUb0hhbmRsZSwgZnVuY3Rpb24gKGV2ZW50TmFtZSwgZGVzY3JpcHRvcikge1xuICAgICAgICBjb25zdCB7cGFzc2l2ZSwgY2FwdHVyZSwgb25jZSwgZGVib3VuY2U6IGRlYm91bmNlJCQxLCB0aHJvdHRsZTogdGhyb3R0bGUkJDF9ID0gbWFrZURlc2NyaXB0b3IoZGVzY3JpcHRvcik7XG4gICAgICAgIGNvbnN0IGV2ZW50T3B0aW9ucyA9IChjYXB0dXJlIHx8IHBhc3NpdmUgfHwgb25jZSkgJiYge2NhcHR1cmUsIHBhc3NpdmUsIG9uY2V9O1xuXG4gICAgICAgIGxldCBldmVudEhhbmRsZXJGbiA9IChldmVudCwgLi4ubW9yZSkgPT4ge1xuICAgICAgICAgIHZhciBoYW5kbGVyUmV0dXJuVmFsdWU7XG4gICAgICAgICAgY29uc3Qge2hhbmRsZXIsIHBhc3NpdmUsIGJ1YmJsZX0gPSBtYWtlRGVzY3JpcHRvcih2YWx1ZUFjY2Vzc29yKClbZXZlbnROYW1lXSk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVGFrZSBhbGwgdGhlIGV2ZW50IGFyZ3MsIGFuZCBwcmVmaXggd2l0aCB0aGUgdmlld21vZGVsXG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICBjb25zdCBwb3NzaWJseVVwZGF0ZWRWaWV3TW9kZWwgPSBiaW5kaW5nQ29udGV4dC4kZGF0YTtcbiAgICAgICAgICAgICAgY29uc3QgYXJnc0ZvckhhbmRsZXIgPSBbcG9zc2libHlVcGRhdGVkVmlld01vZGVsLCBldmVudCwgLi4ubW9yZV07XG4gICAgICAgICAgICAgIGhhbmRsZXJSZXR1cm5WYWx1ZSA9IGhhbmRsZXIuYXBwbHkocG9zc2libHlVcGRhdGVkVmlld01vZGVsLCBhcmdzRm9ySGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyUmV0dXJuVmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgLy8gTm9ybWFsbHkgd2Ugd2FudCB0byBwcmV2ZW50IGRlZmF1bHQgYWN0aW9uLiBEZXZlbG9wZXIgY2FuIG92ZXJyaWRlIHRoaXMgYmUgZXhwbGljaXRseSByZXR1cm5pbmcgdHJ1ZS5cbiAgICAgICAgICAgICAgLy8gcHJldmVudERlZmF1bHQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZXZlbnQgaXMgcGFzc2l2ZS5cbiAgICAgICAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXNzaXZlKSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYnViYmxlTWFyayA9IGFsbEJpbmRpbmdzLmdldChldmVudE5hbWUgKyAnQnViYmxlJykgIT09IGZhbHNlO1xuICAgICAgICAgIGlmIChidWJibGUgPT09IGZhbHNlIHx8ICFidWJibGVNYXJrKSB7XG4gICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikgeyBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZGVib3VuY2UkJDEpIHsgZXZlbnRIYW5kbGVyRm4gPSBkZWJvdW5jZShldmVudEhhbmRsZXJGbiwgZGVib3VuY2UkJDEpOyB9XG4gICAgICAgIGlmICh0aHJvdHRsZSQkMSkgeyBldmVudEhhbmRsZXJGbiA9IHRocm90dGxlKGV2ZW50SGFuZGxlckZuLCB0aHJvdHRsZSQkMSk7IH1cblxuICAgICAgICByZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCBldmVudE5hbWUsIGV2ZW50SGFuZGxlckZuLCBldmVudE9wdGlvbnMgfHwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uSGFuZGxlciA9IHtcbiAgICBpbml0OiBldmVudEhhbmRsZXIuaW5pdCxcbiAgICBwcmVwcm9jZXNzOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgYWRkQmluZGluZykge1xuICAgICAgYWRkQmluZGluZyhrZXkucmVwbGFjZSgnb24uJywgJycpLCAnPT4nICsgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvLyAnY2xpY2snIGlzIGp1c3QgYSBzaG9ydGhhbmQgZm9yIHRoZSB1c3VhbCBmdWxsLWxlbmd0aCBldmVudDp7Y2xpY2s6aGFuZGxlcn1cbiAgdmFyIGNsaWNrID0gbWFrZUV2ZW50SGFuZGxlclNob3J0Y3V0KCdjbGljaycpO1xuXG4gIHZhciBjc3MgPSB7XG4gICAgYWxpYXNlczogWydjbGFzcyddLFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHVud3JhcCh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb2JqZWN0Rm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKGNsYXNzTmFtZSwgc2hvdWxkSGF2ZUNsYXNzKSB7XG4gICAgICAgICAgc2hvdWxkSGF2ZUNsYXNzID0gdW53cmFwKHNob3VsZEhhdmVDbGFzcyk7XG4gICAgICAgICAgdG9nZ2xlRG9tTm9kZUNzc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgc2hvdWxkSGF2ZUNsYXNzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHN0cmluZ1RyaW0oU3RyaW5nKHZhbHVlIHx8ICcnKSk7IC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCB0cnkgdG8gc3RvcmUgb3Igc2V0IGEgbm9uLXN0cmluZyB2YWx1ZVxuICAgICAgICB0b2dnbGVEb21Ob2RlQ3NzQ2xhc3MoZWxlbWVudCwgZWxlbWVudFtjc3MuY2xhc3Nlc1dyaXR0ZW5CeUJpbmRpbmdLZXldLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnRbY3NzLmNsYXNzZXNXcml0dGVuQnlCaW5kaW5nS2V5XSA9IHZhbHVlO1xuICAgICAgICB0b2dnbGVEb21Ob2RlQ3NzQ2xhc3MoZWxlbWVudCwgdmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xhc3Nlc1dyaXR0ZW5CeUJpbmRpbmdLZXk6IGNyZWF0ZVN5bWJvbE9yU3RyaW5nKCdfX2tvX19jc3NWYWx1ZScpXG4gIH07XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxlIGNhbGxiYWNrIGJpbmRpbmcuXG4gICAqL1xuXG4gIGNsYXNzIERlc2NlbmRhbnRzQ29tcGxldGVIYW5kbGVyIGV4dGVuZHMgQmluZGluZ0hhbmRsZXIge1xuICAgIG9uRGVzY2VuZGFudHNDb21wbGV0ZSAoKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy52YWx1ZSh0aGlzLiRlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IGFsbG93VmlydHVhbEVsZW1lbnRzICgpIHsgcmV0dXJuIHRydWUgfVxuICB9XG5cbiAgdmFyIGVuYWJsZSA9IHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICB2YXIgdmFsdWUgPSB1bndyYXAodmFsdWVBY2Nlc3NvcigpKTtcbiAgICAgIGlmICh2YWx1ZSAmJiBlbGVtZW50LmRpc2FibGVkKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgfSBlbHNlIGlmICgoIXZhbHVlKSAmJiAoIWVsZW1lbnQuZGlzYWJsZWQpKSB7XG4gICAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZGlzYWJsZSA9IHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICBlbmFibGUudXBkYXRlKGVsZW1lbnQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICF1bndyYXAodmFsdWVBY2Nlc3NvcigpKSB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhc2ZvY3VzVXBkYXRpbmdQcm9wZXJ0eSA9IGNyZWF0ZVN5bWJvbE9yU3RyaW5nKCdfX2tvX2hhc2ZvY3VzVXBkYXRpbmcnKTtcbiAgdmFyIGhhc2ZvY3VzTGFzdFZhbHVlID0gY3JlYXRlU3ltYm9sT3JTdHJpbmcoJ19fa29faGFzZm9jdXNMYXN0VmFsdWUnKTtcblxuICB2YXIgaGFzZm9jdXMgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IgLyosIGFsbEJpbmRpbmdzICovKSB7XG4gICAgICB2YXIgaGFuZGxlRWxlbWVudEZvY3VzQ2hhbmdlID0gZnVuY3Rpb24gKGlzRm9jdXNlZCkge1xuICAgICAgICAgICAgICAvLyBXaGVyZSBwb3NzaWJsZSwgaWdub3JlIHdoaWNoIGV2ZW50IHdhcyByYWlzZWQgYW5kIGRldGVybWluZSBmb2N1cyBzdGF0ZSB1c2luZyBhY3RpdmVFbGVtZW50LFxuICAgICAgICAgICAgICAvLyBhcyB0aGlzIGF2b2lkcyBwaGFudG9tIGZvY3VzL2JsdXIgZXZlbnRzIHJhaXNlZCB3aGVuIGNoYW5naW5nIHRhYnMgaW4gbW9kZXJuIGJyb3dzZXJzLlxuICAgICAgICAgICAgICAvLyBIb3dldmVyLCBub3QgYWxsIEtPLXRhcmdldGVkIGJyb3dzZXJzIChGaXJlZm94IDIpIHN1cHBvcnQgYWN0aXZlRWxlbWVudC4gRm9yIHRob3NlIGJyb3dzZXJzLFxuICAgICAgICAgICAgICAvLyBwcmV2ZW50IGEgbG9zcyBvZiBmb2N1cyB3aGVuIGNoYW5naW5nIHRhYnMvd2luZG93cyBieSBzZXR0aW5nIGEgZmxhZyB0aGF0IHByZXZlbnRzIGhhc2ZvY3VzXG4gICAgICAgICAgICAgIC8vIGZyb20gY2FsbGluZyAnYmx1cigpJyBvbiB0aGUgZWxlbWVudCB3aGVuIGl0IGxvc2VzIGZvY3VzLlxuICAgICAgICAgICAgICAvLyBEaXNjdXNzaW9uIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9wdWxsLzM1MlxuICAgICAgICBlbGVtZW50W2hhc2ZvY3VzVXBkYXRpbmdQcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICB2YXIgb3duZXJEb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGlmICgnYWN0aXZlRWxlbWVudCcgaW4gb3duZXJEb2MpIHtcbiAgICAgICAgICB2YXIgYWN0aXZlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhY3RpdmUgPSBvd25lckRvYy5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJRTkgdGhyb3dzIGlmIHlvdSBhY2Nlc3MgYWN0aXZlRWxlbWVudCBkdXJpbmcgcGFnZSBsb2FkIChzZWUgaXNzdWUgIzcwMylcbiAgICAgICAgICAgIGFjdGl2ZSA9IG93bmVyRG9jLmJvZHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzRm9jdXNlZCA9IChhY3RpdmUgPT09IGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHZhciBtb2RlbFZhbHVlID0gdmFsdWVBY2Nlc3NvcigpO1xuICAgICAgICB2YWx1ZUFjY2Vzc29yKGlzRm9jdXNlZCwge29ubHlJZkNoYW5nZWQ6IHRydWV9KTtcblxuICAgICAgICAgICAgICAvLyBjYWNoZSB0aGUgbGF0ZXN0IHZhbHVlLCBzbyB3ZSBjYW4gYXZvaWQgdW5uZWNlc3NhcmlseSBjYWxsaW5nIGZvY3VzL2JsdXIgaW4gdGhlIHVwZGF0ZSBmdW5jdGlvblxuICAgICAgICBlbGVtZW50W2hhc2ZvY3VzTGFzdFZhbHVlXSA9IGlzRm9jdXNlZDtcbiAgICAgICAgZWxlbWVudFtoYXNmb2N1c1VwZGF0aW5nUHJvcGVydHldID0gZmFsc2U7XG4gICAgICB9O1xuICAgICAgdmFyIGhhbmRsZUVsZW1lbnRGb2N1c0luID0gaGFuZGxlRWxlbWVudEZvY3VzQ2hhbmdlLmJpbmQobnVsbCwgdHJ1ZSk7XG4gICAgICB2YXIgaGFuZGxlRWxlbWVudEZvY3VzT3V0ID0gaGFuZGxlRWxlbWVudEZvY3VzQ2hhbmdlLmJpbmQobnVsbCwgZmFsc2UpO1xuXG4gICAgICByZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCAnZm9jdXMnLCBoYW5kbGVFbGVtZW50Rm9jdXNJbik7XG4gICAgICByZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCAnZm9jdXNpbicsIGhhbmRsZUVsZW1lbnRGb2N1c0luKTsgLy8gRm9yIElFXG4gICAgICByZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCAnYmx1cicsIGhhbmRsZUVsZW1lbnRGb2N1c091dCk7XG4gICAgICByZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCAnZm9jdXNvdXQnLCBoYW5kbGVFbGVtZW50Rm9jdXNPdXQpOyAvLyBGb3IgSUVcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgIHZhciB2YWx1ZSA9ICEhdW53cmFwKHZhbHVlQWNjZXNzb3IoKSk7XG5cbiAgICAgIGlmICghZWxlbWVudFtoYXNmb2N1c1VwZGF0aW5nUHJvcGVydHldICYmIGVsZW1lbnRbaGFzZm9jdXNMYXN0VmFsdWVdICE9PSB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA/IGVsZW1lbnQuZm9jdXMoKSA6IGVsZW1lbnQuYmx1cigpO1xuXG4gICAgICAgICAgICAgIC8vIEluIElFLCB0aGUgYmx1ciBtZXRob2QgZG9lc24ndCBhbHdheXMgY2F1c2UgdGhlIGVsZW1lbnQgdG8gbG9zZSBmb2N1cyAoZm9yIGV4YW1wbGUsIGlmIHRoZSB3aW5kb3cgaXMgbm90IGluIGZvY3VzKS5cbiAgICAgICAgICAgICAgLy8gU2V0dGluZyBmb2N1cyB0byB0aGUgYm9keSBlbGVtZW50IGRvZXMgc2VlbSB0byBiZSByZWxpYWJsZSBpbiBJRSwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgd2Uga25vdyB0aGF0IHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgd2FzIGZvY3VzZWQgYWxyZWFkeS5cbiAgICAgICAgaWYgKCF2YWx1ZSAmJiBlbGVtZW50W2hhc2ZvY3VzTGFzdFZhbHVlXSkge1xuICAgICAgICAgIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBGb3IgSUUsIHdoaWNoIGRvZXNuJ3QgcmVsaWFibHkgZmlyZSBcImZvY3VzXCIgb3IgXCJibHVyXCIgZXZlbnRzIHN5bmNocm9ub3VzbHlcbiAgICAgICAgaWdub3JlKHRyaWdnZXJFdmVudCwgbnVsbCwgW2VsZW1lbnQsIHZhbHVlID8gJ2ZvY3VzaW4nIDogJ2ZvY3Vzb3V0J10pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaHRtbCA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gUHJldmVudCBiaW5kaW5nIG9uIHRoZSBkeW5hbWljYWxseS1pbmplY3RlZCBIVE1MIChhcyBkZXZlbG9wZXJzIGFyZSB1bmxpa2VseSB0byBleHBlY3QgdGhhdCwgYW5kIGl0IGhhcyBzZWN1cml0eSBpbXBsaWNhdGlvbnMpXG4gICAgICByZXR1cm4ge1xuICAgICAgICAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICAgIC8vXG4gICAgICAvLyBNb2RpZnkgaW50ZXJuYWwsIHBlciBrby5wdW5jaGVzIGFuZCA6XG4gICAgICAvLyAgICAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1MzQ4MTM5XG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgc2V0SHRtbChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKCkpO1xuICAgIH0sXG4gICAgYWxsb3dWaXJ0dWFsRWxlbWVudHM6IHRydWVcbiAgfTtcblxuICB2YXIgJGxldCA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQkJDEpIHtcbiAgICAgICAgICAvLyBNYWtlIGEgbW9kaWZpZWQgYmluZGluZyBjb250ZXh0LCB3aXRoIGV4dHJhIHByb3BlcnRpZXMsIGFuZCBhcHBseSBpdCB0byBkZXNjZW5kYW50IGVsZW1lbnRzXG4gICAgICB2YXIgaW5uZXJDb250ZXh0ID0gYmluZGluZ0NvbnRleHQkJDFbJ2V4dGVuZCddKHZhbHVlQWNjZXNzb3IpO1xuICAgICAgYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHMoaW5uZXJDb250ZXh0LCBlbGVtZW50KTtcblxuICAgICAgcmV0dXJuIHsgJ2NvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzJzogdHJ1ZSB9XG4gICAgfSxcbiAgICBhbGxvd1ZpcnR1YWxFbGVtZW50czogdHJ1ZVxuICB9XG5cbiAgdmFyIGNhcHRpb25QbGFjZWhvbGRlciA9IHt9O1xuXG4gIHZhciBvcHRpb25zJDEgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0YWdOYW1lTG93ZXIoZWxlbWVudCkgIT09ICdzZWxlY3QnKSB7IHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBiaW5kaW5nIGFwcGxpZXMgb25seSB0byBTRUxFQ1QgZWxlbWVudHMnKSB9XG5cbiAgICAgICAgICAvLyBSZW1vdmUgYWxsIGV4aXN0aW5nIDxvcHRpb24+cy5cbiAgICAgIHdoaWxlIChlbGVtZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmUoMCk7XG4gICAgICB9XG5cbiAgICAgICAgICAvLyBFbnN1cmVzIHRoYXQgdGhlIGJpbmRpbmcgcHJvY2Vzc29yIGRvZXNuJ3QgdHJ5IHRvIGJpbmQgdGhlIG9wdGlvbnNcbiAgICAgIHJldHVybiB7ICdjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncyc6IHRydWUgfVxuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MpIHtcbiAgICAgIGZ1bmN0aW9uIHNlbGVjdGVkT3B0aW9ucyAoKSB7XG4gICAgICAgIHJldHVybiBhcnJheUZpbHRlcihlbGVtZW50Lm9wdGlvbnMsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnNlbGVjdGVkIH0pXG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxlY3RXYXNQcmV2aW91c2x5RW1wdHkgPSBlbGVtZW50Lmxlbmd0aCA9PSAwLFxuICAgICAgICBtdWx0aXBsZSA9IGVsZW1lbnQubXVsdGlwbGUsXG4gICAgICAgIHByZXZpb3VzU2Nyb2xsVG9wID0gKCFzZWxlY3RXYXNQcmV2aW91c2x5RW1wdHkgJiYgbXVsdGlwbGUpID8gZWxlbWVudC5zY3JvbGxUb3AgOiBudWxsLFxuICAgICAgICB1bndyYXBwZWRBcnJheSA9IHVud3JhcCh2YWx1ZUFjY2Vzc29yKCkpLFxuICAgICAgICB2YWx1ZUFsbG93VW5zZXQgPSBhbGxCaW5kaW5ncy5nZXQoJ3ZhbHVlQWxsb3dVbnNldCcpICYmIGFsbEJpbmRpbmdzWydoYXMnXSgndmFsdWUnKSxcbiAgICAgICAgaW5jbHVkZURlc3Ryb3llZCA9IGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc0luY2x1ZGVEZXN0cm95ZWQnKSxcbiAgICAgICAgYXJyYXlUb0RvbU5vZGVDaGlsZHJlbk9wdGlvbnMgPSB7fSxcbiAgICAgICAgY2FwdGlvblZhbHVlLFxuICAgICAgICBmaWx0ZXJlZEFycmF5LFxuICAgICAgICBwcmV2aW91c1NlbGVjdGVkVmFsdWVzID0gW107XG5cbiAgICAgIGlmICghdmFsdWVBbGxvd1Vuc2V0KSB7XG4gICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgIHByZXZpb3VzU2VsZWN0ZWRWYWx1ZXMgPSBhcnJheU1hcChzZWxlY3RlZE9wdGlvbnMoKSwgc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgcHJldmlvdXNTZWxlY3RlZFZhbHVlcy5wdXNoKHNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKGVsZW1lbnQub3B0aW9uc1tlbGVtZW50LnNlbGVjdGVkSW5kZXhdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHVud3JhcHBlZEFycmF5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW53cmFwcGVkQXJyYXkubGVuZ3RoID09PSAndW5kZWZpbmVkJykgLy8gQ29lcmNlIHNpbmdsZSB2YWx1ZSBpbnRvIGFycmF5XG4gICAgICAgICAgeyB1bndyYXBwZWRBcnJheSA9IFt1bndyYXBwZWRBcnJheV07IH1cblxuICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFueSBlbnRyaWVzIG1hcmtlZCBhcyBkZXN0cm95ZWRcbiAgICAgICAgZmlsdGVyZWRBcnJheSA9IGFycmF5RmlsdGVyKHVud3JhcHBlZEFycmF5LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlRGVzdHJveWVkIHx8IGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtID09PSBudWxsIHx8ICF1bndyYXAoaXRlbVsnX2Rlc3Ryb3knXSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gSWYgY2FwdGlvbiBpcyBpbmNsdWRlZCwgYWRkIGl0IHRvIHRoZSBhcnJheVxuICAgICAgICBpZiAoYWxsQmluZGluZ3NbJ2hhcyddKCdvcHRpb25zQ2FwdGlvbicpKSB7XG4gICAgICAgICAgY2FwdGlvblZhbHVlID0gdW53cmFwKGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc0NhcHRpb24nKSk7XG4gICAgICAgICAgICAgICAgICAvLyBJZiBjYXB0aW9uIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBkb24ndCBzaG93IGEgY2FwdGlvblxuICAgICAgICAgIGlmIChjYXB0aW9uVmFsdWUgIT09IG51bGwgJiYgY2FwdGlvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkQXJyYXkudW5zaGlmdChjYXB0aW9uUGxhY2Vob2xkZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhcHBseVRvT2JqZWN0IChvYmplY3QsIHByZWRpY2F0ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHZhciBwcmVkaWNhdGVUeXBlID0gdHlwZW9mIHByZWRpY2F0ZTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZVR5cGUgPT0gJ2Z1bmN0aW9uJykgICAgLy8gR2l2ZW4gYSBmdW5jdGlvbjsgcnVuIGl0IGFnYWluc3QgdGhlIGRhdGEgdmFsdWVcbiAgICAgICAgICAgICAgICB7IHJldHVybiBwcmVkaWNhdGUob2JqZWN0KSB9IGVsc2UgaWYgKHByZWRpY2F0ZVR5cGUgPT0gJ3N0cmluZycpIC8vIEdpdmVuIGEgc3RyaW5nOyB0cmVhdCBpdCBhcyBhIHByb3BlcnR5IG5hbWUgb24gdGhlIGRhdGEgdmFsdWVcbiAgICAgICAgICAgICAgICB7IHJldHVybiBvYmplY3RbcHJlZGljYXRlXSB9IGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdpdmVuIG5vIG9wdGlvbnNUZXh0IGFyZzsgdXNlIHRoZSBkYXRhIHZhbHVlIGl0c2VsZlxuICAgICAgICAgICAgICAgICAgeyByZXR1cm4gZGVmYXVsdFZhbHVlIH1cbiAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNhbiBydW4gYXQgdHdvIGRpZmZlcmVudCB0aW1lczpcbiAgICAgICAgICAvLyBUaGUgZmlyc3QgaXMgd2hlbiB0aGUgd2hvbGUgYXJyYXkgaXMgYmVpbmcgdXBkYXRlZCBkaXJlY3RseSBmcm9tIHRoaXMgYmluZGluZyBoYW5kbGVyLlxuICAgICAgICAgIC8vIFRoZSBzZWNvbmQgaXMgd2hlbiBhbiBvYnNlcnZhYmxlIHZhbHVlIGZvciBhIHNwZWNpZmljIGFycmF5IGVudHJ5IGlzIHVwZGF0ZWQuXG4gICAgICAgICAgLy8gb2xkT3B0aW9ucyB3aWxsIGJlIGVtcHR5IGluIHRoZSBmaXJzdCBjYXNlLCBidXQgd2lsbCBiZSBmaWxsZWQgd2l0aCB0aGUgcHJldmlvdXNseSBnZW5lcmF0ZWQgb3B0aW9uIGluIHRoZSBzZWNvbmQuXG4gICAgICB2YXIgaXRlbVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgZnVuY3Rpb24gb3B0aW9uRm9yQXJyYXlJdGVtIChhcnJheUVudHJ5LCBpbmRleCwgb2xkT3B0aW9ucykge1xuICAgICAgICBpZiAob2xkT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBwcmV2aW91c1NlbGVjdGVkVmFsdWVzID0gIXZhbHVlQWxsb3dVbnNldCAmJiBvbGRPcHRpb25zWzBdLnNlbGVjdGVkID8gWyBzZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZShvbGRPcHRpb25zWzBdKSBdIDogW107XG4gICAgICAgICAgaXRlbVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgaWYgKGFycmF5RW50cnkgPT09IGNhcHRpb25QbGFjZWhvbGRlcikge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KG9wdGlvbiwgYWxsQmluZGluZ3MuZ2V0KCdvcHRpb25zQ2FwdGlvbicpKTtcbiAgICAgICAgICBzZWxlY3RFeHRlbnNpb25zLndyaXRlVmFsdWUob3B0aW9uLCB1bmRlZmluZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgYSB2YWx1ZSB0byB0aGUgb3B0aW9uIGVsZW1lbnRcbiAgICAgICAgICB2YXIgb3B0aW9uVmFsdWUgPSBhcHBseVRvT2JqZWN0KGFycmF5RW50cnksIGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc1ZhbHVlJyksIGFycmF5RW50cnkpO1xuICAgICAgICAgIHNlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZShvcHRpb24sIHVud3JhcChvcHRpb25WYWx1ZSkpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBBcHBseSBzb21lIHRleHQgdG8gdGhlIG9wdGlvbiBlbGVtZW50XG4gICAgICAgICAgdmFyIG9wdGlvblRleHQgPSBhcHBseVRvT2JqZWN0KGFycmF5RW50cnksIGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc1RleHQnKSwgb3B0aW9uVmFsdWUpO1xuICAgICAgICAgIHNldFRleHRDb250ZW50KG9wdGlvbiwgb3B0aW9uVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtvcHRpb25dXG4gICAgICB9XG5cbiAgICAgICAgICAvLyBCeSB1c2luZyBhIGJlZm9yZVJlbW92ZSBjYWxsYmFjaywgd2UgZGVsYXkgdGhlIHJlbW92YWwgdW50aWwgYWZ0ZXIgbmV3IGl0ZW1zIGFyZSBhZGRlZC4gVGhpcyBmaXhlcyBhIHNlbGVjdGlvblxuICAgICAgICAgIC8vIHByb2JsZW0gaW4gSUU8PTggYW5kIEZpcmVmb3guIFNlZSBodHRwczovL2dpdGh1Yi5jb20va25vY2tvdXQva25vY2tvdXQvaXNzdWVzLzEyMDhcbiAgICAgIGFycmF5VG9Eb21Ob2RlQ2hpbGRyZW5PcHRpb25zWydiZWZvcmVSZW1vdmUnXSA9XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKG9wdGlvbik7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIHNldFNlbGVjdGlvbkNhbGxiYWNrIChhcnJheUVudHJ5LCBuZXdPcHRpb25zKSB7XG4gICAgICAgIGlmIChpdGVtVXBkYXRlICYmIHZhbHVlQWxsb3dVbnNldCkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vZGVsIHZhbHVlIGlzIGF1dGhvcml0YXRpdmUsIHNvIG1ha2Ugc3VyZSBpdHMgdmFsdWUgaXMgdGhlIG9uZSBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB1c2UgZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUgc2luY2Ugc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZyBkb2VzIHNvIGFscmVhZHkuXG4gICAgICAgICAgc2VsZWN0RXh0ZW5zaW9ucy53cml0ZVZhbHVlKGVsZW1lbnQsIHVud3JhcChhbGxCaW5kaW5ncy5nZXQoJ3ZhbHVlJykpLCB0cnVlIC8qIGFsbG93VW5zZXQgKi8pO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzU2VsZWN0ZWRWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAvLyBJRTYgZG9lc24ndCBsaWtlIHVzIHRvIGFzc2lnbiBzZWxlY3Rpb24gdG8gT1BUSU9OIG5vZGVzIGJlZm9yZSB0aGV5J3JlIGFkZGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAgIC8vIFRoYXQncyB3aHkgd2UgZmlyc3QgYWRkZWQgdGhlbSB3aXRob3V0IHNlbGVjdGlvbi4gTm93IGl0J3MgdGltZSB0byBzZXQgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IGFycmF5SW5kZXhPZihwcmV2aW91c1NlbGVjdGVkVmFsdWVzLCBzZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZShuZXdPcHRpb25zWzBdKSkgPj0gMDtcbiAgICAgICAgICBzZXRPcHRpb25Ob2RlU2VsZWN0aW9uU3RhdGUobmV3T3B0aW9uc1swXSwgaXNTZWxlY3RlZCk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgb3B0aW9uIHdhcyBjaGFuZ2VkIGZyb20gYmVpbmcgc2VsZWN0ZWQgZHVyaW5nIGEgc2luZ2xlLWl0ZW0gdXBkYXRlLCBub3RpZnkgdGhlIGNoYW5nZVxuICAgICAgICAgIGlmIChpdGVtVXBkYXRlICYmICFpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBpZ25vcmUodHJpZ2dlckV2ZW50LCBudWxsLCBbZWxlbWVudCwgJ2NoYW5nZSddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNhbGxiYWNrID0gc2V0U2VsZWN0aW9uQ2FsbGJhY2s7XG4gICAgICBpZiAoYWxsQmluZGluZ3NbJ2hhcyddKCdvcHRpb25zQWZ0ZXJSZW5kZXInKSAmJiB0eXBlb2YgYWxsQmluZGluZ3MuZ2V0KCdvcHRpb25zQWZ0ZXJSZW5kZXInKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIChhcnJheUVudHJ5LCBuZXdPcHRpb25zKSB7XG4gICAgICAgICAgc2V0U2VsZWN0aW9uQ2FsbGJhY2soYXJyYXlFbnRyeSwgbmV3T3B0aW9ucyk7XG4gICAgICAgICAgaWdub3JlKGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc0FmdGVyUmVuZGVyJyksIG51bGwsIFtuZXdPcHRpb25zWzBdLCBhcnJheUVudHJ5ICE9PSBjYXB0aW9uUGxhY2Vob2xkZXIgPyBhcnJheUVudHJ5IDogdW5kZWZpbmVkXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNldERvbU5vZGVDaGlsZHJlbkZyb21BcnJheU1hcHBpbmcoZWxlbWVudCwgZmlsdGVyZWRBcnJheSwgb3B0aW9uRm9yQXJyYXlJdGVtLCBhcnJheVRvRG9tTm9kZUNoaWxkcmVuT3B0aW9ucywgY2FsbGJhY2spO1xuXG4gICAgICBpZ25vcmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodmFsdWVBbGxvd1Vuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgbW9kZWwgdmFsdWUgaXMgYXV0aG9yaXRhdGl2ZSwgc28gbWFrZSBzdXJlIGl0cyB2YWx1ZSBpcyB0aGUgb25lIHNlbGVjdGVkXG4gICAgICAgICAgc2VsZWN0RXh0ZW5zaW9ucy53cml0ZVZhbHVlKGVsZW1lbnQsIHVud3JhcChhbGxCaW5kaW5ncy5nZXQoJ3ZhbHVlJykpLCB0cnVlIC8qIGFsbG93VW5zZXQgKi8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3Rpb24gaGFzIGNoYW5nZWQgYXMgYSByZXN1bHQgb2YgdXBkYXRpbmcgdGhlIG9wdGlvbnMgbGlzdFxuICAgICAgICAgIHZhciBzZWxlY3Rpb25DaGFuZ2VkO1xuICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBhIG11bHRpcGxlLXNlbGVjdCBib3gsIGNvbXBhcmUgdGhlIG5ldyBzZWxlY3Rpb24gY291bnQgdG8gdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBpZiBub3RoaW5nIHdhcyBzZWxlY3RlZCBiZWZvcmUsIHRoZSBzZWxlY3Rpb24gY2FuJ3QgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2VkID0gcHJldmlvdXNTZWxlY3RlZFZhbHVlcy5sZW5ndGggJiYgc2VsZWN0ZWRPcHRpb25zKCkubGVuZ3RoIDwgcHJldmlvdXNTZWxlY3RlZFZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYSBzaW5nbGUtc2VsZWN0IGJveCwgY29tcGFyZSB0aGUgY3VycmVudCB2YWx1ZSB0byB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgaWYgbm90aGluZyB3YXMgc2VsZWN0ZWQgYmVmb3JlIG9yIG5vdGhpbmcgaXMgc2VsZWN0ZWQgbm93LCBqdXN0IGxvb2sgZm9yIGEgY2hhbmdlIGluIHNlbGVjdGlvblxuICAgICAgICAgICAgc2VsZWN0aW9uQ2hhbmdlZCA9IChwcmV2aW91c1NlbGVjdGVkVmFsdWVzLmxlbmd0aCAmJiBlbGVtZW50LnNlbGVjdGVkSW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUoZWxlbWVudC5vcHRpb25zW2VsZW1lbnQuc2VsZWN0ZWRJbmRleF0pICE9PSBwcmV2aW91c1NlbGVjdGVkVmFsdWVzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IChwcmV2aW91c1NlbGVjdGVkVmFsdWVzLmxlbmd0aCB8fCBlbGVtZW50LnNlbGVjdGVkSW5kZXggPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY29uc2lzdGVuY3kgYmV0d2VlbiBtb2RlbCB2YWx1ZSBhbmQgc2VsZWN0ZWQgb3B0aW9uLlxuICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRyb3Bkb3duIHdhcyBjaGFuZ2VkIHNvIHRoYXQgc2VsZWN0aW9uIGlzIG5vIGxvbmdlciB0aGUgc2FtZSxcbiAgICAgICAgICAgICAgICAgIC8vIG5vdGlmeSB0aGUgdmFsdWUgb3Igc2VsZWN0ZWRPcHRpb25zIGJpbmRpbmcuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChlbGVtZW50LCAnY2hhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIElFIGJ1Z1xuICAgICAgZW5zdXJlU2VsZWN0RWxlbWVudElzUmVuZGVyZWRDb3JyZWN0bHkoZWxlbWVudCk7XG5cbiAgICAgIGlmIChwcmV2aW91c1Njcm9sbFRvcCAmJiBNYXRoLmFicyhwcmV2aW91c1Njcm9sbFRvcCAtIGVsZW1lbnQuc2Nyb2xsVG9wKSA+IDIwKSB7IGVsZW1lbnQuc2Nyb2xsVG9wID0gcHJldmlvdXNTY3JvbGxUb3A7IH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHNlbGVjdGVkT3B0aW9ucyA9IHtcbiAgICBhZnRlcjogWydvcHRpb25zJywgJ2ZvcmVhY2gnXSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncykge1xuICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVBY2Nlc3NvcigpLCB2YWx1ZVRvV3JpdGUgPSBbXTtcbiAgICAgICAgYXJyYXlGb3JFYWNoKGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ29wdGlvbicpLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLnNlbGVjdGVkKSB7IHZhbHVlVG9Xcml0ZS5wdXNoKHNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKG5vZGUpKTsgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWVBY2Nlc3Nvcih2YWx1ZVRvV3JpdGUpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgIGlmICh0YWdOYW1lTG93ZXIoZWxlbWVudCkgIT0gJ3NlbGVjdCcpIHsgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZXMgYmluZGluZyBhcHBsaWVzIG9ubHkgdG8gU0VMRUNUIGVsZW1lbnRzJykgfVxuXG4gICAgICB2YXIgbmV3VmFsdWUgPSB1bndyYXAodmFsdWVBY2Nlc3NvcigpKSxcbiAgICAgICAgcHJldmlvdXNTY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcblxuICAgICAgaWYgKG5ld1ZhbHVlICYmIHR5cGVvZiBuZXdWYWx1ZS5sZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgIGFycmF5Rm9yRWFjaChlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdvcHRpb24nKSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IGFycmF5SW5kZXhPZihuZXdWYWx1ZSwgc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUobm9kZSkpID49IDA7XG4gICAgICAgICAgaWYgKG5vZGUuc2VsZWN0ZWQgIT0gaXNTZWxlY3RlZCkgeyAgICAgIC8vIFRoaXMgY2hlY2sgcHJldmVudHMgZmxhc2hpbmcgb2YgdGhlIHNlbGVjdCBlbGVtZW50IGluIElFXG4gICAgICAgICAgICBzZXRPcHRpb25Ob2RlU2VsZWN0aW9uU3RhdGUobm9kZSwgaXNTZWxlY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBwcmV2aW91c1Njcm9sbFRvcDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qge2pRdWVyeUluc3RhbmNlOiBqUXVlcnlJbnN0YW5jZSQxfSA9IG9wdGlvbnM7XG5cbiAgdmFyIHN0eWxlID0ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHVud3JhcCh2YWx1ZUFjY2Vzc29yKCkgfHwge30pO1xuICAgICAgb2JqZWN0Rm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVZhbHVlID0gdW53cmFwKHN0eWxlVmFsdWUpO1xuXG4gICAgICAgIGlmIChzdHlsZVZhbHVlID09PSBudWxsIHx8IHN0eWxlVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHlsZVZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIEVtcHR5IHN0cmluZyByZW1vdmVzIHRoZSB2YWx1ZSwgd2hlcmVhcyBudWxsL3VuZGVmaW5lZCBoYXZlIG5vIGVmZmVjdFxuICAgICAgICAgIHN0eWxlVmFsdWUgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqUXVlcnlJbnN0YW5jZSQxKSB7XG4gICAgICAgICAgalF1ZXJ5SW5zdGFuY2UkMShlbGVtZW50KS5jc3Moc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZU5hbWUucmVwbGFjZSgvLShcXHcpL2csIChhbGwsIGxldHRlcikgPT4gbGV0dGVyLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzU3R5bGUgPSBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV07XG4gICAgICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgICAgICBpZiAoc3R5bGVWYWx1ZSAhPT0gcHJldmlvdXNTdHlsZSAmJiBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV0gPT09IHByZXZpb3VzU3R5bGUgJiYgIWlzTmFOKHN0eWxlVmFsdWUpKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlICsgJ3B4JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc3VibWl0ID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZUFjY2Vzc29yKCkgIT09ICdmdW5jdGlvbicpIHsgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgZm9yIGEgc3VibWl0IGJpbmRpbmcgbXVzdCBiZSBhIGZ1bmN0aW9uJykgfVxuICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgJ3N1Ym1pdCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgaGFuZGxlclJldHVyblZhbHVlO1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCk7XG4gICAgICAgIHRyeSB7IGhhbmRsZXJSZXR1cm5WYWx1ZSA9IHZhbHVlLmNhbGwoYmluZGluZ0NvbnRleHRbJyRkYXRhJ10sIGVsZW1lbnQpOyB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChoYW5kbGVyUmV0dXJuVmFsdWUgIT09IHRydWUpIHsgLy8gTm9ybWFsbHkgd2Ugd2FudCB0byBwcmV2ZW50IGRlZmF1bHQgYWN0aW9uLiBEZXZlbG9wZXIgY2FuIG92ZXJyaWRlIHRoaXMgYmUgZXhwbGljaXRseSByZXR1cm5pbmcgdHJ1ZS5cbiAgICAgICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkgeyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9IGVsc2UgeyBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHRleHQgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gUHJldmVudCBiaW5kaW5nIG9uIHRoZSBkeW5hbWljYWxseS1pbmplY3RlZCB0ZXh0IG5vZGUgKGFzIGRldmVsb3BlcnMgYXJlIHVubGlrZWx5IHRvIGV4cGVjdCB0aGF0LCBhbmQgaXQgaGFzIHNlY3VyaXR5IGltcGxpY2F0aW9ucykuXG4gICAgICAvLyBJdCBzaG91bGQgYWxzbyBtYWtlIHRoaW5ncyBmYXN0ZXIsIGFzIHdlIG5vIGxvbmdlciBoYXZlIHRvIGNvbnNpZGVyIHdoZXRoZXIgdGhlIHRleHQgbm9kZSBtaWdodCBiZSBiaW5kYWJsZS5cbiAgICAgIHJldHVybiB7IGNvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiB0cnVlIH1cbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgIHNldFRleHRDb250ZW50KGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IoKSk7XG4gICAgfSxcbiAgICBhbGxvd1ZpcnR1YWxFbGVtZW50czogdHJ1ZVxuICB9O1xuXG4gIHZhciBvcGVyYVZlcnNpb24sIHNhZmFyaVZlcnNpb24sIGZpcmVmb3hWZXJzaW9uO1xuXG5cbiAgLyoqXG4gICAqIFRleHRJbnB1dCBiaW5kaW5nIGhhbmRsZXIgZm9yIG1vZGVybiBicm93c2VycyAobGVnYWN5IGJlbG93KS5cbiAgICogQGV4dGVuZHMgQmluZGluZ0hhbmRsZXJcbiAgICovXG4gIGNsYXNzIFRleHRJbnB1dCBleHRlbmRzIEJpbmRpbmdIYW5kbGVyIHtcbiAgICBnZXQgYWxpYXNlcyAoKSB7IHJldHVybiAndGV4dGlucHV0JyB9XG5cbiAgICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICB0aGlzLnByZXZpb3VzRWxlbWVudFZhbHVlID0gdGhpcy4kZWxlbWVudC52YWx1ZTtcblxuICAgICAgaWYgKG9wdGlvbnMuZGVidWcgJiYgdGhpcy5jb25zdHJ1Y3Rvci5fZm9yY2VVcGRhdGVPbikge1xuICAgICAgICAvLyBQcm92aWRlIGEgd2F5IGZvciB0ZXN0cyB0byBzcGVjaWZ5IGV4YWN0bHkgd2hpY2ggZXZlbnRzIGFyZSBib3VuZFxuICAgICAgICBhcnJheUZvckVhY2godGhpcy5jb25zdHJ1Y3Rvci5fZm9yY2VVcGRhdGVPbiwgKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgIGlmIChldmVudE5hbWUuc2xpY2UoMCwgNSkgPT09ICdhZnRlcicpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUuc2xpY2UoNSksICdkZWZlclVwZGF0ZU1vZGVsJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsICd1cGRhdGVNb2RlbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIG9mIHRoaXMuZXZlbnRzSW5kaWNhdGluZ1N5bmNWYWx1ZUNoYW5nZSgpKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsICd1cGRhdGVNb2RlbCcpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgb2YgdGhpcy5ldmVudHNJbmRpY2F0aW5nRGVmZXJWYWx1ZUNoYW5nZSgpKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsICdkZWZlclVwZGF0ZU1vZGVsJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbXB1dGVkKCd1cGRhdGVWaWV3Jyk7XG4gICAgfVxuXG4gICAgZXZlbnRzSW5kaWNhdGluZ1N5bmNWYWx1ZUNoYW5nZSAoKSB7XG4gICAgICAvLyBpbnB1dDogRGVmYXVsdCwgbW9kZXJuIGhhbmRsZXJcbiAgICAgIC8vIGNoYW5nZTogQ2F0Y2ggcHJvZ3JhbW1hdGljIHVwZGF0ZXMgb2YgdGhlIHZhbHVlIHRoYXQgZmlyZSB0aGlzIGV2ZW50LlxuICAgICAgLy8gYmx1cjogVG8gZGVhbCB3aXRoIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgbm90aWZ5IGFueSBraW5kIG9mIGV2ZW50IGZvciBzb21lIGNoYW5nZXMgKElFLCBTYWZhcmksIGV0Yy4pXG4gICAgICByZXR1cm4gWydpbnB1dCcsICdjaGFuZ2UnLCAnYmx1ciddXG4gICAgfVxuXG4gICAgZXZlbnRzSW5kaWNhdGluZ0RlZmVyVmFsdWVDaGFuZ2UgKCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgdXBkYXRlTW9kZWwgKGV2ZW50KSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy4kZWxlbWVudDtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRIYW5kbGUpO1xuICAgICAgdGhpcy5lbGVtZW50VmFsdWVCZWZvcmVFdmVudCA9IHRoaXMudGltZW91dEhhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGVsZW1lbnQudmFsdWU7XG4gICAgICBpZiAodGhpcy5wcmV2aW91c0VsZW1lbnRWYWx1ZSAhPT0gZWxlbWVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZSBhIHdheSBmb3IgdGVzdHMgdG8ga25vdyBleGFjdGx5IHdoaWNoIGV2ZW50IHdhcyBwcm9jZXNzZWRcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcgJiYgZXZlbnQpIHtcbiAgICAgICAgICBlbGVtZW50Ll9rb190ZXh0SW5wdXRQcm9jZXNzZWRFdmVudCA9IGV2ZW50LnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2aW91c0VsZW1lbnRWYWx1ZSA9IGVsZW1lbnRWYWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGVsZW1lbnRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWZlclVwZGF0ZU1vZGVsIChldmVudCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuJGVsZW1lbnQ7XG4gICAgICBpZiAoIXRoaXMudGltZW91dEhhbmRsZSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudFZhbHVlQmVmb3JlRXZlbnQgdmFyaWFibGUgaXMgc2V0ICpvbmx5KiBkdXJpbmcgdGhlIGJyaWVmIGdhcCBiZXR3ZWVuIGFuXG4gICAgICAgIC8vIGV2ZW50IGZpcmluZyBhbmQgdGhlIHVwZGF0ZU1vZGVsIGZ1bmN0aW9uIHJ1bm5pbmcuIFRoaXMgYWxsb3dzIHVzIHRvIGlnbm9yZSBtb2RlbFxuICAgICAgICAvLyB1cGRhdGVzIHRoYXQgYXJlIGZyb20gdGhlIHByZXZpb3VzIHN0YXRlIG9mIHRoZSBlbGVtZW50LCB1c3VhbGx5IGR1ZSB0byB0ZWNobmlxdWVzXG4gICAgICAgIC8vIHN1Y2ggYXMgcmF0ZUxpbWl0LiBTdWNoIHVwZGF0ZXMsIGlmIG5vdCBpZ25vcmVkLCBjYW4gY2F1c2Uga2V5c3Ryb2tlcyB0byBiZSBsb3N0LlxuICAgICAgICB0aGlzLmVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50ID0gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IG9wdGlvbnMuZGVidWcgPyB0aGlzLnVwZGF0ZU1vZGVsLmJpbmQodGhpcywgeyB0eXBlOiBldmVudC50eXBlIH0pIDogdGhpcy51cGRhdGVNb2RlbDtcbiAgICAgICAgdGhpcy50aW1lb3V0SGFuZGxlID0gc2FmZVNldFRpbWVvdXQoaGFuZGxlciwgNCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlVmlldyAoKSB7XG4gICAgICBsZXQgbW9kZWxWYWx1ZSA9IHVud3JhcCh0aGlzLnZhbHVlKTtcbiAgICAgIGlmIChtb2RlbFZhbHVlID09PSBudWxsIHx8IG1vZGVsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtb2RlbFZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbGVtZW50VmFsdWVCZWZvcmVFdmVudCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICYmIG1vZGVsVmFsdWUgPT09IHRoaXMuZWxlbWVudFZhbHVlQmVmb3JlRXZlbnQpIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnVwZGF0ZVZpZXcuYmluZCh0aGlzKSwgNCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuJGVsZW1lbnQudmFsdWUgIT09IG1vZGVsVmFsdWUpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBlbGVtZW50IG9ubHkgaWYgdGhlIGVsZW1lbnQgYW5kIG1vZGVsIGFyZSBkaWZmZXJlbnQuIE9uIHNvbWUgYnJvd3NlcnMsIHVwZGF0aW5nIHRoZSB2YWx1ZVxuICAgICAgICAvLyB3aWxsIG1vdmUgdGhlIGN1cnNvciB0byB0aGUgZW5kIG9mIHRoZSBpbnB1dCwgd2hpY2ggd291bGQgYmUgYmFkIHdoaWxlIHRoZSB1c2VyIGlzIHR5cGluZy5cbiAgICAgICAgdGhpcy5wcmV2aW91c0VsZW1lbnRWYWx1ZSA9IG1vZGVsVmFsdWU7IC8vIE1ha2Ugc3VyZSB3ZSBpZ25vcmUgZXZlbnRzIChwcm9wZXJ0eWNoYW5nZSkgdGhhdCByZXN1bHQgZnJvbSB1cGRhdGluZyB0aGUgdmFsdWVcbiAgICAgICAgdGhpcy4kZWxlbWVudC52YWx1ZSA9IG1vZGVsVmFsdWU7XG4gICAgICAgIHRoaXMucHJldmlvdXNFbGVtZW50VmFsdWUgPSB0aGlzLiRlbGVtZW50LnZhbHVlOyAvLyBJbiBjYXNlIHRoZSBicm93c2VyIGNoYW5nZXMgdGhlIHZhbHVlIChzZWUgIzIyODEpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExlZ2FjeSBJbnB1dCBDbGFzc2VzLCBiZWxvd1xuICAgKi9cbiAgY2xhc3MgVGV4dElucHV0SUUgZXh0ZW5kcyBUZXh0SW5wdXQge1xuICAgIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcblxuICAgICAgaWYgKGllVmVyc2lvbiA8IDExKSB7XG4gICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIDw9IDggZG9lc24ndCBzdXBwb3J0IHRoZSAnaW5wdXQnIGV2ZW50LCBidXQgZG9lcyBpbmNsdWRlICdwcm9wZXJ0eWNoYW5nZScgdGhhdCBmaXJlcyB3aGVuZXZlclxuICAgICAgICAvLyBhbnkgcHJvcGVydHkgb2YgYW4gZWxlbWVudCBjaGFuZ2VzLiBVbmxpa2UgJ2lucHV0JywgaXQgYWxzbyBmaXJlcyBpZiBhIHByb3BlcnR5IGlzIGNoYW5nZWQgZnJvbSBKYXZhU2NyaXB0IGNvZGUsXG4gICAgICAgIC8vIGJ1dCB0aGF0J3MgYW4gYWNjZXB0YWJsZSBjb21wcm9taXNlIGZvciB0aGlzIGJpbmRpbmcuIElFIDkgYW5kIDEwIHN1cHBvcnQgJ2lucHV0JywgYnV0IHNpbmNlIHRoZXkgZG9uJ3QgYWx3YXlzXG4gICAgICAgIC8vIGZpcmUgaXQgd2hlbiB1c2luZyBhdXRvY29tcGxldGUsIHdlJ2xsIHVzZSAncHJvcGVydHljaGFuZ2UnIGZvciB0aGVtIGFsc28uXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncHJvcGVydHljaGFuZ2UnLCBldmVudCA9PlxuICAgICAgICAgIGV2ZW50LnByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyAmJiB0aGlzLnVwZGF0ZU1vZGVsKGV2ZW50KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWVWZXJzaW9uID49IDggJiYgaWVWZXJzaW9uIDwgMTApIHtcbiAgICAgICAgdGhpcy53YXRjaEZvclNlbGVjdGlvbkNoYW5nZUV2ZW50KCk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsICdkZWZlclVwZGF0ZU1vZGVsJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXZlbnRzSW5kaWNhdGluZ1N5bmNWYWx1ZUNoYW5nZSAoKSB7XG4gICAgICAvLyBrZXlwcmVzczogQWxsIHZlcnNpb25zIChpbmNsdWRpbmcgMTEpIG9mIEludGVybmV0IEV4cGxvcmVyIGhhdmUgYSBidWcgdGhhdCB0aGV5IGRvbid0IGdlbmVyYXRlIGFuIGlucHV0IG9yIHByb3BlcnR5Y2hhbmdlIGV2ZW50IHdoZW4gRVNDIGlzIHByZXNzZWRcbiAgICAgIHJldHVybiBbLi4uc3VwZXIuZXZlbnRzSW5kaWNhdGluZ1ZhbHVlQ2hhbmdlKCksICdrZXlwcmVzcyddXG4gICAgfVxuXG4gICAgLy8gSUUgOCBhbmQgOSBoYXZlIGJ1Z3MgdGhhdCBwcmV2ZW50IHRoZSBub3JtYWwgZXZlbnRzIGZyb20gZmlyaW5nIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuXG4gICAgLy8gQnV0IGl0IGRvZXMgZmlyZSB0aGUgJ3NlbGVjdGlvbmNoYW5nZScgZXZlbnQgb24gbWFueSBvZiB0aG9zZSwgcHJlc3VtYWJseSBiZWNhdXNlIHRoZVxuICAgIC8vIGN1cnNvciBpcyBtb3ZpbmcgYW5kIHRoYXQgY291bnRzIGFzIHRoZSBzZWxlY3Rpb24gY2hhbmdpbmcuIFRoZSAnc2VsZWN0aW9uY2hhbmdlJyBldmVudCBpc1xuICAgIC8vIGZpcmVkIGF0IHRoZSBkb2N1bWVudCBsZXZlbCBvbmx5IGFuZCBkb2Vzbid0IGRpcmVjdGx5IGluZGljYXRlIHdoaWNoIGVsZW1lbnQgY2hhbmdlZC4gV2VcbiAgICAvLyBzZXQgdXAganVzdCBvbmUgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGRvY3VtZW50IGFuZCB1c2UgJ2FjdGl2ZUVsZW1lbnQnIHRvIGRldGVybWluZSB3aGljaFxuICAgIC8vIGVsZW1lbnQgd2FzIGNoYW5nZWQuXG4gICAgc2VsZWN0aW9uQ2hhbmdlSGFuZGxlciAoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5hY3RpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGFyZ2V0ICYmIGdldCh0YXJnZXQsIHNlbGVjdGlvbkNoYW5nZUhhbmRsZXJOYW1lKTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHsgaGFuZGxlcihldmVudCk7IH1cbiAgICB9XG5cbiAgICB3YXRjaEZvclNlbGVjdGlvbkNoYW5nZUV2ZW50IChlbGVtZW50LCBpZVVwZGF0ZU1vZGVsKSB7XG4gICAgICBjb25zdCBvd25lckRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmICghZ2V0KG93bmVyRG9jLCBzZWxlY3Rpb25DaGFuZ2VSZWdpc3RlcmVkTmFtZSkpIHtcbiAgICAgICAgICBzZXQob3duZXJEb2MsIHNlbGVjdGlvbkNoYW5nZVJlZ2lzdGVyZWROYW1lLCB0cnVlKTtcbiAgICAgICAgICByZWdpc3RlckV2ZW50SGFuZGxlcihvd25lckRvYywgJ3NlbGVjdGlvbmNoYW5nZScsIHRoaXMuc2VsZWN0aW9uQ2hhbmdlSGFuZGxlci5iaW5kKG93bmVyRG9jKSk7XG4gICAgICB9XG4gICAgICBzZXQoZWxlbWVudCwgc2VsZWN0aW9uQ2hhbmdlSGFuZGxlck5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gSUUgOCBhbmQgOSBoYXZlIGJ1Z3MgdGhhdCBwcmV2ZW50IHRoZSBub3JtYWwgZXZlbnRzIGZyb20gZmlyaW5nIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuXG4gIC8vIEJ1dCBpdCBkb2VzIGZpcmUgdGhlICdzZWxlY3Rpb25jaGFuZ2UnIGV2ZW50IG9uIG1hbnkgb2YgdGhvc2UsIHByZXN1bWFibHkgYmVjYXVzZSB0aGVcbiAgLy8gY3Vyc29yIGlzIG1vdmluZyBhbmQgdGhhdCBjb3VudHMgYXMgdGhlIHNlbGVjdGlvbiBjaGFuZ2luZy4gVGhlICdzZWxlY3Rpb25jaGFuZ2UnIGV2ZW50IGlzXG4gIC8vIGZpcmVkIGF0IHRoZSBkb2N1bWVudCBsZXZlbCBvbmx5IGFuZCBkb2Vzbid0IGRpcmVjdGx5IGluZGljYXRlIHdoaWNoIGVsZW1lbnQgY2hhbmdlZC4gV2VcbiAgLy8gc2V0IHVwIGp1c3Qgb25lIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBkb2N1bWVudCBhbmQgdXNlICdhY3RpdmVFbGVtZW50JyB0byBkZXRlcm1pbmUgd2hpY2hcbiAgLy8gZWxlbWVudCB3YXMgY2hhbmdlZC5cbiAgY2xhc3MgVGV4dElucHV0SUU5IGV4dGVuZHMgVGV4dElucHV0SUUge1xuICAgIHVwZGF0ZU1vZGVsICguLi5hcmdzKSB7XG4gICAgICAvLyBJRTkgd2lsbCBtZXNzIHVwIHRoZSBET00gaWYgeW91IGhhbmRsZSBldmVudHMgc3luY2hyb25vdXNseSB3aGljaCByZXN1bHRzIGluIERPTSBjaGFuZ2VzIChzdWNoIGFzIG90aGVyIGJpbmRpbmdzKTtcbiAgICAgIC8vIHNvIHdlJ2xsIG1ha2Ugc3VyZSBhbGwgdXBkYXRlcyBhcmUgYXN5bmNocm9ub3VzXG4gICAgICB0aGlzLmRlZmVyVXBkYXRlTW9kZWwoLi4uYXJncyk7XG4gICAgfVxuICB9XG5cblxuICBjbGFzcyBUZXh0SW5wdXRJRTggZXh0ZW5kcyBUZXh0SW5wdXRJRSB7XG4gICAgZXZlbnRzSW5kaWNhdGluZ1ZhbHVlQ2hhbmdlICgpIHtcbiAgICAgIC8vIElFIDggaGFzIGEgYnVnIHdoZXJlIGl0IGZhaWxzIHRvIGZpcmUgJ3Byb3BlcnR5Y2hhbmdlJyBvbiB0aGUgZmlyc3QgdXBkYXRlIGZvbGxvd2luZyBhIHZhbHVlIGNoYW5nZSBmcm9tXG4gICAgICAvLyBKYXZhU2NyaXB0IGNvZGUuIEl0IGFsc28gZG9lc24ndCBmaXJlIGlmIHlvdSBjbGVhciB0aGUgZW50aXJlIHZhbHVlLiBUbyBmaXggdGhpcywgd2UgYmluZCB0byB0aGUgZm9sbG93aW5nXG4gICAgICAvLyBldmVudHMgdG9vLlxuICAgICAgLy8ga2V5cHJlc3M6IEFsbCB2ZXJzaW9ucyAoaW5jbHVkaW5nIDExKSBvZiBJbnRlcm5ldCBFeHBsb3JlciBoYXZlIGEgYnVnIHRoYXQgdGhleSBkb24ndCBnZW5lcmF0ZSBhbiBpbnB1dCBvciBwcm9wZXJ0eWNoYW5nZSBldmVudCB3aGVuIEVTQyBpcyBwcmVzc2VkXG4gICAgICAvLyBrZXl1cDogQSBzaW5nbGUga2V5c3Rva2VcbiAgICAgIC8vIGtleWRvd246IEZpcnN0IGNoYXJhY3RlciB3aGVuIGEga2V5IGlzIGhlbGQgZG93blxuICAgICAgcmV0dXJuIFsuLi5zdXBlci5ldmVudHNJbmRpY2F0aW5nVmFsdWVDaGFuZ2UoKSwgJ2tleXVwJywgJ2tleWRvd24nXVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gU2FmYXJpIDw1IGRvZXNuJ3QgZmlyZSB0aGUgJ2lucHV0JyBldmVudCBmb3IgPHRleHRhcmVhPiBlbGVtZW50cyAoaXQgZG9lcyBmaXJlICd0ZXh0SW5wdXQnXG4gIC8vIGJ1dCBvbmx5IHdoZW4gdHlwaW5nKS4gU28gd2UnbGwganVzdCBjYXRjaCBhcyBtdWNoIGFzIHdlIGNhbiB3aXRoIGtleWRvd24sIGN1dCwgYW5kIHBhc3RlLlxuICBjbGFzcyBUZXh0SW5wdXRMZWdhY3lTYWZhcmkgZXh0ZW5kcyBUZXh0SW5wdXQge1xuICAgIGV2ZW50c0luZGljYXRpbmdEZWZlclZhbHVlQ2hhbmdlICgpIHtcbiAgICAgIHJldHVybiBbJ2tleWRvd24nLCAncGFzdGUnLCAnY3V0J11cbiAgICB9XG4gIH1cblxuXG4gIGNsYXNzIFRleHRJbnB1dExlZ2FjeU9wZXJhIGV4dGVuZHMgVGV4dElucHV0IHtcbiAgICBldmVudHNJbmRpY2F0aW5nRGVmZXJWYWx1ZUNoYW5nZSAoKSB7XG4gICAgICAvLyBPcGVyYSAxMCBkb2Vzbid0IGFsd2F5cyBmaXJlIHRoZSAnaW5wdXQnIGV2ZW50IGZvciBjdXQsIHBhc3RlLCB1bmRvICYgZHJvcCBvcGVyYXRpb25zLlxuICAgICAgLy8gV2UgY2FuIHRyeSB0byBjYXRjaCBzb21lIG9mIHRob3NlIHVzaW5nICdrZXlkb3duJy5cbiAgICAgIHJldHVybiBbJ2tleWRvd24nXVxuICAgIH1cbiAgfVxuXG5cbiAgY2xhc3MgVGV4dElucHV0TGVnYWN5RmlyZWZveCBleHRlbmRzIFRleHRJbnB1dCB7XG4gICAgZXZlbnRzSW5kaWNhdGluZ1ZhbHVlQ2hhbmdlICgpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC4uLnN1cGVyLmV2ZW50c0luZGljYXRpbmdTeW5jVmFsdWVDaGFuZ2UoKSxcbiAgICAgICAgLy8gRmlyZWZveCA8PSAzLjYgZG9lc24ndCBmaXJlIHRoZSAnaW5wdXQnIGV2ZW50IHdoZW4gdGV4dCBpcyBmaWxsZWQgaW4gdGhyb3VnaCBhdXRvY29tcGxldGVcbiAgICAgICAgJ0RPTUF1dG9Db21wbGV0ZScsXG4gICAgICAgIC8vIEZpcmVmb3ggPD0zLjUgZG9lc24ndCBmaXJlIHRoZSAnaW5wdXQnIGV2ZW50IHdoZW4gdGV4dCBpcyBkcm9wcGVkIGludG8gdGhlIGlucHV0LlxuICAgICAgICAnZHJhZ2Ryb3AnLCAvLyA8IDMuNVxuICAgICAgICAnZHJvcCcgLy8gMy41XG4gICAgICBdXG4gICAgfVxuICB9XG5cblxuICBjb25zdCB3JDEgPSBvcHRpb25zLmdsb2JhbDsgLy8gd2luZG93IC8gZ2xvYmFsXG4gIGlmICh3JDEubmF2aWdhdG9yKSB7XG4gICAgY29uc3QgcGFyc2VWZXJzaW9uID0gKG1hdGNoZXMpID0+IG1hdGNoZXMgJiYgcGFyc2VGbG9hdChtYXRjaGVzWzFdKTtcbiAgICBjb25zdCB1c2VyQWdlbnQgPSB3JDEubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICBjb25zdCBpc0Nocm9tZSA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFteIF0rKS8pO1xuICAgIC8vIERldGVjdCB2YXJpb3VzIGJyb3dzZXIgdmVyc2lvbnMgYmVjYXVzZSBzb21lIG9sZCB2ZXJzaW9ucyBkb24ndCBmdWxseSBzdXBwb3J0IHRoZSAnaW5wdXQnIGV2ZW50XG4gICAgb3BlcmFWZXJzaW9uID0gdyQxLm9wZXJhICYmIHckMS5vcGVyYS52ZXJzaW9uICYmIHBhcnNlSW50KHckMS5vcGVyYS52ZXJzaW9uKCkpO1xuICAgIHNhZmFyaVZlcnNpb24gPSBwYXJzZVZlcnNpb24odXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFteIF0rKSBTYWZhcmkvKSk7XG4gICAgZmlyZWZveFZlcnNpb24gPSBwYXJzZVZlcnNpb24odXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvKFteIF0qKS8pKTtcbiAgfVxuXG5cbiAgY29uc3QgdGV4dElucHV0ID1cbiAgICBpZVZlcnNpb24gPT09IDggPyBUZXh0SW5wdXRJRThcbiAgICA6IGllVmVyc2lvbiA9PT0gOSA/IFRleHRJbnB1dElFOVxuICAgIDogaWVWZXJzaW9uID8gVGV4dElucHV0SUVcbiAgICA6IHNhZmFyaVZlcnNpb24gJiYgc2FmYXJpVmVyc2lvbiA8IDUgPyBUZXh0SW5wdXRMZWdhY3lTYWZhcmlcbiAgICA6IG9wZXJhVmVyc2lvbiA8IDExID8gVGV4dElucHV0TGVnYWN5T3BlcmFcbiAgICA6IGZpcmVmb3hWZXJzaW9uICYmIGZpcmVmb3hWZXJzaW9uIDwgNCA/IFRleHRJbnB1dExlZ2FjeUZpcmVmb3hcbiAgICA6IFRleHRJbnB1dDtcblxuICB2YXIgdW5pcXVlTmFtZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgaWYgKHZhbHVlQWNjZXNzb3IoKSkge1xuICAgICAgICB2YXIgbmFtZSA9ICdrb191bmlxdWVfJyArICgrK3VuaXF1ZU5hbWUuY3VycmVudEluZGV4KTtcbiAgICAgICAgc2V0RWxlbWVudE5hbWUoZWxlbWVudCwgbmFtZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjdXJyZW50SW5kZXg6IDBcbiAgfTtcblxuICBjbGFzcyB2YWx1ZSBleHRlbmRzIEJpbmRpbmdIYW5kbGVyIHtcbiAgICBzdGF0aWMgZ2V0IGFmdGVyICgpIHsgcmV0dXJuIFsnb3B0aW9ucycsICdmb3JlYWNoJywgJ3RlbXBsYXRlJ10gfVxuXG4gICAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgICAvLyBJZiB0aGUgdmFsdWUgYmluZGluZyBpcyBwbGFjZWQgb24gYSByYWRpby9jaGVja2JveCwgdGhlbiBqdXN0IHBhc3MgdGhyb3VnaCB0byBjaGVja2VkVmFsdWUgYW5kIHF1aXRcbiAgICAgIGlmICh0aGlzLmlzQ2hlY2tib3hPclJhZGlvKSB7XG4gICAgICAgIGFwcGx5QmluZGluZ0FjY2Vzc29yc1RvTm9kZSh0aGlzLiRlbGVtZW50LFxuICAgICAgICAgIHsgY2hlY2tlZFZhbHVlOiB0aGlzLnZhbHVlQWNjZXNzb3IgfSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BlcnR5Q2hhbmdlZEZpcmVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuaWVBdXRvQ29tcGxldGVIYWNrTmVlZGVkKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncHJvcGVydHlDaGFuZ2UnLCAoKSA9PiB0aGlzLnByb3BlcnR5Q2hhbmdlZEZpcmVkID0gdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoKSA9PiB0aGlzLnByb3BlcnR5Q2hhbmdlZEZpcmVkID0gZmFsc2UpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoKSA9PiB0aGlzLnByb3BlcnR5Q2hhbmdlRmlyZWQgJiZcbiAgICAgICAgICB0aGlzLnZhbHVlVXBkYXRlSGFuZGxlcigpKTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlGb3JFYWNoKHRoaXMuZXZlbnRzVG9DYXRjaCwgZXZlbnROYW1lID0+IHRoaXMucmVnaXN0ZXJFdmVudChldmVudE5hbWUpKTtcblxuICAgICAgaWYgKHRoaXMuaXNJbnB1dCAmJiB0aGlzLiRlbGVtZW50LnR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICB0aGlzLnVwZGF0ZUZyb21Nb2RlbCA9IHRoaXMudXBkYXRlRnJvbU1vZGVsRm9yRmlsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbU1vZGVsID0gdGhpcy51cGRhdGVGcm9tTW9kZWxGb3JWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21wdXRlZCgndXBkYXRlRnJvbU1vZGVsJyk7XG4gICAgfVxuXG4gICAgZ2V0IGV2ZW50c1RvQ2F0Y2ggKCkge1xuICAgICAgY29uc3QgcmVxdWVzdGVkRXZlbnRzVG9DYXRjaCA9IHRoaXMuYWxsQmluZGluZ3MuZ2V0KCd2YWx1ZVVwZGF0ZScpO1xuICAgICAgY29uc3QgcmVxdWVzdGVkRXZlbnRzQXJyYXkgPSB0eXBlb2YgcmVxdWVzdGVkRXZlbnRzVG9DYXRjaCA9PT0gJ3N0cmluZycgP1xuICAgICAgICBbcmVxdWVzdGVkRXZlbnRzVG9DYXRjaF0gOiByZXF1ZXN0ZWRFdmVudHNUb0NhdGNoIHx8IFtdO1xuICAgICAgcmV0dXJuIFsuLi5uZXcgU2V0KFsnY2hhbmdlJywgLi4ucmVxdWVzdGVkRXZlbnRzQXJyYXldKV1cbiAgICB9XG5cbiAgICBnZXQgaXNJbnB1dCAoKSB7XG4gICAgICByZXR1cm4gdGFnTmFtZUxvd2VyKHRoaXMuJGVsZW1lbnQpID09PSAnaW5wdXQnXG4gICAgfVxuXG4gICAgZ2V0IGlzQ2hlY2tib3hPclJhZGlvICgpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLiRlbGVtZW50O1xuICAgICAgcmV0dXJuIHRoaXMuaXNJbnB1dCAmJiAoZS50eXBlID09ICdjaGVja2JveCcgfHwgZS50eXBlID09ICdyYWRpbycpXG4gICAgfVxuXG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL1N0ZXZlU2FuZGVyc29uL2tub2Nrb3V0L2lzc3Vlcy8xMjJcbiAgICAvLyBJRSBkb2Vzbid0IGZpcmUgXCJjaGFuZ2VcIiBldmVudHMgb24gdGV4dGJveGVzIGlmIHRoZSB1c2VyIHNlbGVjdHMgYSB2YWx1ZSBmcm9tIGl0cyBhdXRvY29tcGxldGUgbGlzdFxuICAgIGdldCBpZUF1dG9Db21wbGV0ZUhhY2tOZWVkZWQgKCkge1xuICAgICAgcmV0dXJuIGllVmVyc2lvbiAmJiBpc0lucHV0RWxlbWVudCAmJlxuICAgICAgICB0aGlzLiRlbGVtZW50LnR5cGUgPT0gJ3RleHQnICYmIHRoaXMuJGVsZW1lbnQuYXV0b2NvbXBsZXRlICE9ICdvZmYnICYmXG4gICAgICAgICghdGhpcy4kZWxlbWVudC5mb3JtIHx8IHRoaXMuJGVsZW1lbnQuZm9ybS5hdXRvY29tcGxldGUgIT0gJ29mZicpXG4gICAgfVxuXG4gICAgdmFsdWVVcGRhdGVIYW5kbGVyICgpIHtcbiAgICAgIHRoaXMuZWxlbWVudFZhbHVlQmVmb3JlRXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5wcm9wZXJ0eUNoYW5nZWRGaXJlZCA9IGZhbHNlO1xuICAgICAgdGhpcy52YWx1ZSA9IHNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKHRoaXMuJGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyRXZlbnQgKGV2ZW50TmFtZSkge1xuICAgICAgLy8gVGhlIHN5bnRheCBcImFmdGVyPGV2ZW50bmFtZT5cIiBtZWFucyBcInJ1biB0aGUgaGFuZGxlciBhc3luY2hyb25vdXNseSBhZnRlciB0aGUgZXZlbnRcIlxuICAgICAgLy8gVGhpcyBpcyB1c2VmdWwsIGZvciBleGFtcGxlLCB0byBjYXRjaCBcImtleWRvd25cIiBldmVudHMgYWZ0ZXIgdGhlIGJyb3dzZXIgaGFzIHVwZGF0ZWQgdGhlIGNvbnRyb2xcbiAgICAgIC8vIChvdGhlcndpc2UsIHNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKHRoaXMpIHdpbGwgcmVjZWl2ZSB0aGUgY29udHJvbCdzIHZhbHVlICpiZWZvcmUqIHRoZSBrZXkgZXZlbnQpXG4gICAgICB2YXIgaGFuZGxlciA9IHRoaXMudmFsdWVVcGRhdGVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICBpZiAoc3RyaW5nU3RhcnRzV2l0aChldmVudE5hbWUsICdhZnRlcicpKSB7XG4gICAgICAgIGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgLy8gVGhlIGVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50IHZhcmlhYmxlIGlzIG5vbi1udWxsICpvbmx5KiBkdXJpbmcgdGhlIGJyaWVmIGdhcCBiZXR3ZWVuXG4gICAgICAgICAgLy8gYSBrZXlYIGV2ZW50IGZpcmluZyBhbmQgdGhlIHZhbHVlVXBkYXRlSGFuZGxlciBydW5uaW5nLCB3aGljaCBpcyBzY2hlZHVsZWQgdG8gaGFwcGVuXG4gICAgICAgICAgLy8gYXQgdGhlIGVhcmxpZXN0IGFzeW5jaHJvbm91cyBvcHBvcnR1bml0eS4gV2Ugc3RvcmUgdGhpcyB0ZW1wb3JhcnkgaW5mb3JtYXRpb24gc28gdGhhdFxuICAgICAgICAgIC8vIGlmLCBiZXR3ZWVuIGtleVggYW5kIHZhbHVlVXBkYXRlSGFuZGxlciwgdGhlIHVuZGVybHlpbmcgbW9kZWwgdmFsdWUgY2hhbmdlcyBzZXBhcmF0ZWx5LFxuICAgICAgICAgIC8vIHdlIGNhbiBvdmVyd3JpdGUgdGhhdCBtb2RlbCB2YWx1ZSBjaGFuZ2Ugd2l0aCB0aGUgdmFsdWUgdGhlIHVzZXIganVzdCB0eXBlZC4gT3RoZXJ3aXNlLFxuICAgICAgICAgIC8vIHRlY2huaXF1ZXMgbGlrZSByYXRlTGltaXQgY2FuIHRyaWdnZXIgbW9kZWwgY2hhbmdlcyBhdCBjcml0aWNhbCBtb21lbnRzIHRoYXQgd2lsbFxuICAgICAgICAgIC8vIG92ZXJyaWRlIHRoZSB1c2VyJ3MgaW5wdXRzLCBjYXVzaW5nIGtleXN0cm9rZXMgdG8gYmUgbG9zdC5cbiAgICAgICAgICB0aGlzLmVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50ID0gc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUodGhpcy4kZWxlbWVudCk7XG4gICAgICAgICAgc2FmZVNldFRpbWVvdXQodGhpcy52YWx1ZVVwZGF0ZUhhbmRsZXIuYmluZCh0aGlzKSwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS5zdWJzdHJpbmcoNSAvKiAnYWZ0ZXInLmxlbmd0aCAqLyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICB1cGRhdGVGcm9tTW9kZWxGb3JGaWxlICgpIHtcbiAgICAgIC8vIEZvciBmaWxlIGlucHV0IGVsZW1lbnRzLCBjYW4gb25seSB3cml0ZSB0aGUgZW1wdHkgc3RyaW5nXG4gICAgICB2YXIgbmV3VmFsdWUgPSB1bndyYXAodGhpcy52YWx1ZSk7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IG51bGwgfHwgbmV3VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBuZXdWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC52YWx1ZSA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWdub3JlKHRoaXMudmFsdWVVcGRhdGVIYW5kbGVyLCB0aGlzKTsgICAvLyByZXNldCB0aGUgbW9kZWwgdG8gbWF0Y2ggdGhlIGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVGcm9tTW9kZWxGb3JWYWx1ZSAoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy4kZWxlbWVudDtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHVud3JhcCh0aGlzLnZhbHVlKTtcbiAgICAgIHZhciBlbGVtZW50VmFsdWUgPSBzZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZShlbGVtZW50KTtcblxuICAgICAgaWYgKHRoaXMuZWxlbWVudFZhbHVlQmVmb3JlRXZlbnQgIT09IG51bGwgJiYgbmV3VmFsdWUgPT09IHRoaXMuZWxlbWVudFZhbHVlQmVmb3JlRXZlbnQpIHtcbiAgICAgICAgc2FmZVNldFRpbWVvdXQodGhpcy51cGRhdGVGcm9tTW9kZWwuYmluZCh0aGlzKSwgMCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IGVsZW1lbnRWYWx1ZSAmJiBlbGVtZW50VmFsdWUgIT09IHVuZGVmaW5lZCkgeyByZXR1cm4gfVxuXG4gICAgICBpZiAodGFnTmFtZUxvd2VyKGVsZW1lbnQpID09PSAnc2VsZWN0Jykge1xuICAgICAgICBjb25zdCBhbGxvd1Vuc2V0ID0gdGhpcy5hbGxCaW5kaW5ncy5nZXQoJ3ZhbHVlQWxsb3dVbnNldCcpO1xuICAgICAgICBzZWxlY3RFeHRlbnNpb25zLndyaXRlVmFsdWUoZWxlbWVudCwgbmV3VmFsdWUsIGFsbG93VW5zZXQpO1xuXG4gICAgICAgIGlmICghYWxsb3dVbnNldCAmJiBuZXdWYWx1ZSAhPT0gc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUoZWxlbWVudCkpIHtcbiAgICAgICAgIC8vIElmIHlvdSB0cnkgdG8gc2V0IGEgbW9kZWwgdmFsdWUgdGhhdCBjYW4ndCBiZSByZXByZXNlbnRlZCBpbiBhbiBhbHJlYWR5LXBvcHVsYXRlZCBkcm9wZG93biwgcmVqZWN0IHRoYXQgY2hhbmdlLFxuICAgICAgICAgLy8gYmVjYXVzZSB5b3UncmUgbm90IGFsbG93ZWQgdG8gaGF2ZSBhIG1vZGVsIHZhbHVlIHRoYXQgZGlzYWdyZWVzIHdpdGggYSB2aXNpYmxlIFVJIHNlbGVjdGlvbi5cbiAgICAgICAgICBpZ25vcmUodGhpcy52YWx1ZVVwZGF0ZUhhbmRsZXIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RFeHRlbnNpb25zLndyaXRlVmFsdWUoZWxlbWVudCwgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB2aXNpYmxlID0ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHVud3JhcCh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgICAgdmFyIGlzQ3VycmVudGx5VmlzaWJsZSA9ICEoZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpO1xuICAgICAgaWYgKHZhbHVlICYmICFpc0N1cnJlbnRseVZpc2libGUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKCF2YWx1ZSAmJiBpc0N1cnJlbnRseVZpc2libGUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaGlkZGVuID0ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgIHZpc2libGUudXBkYXRlLmNhbGwodGhpcywgZWxlbWVudCwgKCkgPT4gIXVud3JhcCh2YWx1ZUFjY2Vzc29yKCkpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVzaW5nID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCQkMSkge1xuICAgICAgdmFyIGlubmVyQ29udGV4dCA9IGJpbmRpbmdDb250ZXh0JCQxLmNyZWF0ZUNoaWxkQ29udGV4dCh2YWx1ZUFjY2Vzc29yKTtcbiAgICAgIGFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzKGlubmVyQ29udGV4dCwgZWxlbWVudCk7XG4gICAgICByZXR1cm4geyBjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczogdHJ1ZSB9XG4gICAgfSxcbiAgICBhbGxvd1ZpcnR1YWxFbGVtZW50czogdHJ1ZVxuICB9O1xuXG4gIHZhciBiaW5kaW5ncyQxID0ge1xuICAgIGF0dHIsXG4gICAgY2hlY2tlZCxcbiAgICBjaGVja2VkVmFsdWUsXG4gICAgY2xpY2ssXG4gICAgY3NzLFxuICAgICdjbGFzcyc6IGNzcyxcbiAgICBkZXNjZW5kYW50c0NvbXBsZXRlOiBEZXNjZW5kYW50c0NvbXBsZXRlSGFuZGxlcixcbiAgICBlbmFibGUsXG4gICAgJ2V2ZW50JzogZXZlbnRIYW5kbGVyLFxuICAgIGRpc2FibGUsXG4gICAgaGFzZm9jdXMsXG4gICAgaGFzRm9jdXM6IGhhc2ZvY3VzLFxuICAgIGhpZGRlbixcbiAgICBodG1sLFxuICAgICdsZXQnOiAkbGV0LFxuICAgIG9uOiBvbkhhbmRsZXIsXG4gICAgb3B0aW9uczogb3B0aW9ucyQxLFxuICAgIHNlbGVjdGVkT3B0aW9ucyxcbiAgICBzdHlsZSxcbiAgICBzdWJtaXQsXG4gICAgdGV4dCxcbiAgICB0ZXh0SW5wdXQsXG4gICAgdGV4dGlucHV0OiB0ZXh0SW5wdXQsXG4gICAgdW5pcXVlTmFtZSxcbiAgICB1c2luZyxcbiAgICB2YWx1ZSxcbiAgICB2aXNpYmxlXG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERPTWJpbmRpbmcgdGhhdCBjb250cm9scyBET00gbm9kZXMgcHJlc2VuY2VcbiAgICpcbiAgICogQ292ZXJzIGUuZy5cbiAgICpcbiAgICogMS4gRE9NIE5vZGVzIGNvbnRlbnRzXG4gICAqXG4gICAqIDxkaXYgZGF0YS1iaW5kPSdpZjogeCc+XG4gICAqIDwhLS0gZWxzZSAtLT4gLi4uIGFuIG9wdGlvbmFsICdpZidcbiAgICogPC9kaXY+XG4gICAqXG4gICAqIDIuIFZpcnR1YWwgZWxlbWVudHNcbiAgICpcbiAgICogPCEtLSBrbyBpZjogeCAtLT5cbiAgICogPCEtLSBlbHNlIC0tPlxuICAgKiA8IS0tIC9rbyAtLT5cbiAgICpcbiAgICogMy4gRWxzZSBiaW5kaW5nXG4gICAqIDxkaXYgZGF0YS1iaW5kPSdpZjogeCc+PC9kaXY+XG4gICAqIDxkaXYgZGF0YS1iaW5kPSdlbHNlJz48L2Rpdj5cbiAgICpcbiAgICogUmVxdWlyZXMgYHJlbmRlclN0YXR1c2AgYW5kIGBnZXQgYmluZGluZ0NvbnRleHRgIHRvIGJlIG92ZXJsb2FkZWQsXG4gICAqIGFuZCB0aGlzLmNvbXB1dGVkKCdyZW5kZXInKSBtdXN0IGJlIGNhbGxlZCBpbiB0aGUgY2hpbGQgY29uc3RydWN0b3IuXG4gICAqL1xuICBjbGFzcyBDb25kaXRpb25hbEJpbmRpbmdIYW5kbGVyIGV4dGVuZHMgQXN5bmNCaW5kaW5nSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IgKHBhcmFtcykge1xuICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgIHRoaXMuaGFzRWxzZSA9IHRoaXMuZGV0ZWN0RWxzZSh0aGlzLiRlbGVtZW50KTtcbiAgICAgIGNvbnN0IGVsc2VDaGFpblNhdGlzZmllZCA9IHRoaXMuY29tcGxldGVzRWxzZUNoYWluID0gb2JzZXJ2YWJsZSgpO1xuICAgICAgc2V0KHRoaXMuJGVsZW1lbnQsICdjb25kaXRpb25hbCcsIHsgZWxzZUNoYWluU2F0aXNmaWVkIH0pO1xuICAgIH1cblxuICAgIGdldElmRWxzZU5vZGVzICgpIHtcbiAgICAgIGlmICh0aGlzLmlmRWxzZU5vZGVzKSB7IHJldHVybiB0aGlzLmlmRWxzZU5vZGVzIH1cbiAgICAgIGlmIChnZXREZXBlbmRlbmNpZXNDb3VudCgpIHx8IHRoaXMuaGFzRWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZUlmRWxzZU5vZGVzKHRoaXMuJGVsZW1lbnQsIHRoaXMuaGFzRWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIgKCkge1xuICAgICAgY29uc3QgaXNGaXJzdFJlbmRlciA9ICF0aGlzLmlmRWxzZU5vZGVzO1xuICAgICAgY29uc3Qge3Nob3VsZERpc3BsYXl9ID0gdGhpcy5yZW5kZXJTdGF0dXMoKTtcblxuICAgICAgLy8gU2F2ZSB0aGUgbm9kZXMgYmVmb3JlIHdlIHBvc3NpYmx5IHJlbW92ZSB0aGVtIGZyb20gdGhlIERPTS5cbiAgICAgIHRoaXMuaWZFbHNlTm9kZXMgPSB0aGlzLmdldElmRWxzZU5vZGVzKCkgfHwge307XG5cbiAgICAgIGlmIChzaG91bGREaXNwbGF5KSB7XG4gICAgICAgIGNvbnN0IHVzZU9yaWdpbmFsTm9kZXMgPSBpc0ZpcnN0UmVuZGVyICYmICF0aGlzLmhhc0Vsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyQW5kQXBwbHlCaW5kaW5ncyh0aGlzLmlmRWxzZU5vZGVzLmlmTm9kZXMsIHVzZU9yaWdpbmFsTm9kZXMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc0Vsc2UpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJBbmRBcHBseUJpbmRpbmdzKHRoaXMuaWZFbHNlTm9kZXMuZWxzZU5vZGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtcHR5Tm9kZSh0aGlzLiRlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyByZW5kZXJBbmRBcHBseUJpbmRpbmdzIChub2RlcywgdXNlT3JpZ2luYWxOb2Rlcykge1xuICAgICAgaWYgKCF1c2VPcmlnaW5hbE5vZGVzKSB7XG4gICAgICAgIHNldERvbU5vZGVDaGlsZHJlbiQxKHRoaXMuJGVsZW1lbnQsIGNsb25lTm9kZXMobm9kZXMpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvdW5kID0gYXdhaXQgYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHModGhpcy5iaW5kaW5nQ29udGV4dCwgdGhpcy4kZWxlbWVudCk7XG4gICAgICB0aGlzLmNvbXBsZXRlQmluZGluZyhib3VuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtYXkgYmUgdHJ1dGh5IGZvciB0aGUgYGVsc2VgIGJpbmRpbmcuXG4gICAgICovXG4gICAgZ2V0IGVsc2VDaGFpbklzQWxyZWFkeVNhdGlzZmllZCAoKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGEgbm9kZSBmb3Igd2hldGhlciBpdCByZXByZXNlbnRzIGFuICdlbHNlJyBjb25kaXRpb24uXG4gICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBub2RlIHRvIGJlIHRlc3RlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgdHJ1ZSB3aGVuXG4gICAgICpcbiAgICAgKiBNYXRjaGVzIDwhLS0gZWxzZSAtLT5cbiAgICAgKi9cbiAgICBpc0Vsc2VOb2RlIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gOCAmJlxuICAgICAgICAgICAgbm9kZS5ub2RlVmFsdWUudHJpbSgpLnRvTG93ZXJDYXNlKCkgPT09ICdlbHNlJ1xuICAgIH1cblxuICAgIGRldGVjdEVsc2UgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNoaWxkTm9kZXMoZWxlbWVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5pc0Vsc2VOb2RlKGNoaWxkcmVuW2ldKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZSB0aGUgbm9kZXMsIHJldHVybmluZyBgaWZOb2Rlc2AsIGBlbHNlTm9kZXNgXG4gICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIG5vZGVzIHRvIGJlIGNsb25lZFxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgIGhhc0Vsc2Ugc2hvcnQtY2lyY3VpdCB0byBzcGVlZCB1cCB0aGUgaW5uZXItbG9vcC5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgQ29udGFpbmluZyB0aGUgY2xvbmVkIG5vZGVzLlxuICAgICAqL1xuICAgIGNsb25lSWZFbHNlTm9kZXMgKGVsZW1lbnQsIGhhc0Vsc2UpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGROb2RlcyhlbGVtZW50KTtcbiAgICAgIGNvbnN0IGlmTm9kZXMgPSBbXTtcbiAgICAgIGNvbnN0IGVsc2VOb2RlcyA9IFtdO1xuICAgICAgbGV0IHRhcmdldCA9IGlmTm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGlmIChoYXNFbHNlICYmIHRoaXMuaXNFbHNlTm9kZShjaGlsZHJlbltpXSkpIHtcbiAgICAgICAgICB0YXJnZXQgPSBlbHNlTm9kZXM7XG4gICAgICAgICAgaGFzRWxzZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGNsZWFuTm9kZShjaGlsZHJlbltpXS5jbG9uZU5vZGUodHJ1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBpZk5vZGVzLCBlbHNlTm9kZXMgfVxuICAgIH1cblxuICAgIGdldCBjb250cm9sc0Rlc2NlbmRhbnRzICgpIHsgcmV0dXJuIHRydWUgfVxuICAgIHN0YXRpYyBnZXQgYWxsb3dWaXJ0dWFsRWxlbWVudHMgKCkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cblxuICAvKipcbiAgICogRm9yIHRoZSBgaWY6YCBiaW5kaW5nLlxuICAgKi9cbiAgY2xhc3MgSWZCaW5kaW5nSGFuZGxlciBleHRlbmRzIENvbmRpdGlvbmFsQmluZGluZ0hhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgIHRoaXMuaWZDb25kaXRpb24gPSB0aGlzLmNvbXB1dGVkKCgpID0+ICEhdW53cmFwKHRoaXMudmFsdWUpKTtcbiAgICAgIHRoaXMuY29tcHV0ZWQoJ3JlbmRlcicpO1xuICAgIH1cblxuICAgIHNob3VsZERpc3BsYXlJZiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZkNvbmRpdGlvbigpXG4gICAgfVxuXG4gICAgZ2V0IGJpbmRpbmdDb250ZXh0ICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlmQ29uZGl0aW9uLmlzQWN0aXZlKClcbiAgICAgICAgPyB0aGlzLiRjb250ZXh0LmV4dGVuZCgoKSA9PiB7XG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhpcyBjb250ZXh0IGlzIGRlcGVuZGFudCB1cG9uIHRoZSBjb25kaXRpb25hbCwgc28gdGhlXG4gICAgICAgICAgLy8gb3JkZXIgb2YgYmluZGluZyBhcHBsaWNhdGlvbiBpczogY29uZGl0aW9uYWwgYmVmb3JlIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2tub2Nrb3V0L2tuXG4gICAgICAgICAgLy8gb2Nrb3V0L3B1bGwvMjIyNlxuICAgICAgICAgIHRoaXMuaWZDb25kaXRpb24oKTtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9KVxuICAgICAgICA6IHRoaXMuJGNvbnRleHRcbiAgICB9XG5cbiAgICByZW5kZXJTdGF0dXMgKCkge1xuICAgICAgbGV0IHNob3VsZERpc3BsYXkgPSB0aGlzLnNob3VsZERpc3BsYXlJZigpO1xuXG4gICAgICBpZiAodGhpcy5lbHNlQ2hhaW5Jc0FscmVhZHlTYXRpc2ZpZWQpIHtcbiAgICAgICAgc2hvdWxkRGlzcGxheSA9IGZhbHNlO1xuICAgICAgICAvLyBuZWVkc1JlZnJlc2ggPSBpc0ZpcnN0UmVuZGVyIHx8IHRoaXMuZGlkRGlzcGxheU9uTGFzdFVwZGF0ZSBGSVhNRVxuICAgICAgICB0aGlzLmNvbXBsZXRlc0Vsc2VDaGFpbih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGVzRWxzZUNoYWluKHNob3VsZERpc3BsYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtzaG91bGREaXNwbGF5fVxuICAgIH1cbiAgfVxuXG4gIGNsYXNzIFVubGVzc0JpbmRpbmdIYW5kbGVyIGV4dGVuZHMgSWZCaW5kaW5nSGFuZGxlciB7XG4gICAgc2hvdWxkRGlzcGxheUlmICgpIHsgcmV0dXJuICFzdXBlci5zaG91bGREaXNwbGF5SWYoKSB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGZvbGxvd2luZyBmYWlscyBzb21ld2hlcmUgaW4gdGhlIGBsaW1pdGAgZnVuY3Rpb25zIG9mIE9ic2VydmFibGVzIGkuZS5cbiAgICogaXQncyBhbiBpc3N1ZSByZWxhdGVkIHRvIGFzeW5jL2RlZmVyVXBkYXRlcy5cbiAgICovXG4gIGNsYXNzIFdpdGhCaW5kaW5nSGFuZGxlciBleHRlbmRzIENvbmRpdGlvbmFsQmluZGluZ0hhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgIHRoaXMuYXNPcHRpb24gPSB0aGlzLmFsbEJpbmRpbmdzLmdldCgnYXMnKTtcblxuICAgICAgLy8gSWYgZ2l2ZW4gYGFzYCwgcmVkdWNlIHRoZSBjb25kaXRpb24gdG8gYSBib29sZWFuLCBzbyBpdCBkb2VzIG5vdFxuICAgICAgLy8gY2hhbmdlICYgcmVmcmVzaCB3aGVuIHRoZSB2YWx1ZSBpcyB1cGRhdGVkLlxuICAgICAgY29uc3QgY29uZGl0aW9uYWxGbiA9IHRoaXMuYXNPcHRpb24gJiYgIW9wdGlvbnMuY3JlYXRlQ2hpbGRDb250ZXh0V2l0aEFzXG4gICAgICAgID8gKCkgPT4gQm9vbGVhbih1bndyYXAodGhpcy52YWx1ZSkpIDogKCkgPT4gdW53cmFwKHRoaXMudmFsdWUpO1xuICAgICAgdGhpcy5jb25kaXRpb25hbCA9IHRoaXMuY29tcHV0ZWQoY29uZGl0aW9uYWxGbik7XG5cbiAgICAgIHRoaXMuY29tcHV0ZWQoJ3JlbmRlcicpO1xuICAgIH1cblxuICAgIGdldCBiaW5kaW5nQ29udGV4dCAoKSB7XG4gICAgICBpZiAoIXRoaXMuYXNPcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuY3JlYXRlQ2hpbGRDb250ZXh0KHRoaXMudmFsdWVBY2Nlc3NvcilcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmNyZWF0ZUNoaWxkQ29udGV4dFdpdGhBc1xuICAgICAgICA/IHRoaXMuJGNvbnRleHQuY3JlYXRlQ2hpbGRDb250ZXh0KHRoaXMudmFsdWUsIHRoaXMuYXNPcHRpb24pXG4gICAgICAgIDogdGhpcy4kY29udGV4dC5leHRlbmQoe1t0aGlzLmFzT3B0aW9uXTogdGhpcy52YWx1ZX0pXG4gICAgfVxuXG4gICAgcmVuZGVyU3RhdHVzICgpIHtcbiAgICAgIGNvbnN0IHNob3VsZERpc3BsYXkgPSBCb29sZWFuKHRoaXMuY29uZGl0aW9uYWwoKSk7XG4gICAgICByZXR1cm4geyBzaG91bGREaXNwbGF5IH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGBlbHNlYCBiaW5kaW5nXG4gICAqIChub3QgdG8gYmUgbWlzdGFrZW4gZm9yIGA8IS0tIGVsc2UgLS0+YCBpbnNpZGUgaWYgYmluZGluZ3MuXG4gICAqL1xuICBjbGFzcyBFbHNlQmluZGluZ0hhbmRsZXIgZXh0ZW5kcyBJZkJpbmRpbmdIYW5kbGVyIHtcbiAgICBzaG91bGREaXNwbGF5SWYgKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnNob3VsZERpc3BsYXlJZigpIHx8IHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbnkgY29uZGl0aW9uYWwgdGhhdCBwcmVjZWRlcyB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgeyBlbHNlQ2hhaW5TYXRpc2ZpZWQ6IG9ic2VydmFibGUgfVxuICAgICAqL1xuICAgIGdldCBlbHNlQ2hhaW5Jc0FscmVhZHlTYXRpc2ZpZWQgKCkge1xuICAgICAgaWYgKCF0aGlzLl9lbHNlQ2hhaW4pIHsgdGhpcy5fZWxzZUNoYWluID0gdGhpcy5yZWFkRWxzZUNoYWluKCk7IH1cbiAgICAgIHJldHVybiB1bndyYXAodGhpcy5fZWxzZUNoYWluLmVsc2VDaGFpblNhdGlzZmllZClcbiAgICB9XG5cbiAgICByZWFkRWxzZUNoYWluICgpIHtcbiAgICAgIGxldCBub2RlID0gdGhpcy4kZWxlbWVudDtcbiAgICAgIGRvIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgfSB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVUeXBlICE9PSAxICYmIG5vZGUubm9kZVR5cGUgIT09IDgpXG5cbiAgICAgIGlmICghbm9kZSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICBub2RlID0gcHJldmlvdXNTaWJsaW5nKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0KG5vZGUsICdjb25kaXRpb25hbCcpIHx8IHt9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYmluZGluZ3MkMiA9IHtcbiAgICAnaWYnOiBJZkJpbmRpbmdIYW5kbGVyLFxuICAgICd3aXRoJzogV2l0aEJpbmRpbmdIYW5kbGVyLFxuICAgIGlmbm90OiBVbmxlc3NCaW5kaW5nSGFuZGxlcixcbiAgICB1bmxlc3M6IFVubGVzc0JpbmRpbmdIYW5kbGVyLFxuICAgICdlbHNlJzogRWxzZUJpbmRpbmdIYW5kbGVyLFxuICAgICdlbHNlaWYnOiBFbHNlQmluZGluZ0hhbmRsZXJcbiAgfTtcblxuICAvLyBpbmRleC5qc1xuXG4gIC8vICAgICAgVXRpbGl0aWVzXG4gIGNvbnN0IE1BWF9MSVNUX1NJWkUgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4gIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtcGxhaW4tb2JqZWN0XG4gIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG8pIHtcbiAgICByZXR1cm4gISFvICYmIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBvLmNvbnN0cnVjdG9yID09PSBPYmplY3RcbiAgfVxuXG4gIGNvbnN0IHN1cHBvcnRzRG9jdW1lbnRGcmFnbWVudCA9IG9wdGlvbnMuZG9jdW1lbnQgJiYgdHlwZW9mIG9wdGlvbnMuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJztcblxuICAvLyBHZXQgYSBjb3B5IG9mIHRoZSAocG9zc2libHkgdmlydHVhbCkgY2hpbGQgbm9kZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQsXG4gIC8vIHB1dCB0aGVtIGludG8gYSBjb250YWluZXIsIHRoZW4gZW1wdHkgdGhlIGdpdmVuIG5vZGUuXG4gIGZ1bmN0aW9uIG1ha2VUZW1wbGF0ZU5vZGUgKHNvdXJjZU5vZGUpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIHBhcmVudE5vZGU7XG4gICAgaWYgKHNvdXJjZU5vZGUuY29udGVudCkge1xuICAgICAgLy8gRm9yIGUuZy4gPHRlbXBsYXRlPiB0YWdzXG4gICAgICBwYXJlbnROb2RlID0gc291cmNlTm9kZS5jb250ZW50O1xuICAgIH0gZWxzZSBpZiAoc291cmNlTm9kZS50YWdOYW1lID09PSAnU0NSSVBUJykge1xuICAgICAgcGFyZW50Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcGFyZW50Tm9kZS5pbm5lckhUTUwgPSBzb3VyY2VOb2RlLnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFueXRoaW5nIGVsc2UgZS5nLiA8ZGl2PlxuICAgICAgcGFyZW50Tm9kZSA9IHNvdXJjZU5vZGU7XG4gICAgfVxuICAgIGFycmF5Rm9yRWFjaChjaGlsZE5vZGVzKHBhcmVudE5vZGUpLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIC8vIEZJWE1FIC0gVGhpcyBjbG9uZU5vZGUgY291bGQgYmUgZXhwZW5zaXZlOyB3ZSBtYXkgcHJlZmVyIHRvIGl0ZXJhdGUgb3ZlciB0aGVcbiAgICAgIC8vIHBhcmVudE5vZGUgY2hpbGRyZW4gaW4gcmV2ZXJzZSAoc28gYXMgbm90IHRvIGZvdWwgdGhlIGluZGV4ZXMgYXMgY2hpbGROb2RlcyBhcmVcbiAgICAgIC8vIHJlbW92ZWQgZnJvbSBwYXJlbnROb2RlIHdoZW4gaW5zZXJ0ZWQgaW50byB0aGUgY29udGFpbmVyKVxuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQuY2xvbmVOb2RlKHRydWUpLCBudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29udGFpbmVyXG4gIH1cblxuICAvLyBNaW1pYyBhIEtPIGNoYW5nZSBpdGVtICdhZGQnXG4gIGZ1bmN0aW9uIHZhbHVlVG9DaGFuZ2VBZGRJdGVtICh2YWx1ZSwgaW5kZXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAnYWRkZWQnLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfVxuICB9XG5cbiAgLy8gc3RvcmUgYSBzeW1ib2wgZm9yIGNhY2hpbmcgdGhlIHBlbmRpbmcgZGVsZXRlIGluZm8gaW5kZXggaW4gdGhlIGRhdGEgaXRlbSBvYmplY3RzXG4gIGNvbnN0IFBFTkRJTkdfREVMRVRFX0lOREVYX1NZTSA9IGNyZWF0ZVN5bWJvbE9yU3RyaW5nKCdfa29fZmZlX3BlbmRpbmdfZGVsZXRlX2luZGV4Jyk7XG5cblxuICBjbGFzcyBGb3JFYWNoQmluZGluZyBleHRlbmRzIEFzeW5jQmluZGluZ0hhbmRsZXIge1xuICAgIC8vIE5PVEU6IHZhbGlkIHZhbHVlQWNjZXNzb3JzIGluY2x1ZGU6XG4gICAgLy8gICAgW11cbiAgICAvLyAgICBvYnNlcnZhYmxlKFtdKVxuICAgIC8vICAgIG9ic2VydmFibGVBcnJheShbXSlcbiAgICAvLyAgICBjb21wdXRlZFxuICAgIC8vICAgIHtkYXRhOiBhcnJheSwgbmFtZTogc3RyaW5nLCBhczogc3RyaW5nfVxuXG4gICAgY29uc3RydWN0b3IgKHBhcmFtcykge1xuICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0ge307XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh0aGlzLnZhbHVlKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCB0aGlzLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcyA9IHNldHRpbmdzLmFzIHx8IHRoaXMuYWxsQmluZGluZ3MuZ2V0KCdhcycpO1xuXG4gICAgICB0aGlzLmRhdGEgPSBzZXR0aW5ncy5kYXRhIHx8ICh1bndyYXAodGhpcy4kY29udGV4dC4kcmF3RGF0YSkgPT09IHRoaXMudmFsdWUgPyB0aGlzLiRjb250ZXh0LiRyYXdEYXRhIDogdGhpcy52YWx1ZSk7XG5cbiAgICAgIHRoaXMuY29udGFpbmVyID0gaXNTdGFydENvbW1lbnQodGhpcy4kZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLiRlbGVtZW50LnBhcmVudE5vZGUgOiB0aGlzLiRlbGVtZW50O1xuICAgICAgdGhpcy5nZW5lcmF0ZUNvbnRleHQgPSB0aGlzLmNyZWF0ZUNvbnRleHRHZW5lcmF0b3IodGhpcy5hcyk7XG4gICAgICB0aGlzLiRpbmRleEhhc0JlZW5SZXF1ZXN0ZWQgPSBmYWxzZTtcblxuICAgICAgdGhpcy50ZW1wbGF0ZU5vZGUgPSBtYWtlVGVtcGxhdGVOb2RlKFxuICAgICAgICBzZXR0aW5ncy50ZW1wbGF0ZU5vZGUgfHwgKHNldHRpbmdzLm5hbWVcbiAgICAgICAgICA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNldHRpbmdzLm5hbWUpLmNsb25lTm9kZSh0cnVlKVxuICAgICAgICAgIDogdGhpcy4kZWxlbWVudClcbiAgICAgIClcblxuICAgICAgO1snYWZ0ZXJBZGQnLCAnYmVmb3JlUmVtb3ZlJywgJ2FmdGVyUXVldWVGbHVzaCcsICdiZWZvcmVRdWV1ZUZsdXNoJ11cbiAgICAgICAgLmZvckVhY2gocCA9PiB7IHRoaXNbcF0gPSBzZXR0aW5nc1twXSB8fCB0aGlzLmFsbEJpbmRpbmdzLmdldChwKTsgfSk7XG5cbiAgICAgIHRoaXMuY2hhbmdlUXVldWUgPSBbXTtcbiAgICAgIHRoaXMuZmlyc3RMYXN0Tm9kZXNMaXN0ID0gW107XG4gICAgICB0aGlzLmluZGV4ZXNUb0RlbGV0ZSA9IFtdO1xuICAgICAgdGhpcy5yZW5kZXJpbmdfcXVldWVkID0gZmFsc2U7XG4gICAgICB0aGlzLnBlbmRpbmdEZWxldGVzID0gW107XG5cbiAgICAgIC8vIEV4cG9zZSB0aGUgY29uZGl0aW9uYWwgc28gdGhhdCBpZiB0aGUgYGZvcmVhY2hgIGRhdGEgaXMgZW1wdHksIHN1Y2Nlc3NpdmVcbiAgICAgIC8vICdlbHNlJyBiaW5kaW5ncyB3aWxsIGFwcGVhci5cbiAgICAgIHRoaXMuaXNOb3RFbXB0eSA9IG9ic2VydmFibGUoQm9vbGVhbih1bndyYXAodGhpcy5kYXRhKS5sZW5ndGgpKTtcbiAgICAgIHNldCh0aGlzLiRlbGVtZW50LCAnY29uZGl0aW9uYWwnLCB7XG4gICAgICAgIGVsc2VDaGFpblNhdGlzZmllZDogdGhpcy5pc05vdEVtcHR5XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICBlbXB0eU5vZGUodGhpcy4kZWxlbWVudCk7XG5cbiAgICAgIC8vIFByaW1lIGNvbnRlbnRcbiAgICAgIGNvbnN0IHByaW1lRGF0YSA9IHVud3JhcCh0aGlzLmRhdGEpO1xuICAgICAgaWYgKHByaW1lRGF0YSAmJiBwcmltZURhdGEubWFwKSB7XG4gICAgICAgIHRoaXMub25BcnJheUNoYW5nZShwcmltZURhdGEubWFwKHZhbHVlVG9DaGFuZ2VBZGRJdGVtKSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlQmluZGluZygpO1xuICAgICAgfVxuXG4gICAgICAvLyBXYXRjaCBmb3IgY2hhbmdlc1xuICAgICAgaWYgKGlzT2JzZXJ2YWJsZSh0aGlzLmRhdGEpKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhLmluZGV4T2YpIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG9ic2VydmFibGUgaXMgdHJhY2thYmxlLlxuICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5leHRlbmQoeyB0cmFja0FycmF5Q2hhbmdlczogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5nZVN1YnMgPSB0aGlzLmRhdGEuc3Vic2NyaWJlKHRoaXMub25BcnJheUNoYW5nZSwgdGhpcywgJ2FycmF5Q2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGlzcG9zZSAoKSB7XG4gICAgICBpZiAodGhpcy5jaGFuZ2VTdWJzKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlU3Vicy5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZsdXNoUGVuZGluZ0RlbGV0ZXMoKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYXJyYXkgY2hhbmdlcyB3ZSByZWdpc3RlciB0aGUgY2hhbmdlLlxuICAgIG9uQXJyYXlDaGFuZ2UgKGNoYW5nZVNldCwgaXNJbml0aWFsJCQxKSB7XG4gICAgICB2YXIgY2hhbmdlTWFwID0ge1xuICAgICAgICBhZGRlZDogW10sXG4gICAgICAgIGRlbGV0ZWQ6IFtdXG4gICAgICB9O1xuXG4gICAgICAvLyBrbm9ja291dCBhcnJheSBjaGFuZ2Ugbm90aWZpY2F0aW9uIGluZGV4IGhhbmRsaW5nOlxuICAgICAgLy8gLSBzZW5kcyB0aGUgb3JpZ2luYWwgYXJyYXkgaW5kZXhlcyBmb3IgZGVsZXRlc1xuICAgICAgLy8gLSBzZW5kcyB0aGUgbmV3IGFycmF5IGluZGV4ZXMgZm9yIGFkZHNcbiAgICAgIC8vIC0gc29ydHMgdGhlbSBhbGwgYnkgaW5kZXggaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICAvLyBiZWNhdXNlIG9mIHRoaXMsIHdoZW4gY2hlY2tpbmcgZm9yIHBvc3NpYmxlIGJhdGNoIGFkZGl0aW9ucywgYW55IGRlbGV0ZSBjYW4gYmUgYmV0d2VlbiB0byBhZGRzIHdpdGggbmVpZ2hib3JpbmcgaW5kZXhlcywgc28gb25seSBhZGRpdGlvbnMgc2hvdWxkIGJlIGNoZWNrZWRcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGFuZ2VTZXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGNoYW5nZU1hcC5hZGRlZC5sZW5ndGggJiYgY2hhbmdlU2V0W2ldLnN0YXR1cyA9PT0gJ2FkZGVkJykge1xuICAgICAgICAgIHZhciBsYXN0QWRkID0gY2hhbmdlTWFwLmFkZGVkW2NoYW5nZU1hcC5hZGRlZC5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gbGFzdEFkZC5pc0JhdGNoID8gbGFzdEFkZC5pbmRleCArIGxhc3RBZGQudmFsdWVzLmxlbmd0aCAtIDEgOiBsYXN0QWRkLmluZGV4O1xuICAgICAgICAgIGlmIChsYXN0SW5kZXggKyAxID09PSBjaGFuZ2VTZXRbaV0uaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghbGFzdEFkZC5pc0JhdGNoKSB7XG4gICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0aGUgbGFzdCBhZGRpdGlvbiBpbnRvIGEgYmF0Y2ggYWRkaXRpb24gb2JqZWN0XG4gICAgICAgICAgICAgIGxhc3RBZGQgPSB7XG4gICAgICAgICAgICAgICAgaXNCYXRjaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdhZGRlZCcsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGxhc3RBZGQuaW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiBbbGFzdEFkZC52YWx1ZV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY2hhbmdlTWFwLmFkZGVkLnNwbGljZShjaGFuZ2VNYXAuYWRkZWQubGVuZ3RoIC0gMSwgMSwgbGFzdEFkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0QWRkLnZhbHVlcy5wdXNoKGNoYW5nZVNldFtpXS52YWx1ZSk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZU1hcFtjaGFuZ2VTZXRbaV0uc3RhdHVzXS5wdXNoKGNoYW5nZVNldFtpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VNYXAuZGVsZXRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlUXVldWUucHVzaC5hcHBseSh0aGlzLmNoYW5nZVF1ZXVlLCBjaGFuZ2VNYXAuZGVsZXRlZCk7XG4gICAgICAgIHRoaXMuY2hhbmdlUXVldWUucHVzaCh7IHN0YXR1czogJ2NsZWFyRGVsZXRlZEluZGV4ZXMnIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoYW5nZVF1ZXVlLnB1c2guYXBwbHkodGhpcy5jaGFuZ2VRdWV1ZSwgY2hhbmdlTWFwLmFkZGVkKTtcbiAgICAgIC8vIE9uY2UgYSBjaGFuZ2UgaXMgcmVnaXN0ZXJlZCwgdGhlIHRpY2tpbmcgY291bnQtZG93biBzdGFydHMgZm9yIHRoZSBwcm9jZXNzUXVldWUuXG4gICAgICBpZiAodGhpcy5jaGFuZ2VRdWV1ZS5sZW5ndGggPiAwICYmICF0aGlzLnJlbmRlcmluZ19xdWV1ZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdfcXVldWVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzSW5pdGlhbCQkMSkge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRm9yRWFjaEJpbmRpbmcuYW5pbWF0ZUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB0aGlzLnByb2Nlc3NRdWV1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXJ0UXVldWVGbHVzaCAoKSB7XG4gICAgICAvLyBDYWxsYmFjayBzbyBmb2xrcyBjYW4gZG8gdGhpbmdzIGJlZm9yZSB0aGUgcXVldWUgZmx1c2guXG4gICAgICBpZiAodHlwZW9mIHRoaXMuYmVmb3JlUXVldWVGbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmJlZm9yZVF1ZXVlRmx1c2godGhpcy5jaGFuZ2VRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZW5kUXVldWVGbHVzaCAoKSB7XG4gICAgICAvLyBDYWxsYmFjayBzbyBmb2xrcyBjYW4gZG8gdGhpbmdzLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmFmdGVyUXVldWVGbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmFmdGVyUXVldWVGbHVzaCh0aGlzLmNoYW5nZVF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWZsZWN0IGFsbCB0aGUgY2hhbmdlcyBpbiB0aGUgcXVldWUgaW4gdGhlIERPTSwgdGhlbiB3aXBlIHRoZSBxdWV1ZS5cbiAgICBwcm9jZXNzUXVldWUgKCkge1xuICAgICAgdmFyIGlzRW1wdHkgPSAhdW53cmFwKHRoaXMuZGF0YSkubGVuZ3RoO1xuICAgICAgdmFyIGxvd2VzdEluZGV4Q2hhbmdlZCA9IE1BWF9MSVNUX1NJWkU7XG5cbiAgICAgIHRoaXMuc3RhcnRRdWV1ZUZsdXNoKCk7XG5cbiAgICAgIGFycmF5Rm9yRWFjaCh0aGlzLmNoYW5nZVF1ZXVlLCAoY2hhbmdlSXRlbSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNoYW5nZUl0ZW0uaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgbG93ZXN0SW5kZXhDaGFuZ2VkID0gTWF0aC5taW4obG93ZXN0SW5kZXhDaGFuZ2VkLCBjaGFuZ2VJdGVtLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2NoYW5nZUl0ZW0uc3RhdHVzXShjaGFuZ2VJdGVtKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mbHVzaFBlbmRpbmdEZWxldGVzKCk7XG4gICAgICB0aGlzLnJlbmRlcmluZ19xdWV1ZWQgPSBmYWxzZTtcblxuICAgICAgLy8gVXBkYXRlIG91ciBpbmRleGVzLlxuICAgICAgaWYgKHRoaXMuJGluZGV4SGFzQmVlblJlcXVlc3RlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUluZGV4ZXMobG93ZXN0SW5kZXhDaGFuZ2VkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbmRRdWV1ZUZsdXNoKCk7XG4gICAgICB0aGlzLmNoYW5nZVF1ZXVlID0gW107XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgY29uZGl0aW9uYWwgZXhwb3NlZCBvbiB0aGUgZG9tRGF0YVxuICAgICAgaWYgKGlzRW1wdHkgIT09ICF0aGlzLmlzTm90RW1wdHkoKSkge1xuICAgICAgICB0aGlzLmlzTm90RW1wdHkoIWlzRW1wdHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uY2UgdGhlICRpbmRleCBoYXMgYmVlbiBhc2tlZCBmb3Igb25jZSwgc3RhcnQgY2FsY3VsYXRpbmcgaXQuXG4gICAgICogTm90ZSB0aGF0IHRoaXMgc2lnbmlmaWNhbnRseSBkZWdyYWRlcyBwZXJmb3JtYW5jZSwgZnJvbSBPKDEpIHRvIE8obilcbiAgICAgKiBmb3IgYXJiaXRyYXJ5IGNoYW5nZXMgdG8gdGhlIGxpc3QuXG4gICAgICovXG4gICAgX2ZpcnN0JGluZGV4UmVxdWVzdCAoY3R4JGluZGV4UmVxdWVzdGVkRnJvbSkge1xuICAgICAgdGhpcy4kaW5kZXhIYXNCZWVuUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmZpcnN0TGFzdE5vZGVzTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmdldENvbnRleHRTdGFydGluZ0Zyb20odGhpcy5maXJzdExhc3ROb2Rlc0xpc3RbaV0uZmlyc3QpO1xuICAgICAgICAvLyBPdmVyd3JpdGUgdGhlIGRlZmluZVByb3BlcnR5LlxuICAgICAgICBpZiAoY3R4KSB7IGN0eC4kaW5kZXggPSBvYnNlcnZhYmxlKGkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4JGluZGV4UmVxdWVzdGVkRnJvbS4kaW5kZXgoKVxuICAgIH1cblxuICAgIF9jb250ZXh0RXh0ZW5zaW9ucyAoJGN0eCkge1xuICAgICAgT2JqZWN0LmFzc2lnbigkY3R4LCB7ICRsaXN0OiB0aGlzLmRhdGEgfSk7XG4gICAgICBpZiAodGhpcy4kaW5kZXhIYXNCZWVuUmVxdWVzdGVkKSB7XG4gICAgICAgICRjdHguJGluZGV4ID0gJGN0eC4kaW5kZXggfHwgb2JzZXJ2YWJsZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCRjdHgsICckaW5kZXgnLCB7XG4gICAgICAgICAgdmFsdWU6ICgpID0+IHRoaXMuX2ZpcnN0JGluZGV4UmVxdWVzdCgkY3R4KSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJGN0eFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIHRoZSBjb250ZXh0IGZvciBhIGdpdmVuIG5vZGUuXG4gICAgICpcbiAgICAgKiBXZSBnZW5lcmF0ZSBhIHNpbmdsZSBmdW5jdGlvbiB0aGF0IHJlZHVjZXMgb3VyIGlubmVyLWxvb3AgY2FsY3VsYXRpb25zLFxuICAgICAqIHdoaWNoIGhhcyBhIGdvb2QgY2hhbmNlIG9mIGJlaW5nIG9wdGltaXplZCBieSB0aGUgYnJvd3Nlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gYXMgIFRoZSBuYW1lIGdpdmVuIHRvIGVhY2ggaXRlbSBpbiB0aGUgbGlzdFxuICAgICAqIEBwYXJhbSAge2Jvb2x9IGluZGV4IFdoZXRoZXIgdG8gY2FsY3VsYXRlIGluZGV4ZXNcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gICBBIGZ1bmN0aW9uKGRhdGFWYWx1ZSkgdGhhdCByZXR1cm5zIHRoZSBjb250ZXh0XG4gICAgICovXG4gICAgY3JlYXRlQ29udGV4dEdlbmVyYXRvciAoYXMpIHtcbiAgICAgIGNvbnN0ICRjdHggPSB0aGlzLiRjb250ZXh0O1xuICAgICAgaWYgKGFzKSB7XG4gICAgICAgIHJldHVybiB2ID0+IHRoaXMuX2NvbnRleHRFeHRlbnNpb25zKCRjdHguZXh0ZW5kKHsgW2FzXTogdiB9KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2ID0+ICRjdHguY3JlYXRlQ2hpbGRDb250ZXh0KHYsIG51bGwsIGN0eCA9PiB0aGlzLl9jb250ZXh0RXh0ZW5zaW9ucyhjdHgpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUZpcnN0TGFzdE5vZGVzTGlzdCAoaW5kZXgsIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBmaXJzdCA9IGNoaWxkcmVuWzBdO1xuICAgICAgY29uc3QgbGFzdCA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgdGhpcy5maXJzdExhc3ROb2Rlc0xpc3Quc3BsaWNlKGluZGV4LCAwLCB7IGZpcnN0LCBsYXN0IH0pO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYSBjaGFuZ2VJdGVtIHdpdGgge3N0YXR1czogJ2FkZGVkJywgLi4ufVxuICAgIGFkZGVkIChjaGFuZ2VJdGVtKSB7XG4gICAgICB2YXIgaW5kZXggPSBjaGFuZ2VJdGVtLmluZGV4O1xuICAgICAgdmFyIHZhbHVlc1RvQWRkID0gY2hhbmdlSXRlbS5pc0JhdGNoID8gY2hhbmdlSXRlbS52YWx1ZXMgOiBbY2hhbmdlSXRlbS52YWx1ZV07XG4gICAgICB2YXIgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuZ2V0TGFzdE5vZGVCZWZvcmVJbmRleChpbmRleCk7XG4gICAgICAvLyBnYXRoZXIgYWxsIGNoaWxkbm9kZXMgZm9yIGEgcG9zc2libGUgYmF0Y2ggaW5zZXJ0aW9uXG4gICAgICBjb25zdCBhbGxDaGlsZE5vZGVzID0gW107XG4gICAgICBjb25zdCBhc3luY0JpbmRpbmdSZXN1bHRzID0gW107XG4gICAgICB2YXIgY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXNUb0FkZC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAvLyB3ZSBjaGVjayBpZiB3ZSBoYXZlIGEgcGVuZGluZyBkZWxldGUgd2l0aCByZXVzYWJsZSBub2Rlc2V0cyBmb3IgdGhpcyBkYXRhLCBhbmQgaWYgeWVzLCB3ZSByZXVzZSBvbmUgbm9kZXNldFxuICAgICAgICB2YXIgcGVuZGluZ0RlbGV0ZSA9IHRoaXMuZ2V0UGVuZGluZ0RlbGV0ZUZvcih2YWx1ZXNUb0FkZFtpXSk7XG4gICAgICAgIGlmIChwZW5kaW5nRGVsZXRlICYmIHBlbmRpbmdEZWxldGUubm9kZXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgY2hpbGRyZW4gPSBwZW5kaW5nRGVsZXRlLm5vZGVzZXRzLnBvcCgpO1xuICAgICAgICAgIHRoaXMudXBkYXRlRmlyc3RMYXN0Tm9kZXNMaXN0KGluZGV4ICsgaSwgY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0ZW1wbGF0ZUNsb25lID0gdGhpcy50ZW1wbGF0ZU5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGROb2Rlcyh0ZW1wbGF0ZUNsb25lKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUZpcnN0TGFzdE5vZGVzTGlzdChpbmRleCArIGksIGNoaWxkcmVuKTtcblxuICAgICAgICAgIC8vIEFwcGx5IGJpbmRpbmdzIGZpcnN0LCBhbmQgdGhlbiBwcm9jZXNzIGNoaWxkIG5vZGVzLFxuICAgICAgICAgIC8vIGJlY2F1c2UgYmluZGluZ3MgY2FuIGFkZCBjaGlsZG5vZGVzLlxuICAgICAgICAgIGNvbnN0IGJpbmRpbmdSZXN1bHQgPSBhcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50cyhcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVDb250ZXh0KHZhbHVlc1RvQWRkW2ldKSwgdGVtcGxhdGVDbG9uZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYXN5bmNCaW5kaW5nUmVzdWx0cy5wdXNoKGJpbmRpbmdSZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWxsQ2hpbGROb2Rlcy5wdXNoKC4uLmNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmFmdGVyQWRkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuYWZ0ZXJBZGQoe1xuICAgICAgICAgIG5vZGVPckFycmF5SW5zZXJ0ZWQ6IHRoaXMuaW5zZXJ0QWxsQWZ0ZXIoYWxsQ2hpbGROb2RlcywgcmVmZXJlbmNlRWxlbWVudCksXG4gICAgICAgICAgZm9yZWFjaEluc3RhbmNlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnNlcnRBbGxBZnRlcihhbGxDaGlsZE5vZGVzLCByZWZlcmVuY2VFbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21wbGV0ZUJpbmRpbmcoUHJvbWlzZS5hbGwoYXN5bmNCaW5kaW5nUmVzdWx0cykpO1xuICAgIH1cblxuICAgIGdldE5vZGVzRm9ySW5kZXggKGluZGV4KSB7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBsZXQgcHRyID0gdGhpcy5maXJzdExhc3ROb2Rlc0xpc3RbaW5kZXhdLmZpcnN0O1xuICAgICAgbGV0IGxhc3QgPSB0aGlzLmZpcnN0TGFzdE5vZGVzTGlzdFtpbmRleF0ubGFzdDtcbiAgICAgIHJlc3VsdC5wdXNoKHB0cik7XG4gICAgICB3aGlsZSAocHRyICYmIHB0ciAhPT0gbGFzdCkge1xuICAgICAgICBwdHIgPSBwdHIubmV4dFNpYmxpbmc7XG4gICAgICAgIHJlc3VsdC5wdXNoKHB0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgZ2V0TGFzdE5vZGVCZWZvcmVJbmRleCAoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA8IDEgfHwgaW5kZXggLSAxID49IHRoaXMuZmlyc3RMYXN0Tm9kZXNMaXN0Lmxlbmd0aCkgeyByZXR1cm4gbnVsbCB9XG4gICAgICByZXR1cm4gdGhpcy5maXJzdExhc3ROb2Rlc0xpc3RbaW5kZXggLSAxXS5sYXN0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhY3RpdmUgKGZvY3VzZWQpIG5vZGUsIGlmIGl0J3MgYSBjaGlsZCBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKi9cbiAgICBhY3RpdmVDaGlsZEVsZW1lbnQgKG5vZGUpIHtcbiAgICAgIHZhciBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKGRvbU5vZGVJc0NvbnRhaW5lZEJ5KGFjdGl2ZSwgbm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc2VydEFsbEFmdGVyIChub2RlT3JOb2RlQXJyYXlUb0luc2VydCwgaW5zZXJ0QWZ0ZXJOb2RlKSB7XG4gICAgICBsZXQgZnJhZztcbiAgICAgIGxldCBsZW47XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBhY3RpdmUgPSBudWxsO1xuICAgICAgbGV0IGNvbnRhaW5lck5vZGUgPSB0aGlzLiRlbGVtZW50O1xuXG4gICAgICAvLyBQb29yIG1hbidzIG5vZGUgYW5kIGFycmF5IGNoZWNrLlxuICAgICAgaWYgKG5vZGVPck5vZGVBcnJheVRvSW5zZXJ0Lm5vZGVUeXBlID09PSB1bmRlZmluZWQgJiYgbm9kZU9yTm9kZUFycmF5VG9JbnNlcnQubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHNpbmdsZSBub2RlIG9yIGEgbm9kZSBhcnJheScpXG4gICAgICB9XG4gICAgICBpZiAobm9kZU9yTm9kZUFycmF5VG9JbnNlcnQubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhY3RpdmUgPSB0aGlzLmFjdGl2ZUNoaWxkRWxlbWVudChub2RlT3JOb2RlQXJyYXlUb0luc2VydCk7XG4gICAgICAgIGluc2VydEFmdGVyKGNvbnRhaW5lck5vZGUsIG5vZGVPck5vZGVBcnJheVRvSW5zZXJ0LCBpbnNlcnRBZnRlck5vZGUpO1xuICAgICAgICByZXR1cm4gW25vZGVPck5vZGVBcnJheVRvSW5zZXJ0XVxuICAgICAgfSBlbHNlIGlmIChub2RlT3JOb2RlQXJyYXlUb0luc2VydC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYWN0aXZlID0gdGhpcy5hY3RpdmVDaGlsZEVsZW1lbnQobm9kZU9yTm9kZUFycmF5VG9JbnNlcnRbMF0pO1xuICAgICAgICBpbnNlcnRBZnRlcihjb250YWluZXJOb2RlLCBub2RlT3JOb2RlQXJyYXlUb0luc2VydFswXSwgaW5zZXJ0QWZ0ZXJOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydHNEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGVPck5vZGVBcnJheVRvSW5zZXJ0Lmxlbmd0aDsgaSAhPT0gbGVuOyArK2kpIHtcbiAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUgfHwgdGhpcy5hY3RpdmVDaGlsZEVsZW1lbnQobm9kZU9yTm9kZUFycmF5VG9JbnNlcnRbaV0pO1xuICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZU9yTm9kZUFycmF5VG9JbnNlcnRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydEFmdGVyKGNvbnRhaW5lck5vZGUsIGZyYWcsIGluc2VydEFmdGVyTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb2RlcyBhcmUgaW5zZXJ0ZWQgaW4gcmV2ZXJzZSBvcmRlciAtIHB1c2hlZCBkb3duIGltbWVkaWF0ZWx5IGFmdGVyXG4gICAgICAgIC8vIHRoZSBsYXN0IG5vZGUgZm9yIHRoZSBwcmV2aW91cyBpdGVtIG9yIGFzIHRoZSBmaXJzdCBub2RlIG9mIGVsZW1lbnQuXG4gICAgICAgIGZvciAoaSA9IG5vZGVPck5vZGVBcnJheVRvSW5zZXJ0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgYWN0aXZlID0gYWN0aXZlIHx8IHRoaXMuYWN0aXZlQ2hpbGRFbGVtZW50KG5vZGVPck5vZGVBcnJheVRvSW5zZXJ0W2ldKTtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlT3JOb2RlQXJyYXlUb0luc2VydFtpXTtcbiAgICAgICAgICBpZiAoIWNoaWxkKSB7IGJyZWFrIH1cbiAgICAgICAgICBpbnNlcnRBZnRlcihjb250YWluZXJOb2RlLCBjaGlsZCwgaW5zZXJ0QWZ0ZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlKSB7IGFjdGl2ZS5mb2N1cygpOyB9XG5cbiAgICAgIHJldHVybiBub2RlT3JOb2RlQXJyYXlUb0luc2VydFxuICAgIH1cblxuICAgIC8vIGNoZWNrcyBpZiB0aGUgZGVsZXRlZCBkYXRhIGl0ZW0gc2hvdWxkIGJlIGhhbmRsZWQgd2l0aCBkZWxheSBmb3IgYSBwb3NzaWJsZSByZXVzZSBhdCBhZGRpdGlvbnNcbiAgICBzaG91bGREZWxheURlbGV0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gZGF0YSAmJiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKVxuICAgIH1cblxuICAgIC8vIGdldHMgdGhlIHBlbmRpbmcgZGVsZXRpb24gaW5mbyBmb3IgdGhpcyBkYXRhIGl0ZW1cbiAgICBnZXRQZW5kaW5nRGVsZXRlRm9yIChkYXRhKSB7XG4gICAgICB2YXIgaW5kZXggPSBkYXRhICYmIGRhdGFbUEVORElOR19ERUxFVEVfSU5ERVhfU1lNXTtcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbFxuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0RlbGV0ZXNbaW5kZXhdXG4gICAgfVxuXG4gICAgLy8gdHJpZXMgdG8gZmluZCB0aGUgZXhpc3RpbmcgcGVuZGluZyBkZWxldGUgaW5mbyBmb3IgdGhpcyBkYXRhIGl0ZW0sIGFuZCBpZiBpdCBjYW4ndCwgaXQgcmVnaXN0ZXJlcyBvbmVcbiAgICBnZXRPckNyZWF0ZVBlbmRpbmdEZWxldGVGb3IgKGRhdGEpIHtcbiAgICAgIHZhciBwZCA9IHRoaXMuZ2V0UGVuZGluZ0RlbGV0ZUZvcihkYXRhKTtcbiAgICAgIGlmIChwZCkge1xuICAgICAgICByZXR1cm4gcGRcbiAgICAgIH1cbiAgICAgIHBkID0ge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBub2Rlc2V0czogW11cbiAgICAgIH07XG4gICAgICBkYXRhW1BFTkRJTkdfREVMRVRFX0lOREVYX1NZTV0gPSB0aGlzLnBlbmRpbmdEZWxldGVzLmxlbmd0aDtcbiAgICAgIHRoaXMucGVuZGluZ0RlbGV0ZXMucHVzaChwZCk7XG4gICAgICByZXR1cm4gcGRcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGEgY2hhbmdlSXRlbSB3aXRoIHtzdGF0dXM6ICdkZWxldGVkJywgLi4ufVxuICAgIGRlbGV0ZWQgKGNoYW5nZUl0ZW0pIHtcbiAgICAgIC8vIGlmIHdlIHNob3VsZCBkZWxheSB0aGUgZGVsZXRpb24gb2YgdGhpcyBkYXRhLCB3ZSBhZGQgdGhlIG5vZGVzZXQgdG8gdGhlIHBlbmRpbmcgZGVsZXRlIGluZm8gb2JqZWN0XG4gICAgICBpZiAodGhpcy5zaG91bGREZWxheURlbGV0aW9uKGNoYW5nZUl0ZW0udmFsdWUpKSB7XG4gICAgICAgIGxldCBwZCA9IHRoaXMuZ2V0T3JDcmVhdGVQZW5kaW5nRGVsZXRlRm9yKGNoYW5nZUl0ZW0udmFsdWUpO1xuICAgICAgICBwZC5ub2Rlc2V0cy5wdXNoKHRoaXMuZ2V0Tm9kZXNGb3JJbmRleChjaGFuZ2VJdGVtLmluZGV4KSk7XG4gICAgICB9IGVsc2UgeyAvLyBzaW1wbGUgZGF0YSwganVzdCByZW1vdmUgdGhlIG5vZGVzXG4gICAgICAgIHRoaXMucmVtb3ZlTm9kZXModGhpcy5nZXROb2Rlc0ZvckluZGV4KGNoYW5nZUl0ZW0uaW5kZXgpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5kZXhlc1RvRGVsZXRlLnB1c2goY2hhbmdlSXRlbS5pbmRleCk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlcyBhIHNldCBvZiBub2RlcyBmcm9tIHRoZSBET01cbiAgICByZW1vdmVOb2RlcyAobm9kZXMpIHtcbiAgICAgIGlmICghbm9kZXMubGVuZ3RoKSB7IHJldHVybiB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUZuICgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVzWzBdLnBhcmVudE5vZGU7XG4gICAgICAgIGZvciAodmFyIGkgPSBub2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgIGNsZWFuTm9kZShub2Rlc1tpXSk7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5iZWZvcmVSZW1vdmUpIHtcbiAgICAgICAgdmFyIGJlZm9yZVJlbW92ZVJldHVybiA9IHRoaXMuYmVmb3JlUmVtb3ZlKHtcbiAgICAgICAgICBub2Rlc1RvUmVtb3ZlOiBub2RlcywgZm9yZWFjaEluc3RhbmNlOiB0aGlzXG4gICAgICAgIH0pIHx8IHt9O1xuICAgICAgICAvLyBJZiBiZWZvcmVSZW1vdmUgcmV0dXJucyBhIGB0aGVuYOKAk2FibGUgZS5nLiBhIFByb21pc2UsIHdlIHJlbW92ZVxuICAgICAgICAvLyB0aGUgbm9kZXMgd2hlbiB0aGF0IHRoZW5hYmxlIGNvbXBsZXRlcy4gIFdlIHBhc3MgYW55IGVycm9ycyB0b1xuICAgICAgICAvLyBrby5vbkVycm9yLlxuICAgICAgICBpZiAodHlwZW9mIGJlZm9yZVJlbW92ZVJldHVybi50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYmVmb3JlUmVtb3ZlUmV0dXJuLnRoZW4ocmVtb3ZlRm4sIG9wdGlvbnMub25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUZuKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmx1c2hlcyB0aGUgcGVuZGluZyBkZWxldGUgaW5mbyBzdG9yZVxuICAgIC8vIHRoaXMgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBxdWV1ZSBwcm9jZXNzaW5nIGhhcyBmaW5pc2hlZCwgc28gdGhhdCBkYXRhIGl0ZW1zIGFuZCByZW1haW5pbmcgKG5vdCByZXVzZWQpIG5vZGVzZXRzIGdldCBjbGVhbmVkIHVwXG4gICAgLy8gd2UgYWxzbyBjYWxsIGl0IG9uIGRpc3Bvc2Ugbm90IHRvIGxlYXZlIGFueSBtZXNzXG4gICAgZmx1c2hQZW5kaW5nRGVsZXRlcyAoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5wZW5kaW5nRGVsZXRlcy5sZW5ndGg7IGkgIT09IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBwZCA9IHRoaXMucGVuZGluZ0RlbGV0ZXNbaV07XG4gICAgICAgIHdoaWxlIChwZC5ub2Rlc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVzKHBkLm5vZGVzZXRzLnBvcCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGQuZGF0YSAmJiBwZC5kYXRhW1BFTkRJTkdfREVMRVRFX0lOREVYX1NZTV0gIT09IHVuZGVmaW5lZCkgeyBkZWxldGUgcGQuZGF0YVtQRU5ESU5HX0RFTEVURV9JTkRFWF9TWU1dOyB9XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdEZWxldGVzID0gW107XG4gICAgfVxuXG4gICAgLy8gV2UgYmF0Y2ggb3VyIGRlbGV0aW9uIG9mIGl0ZW0gaW5kZXhlcyBpbiBvdXIgcGFyYWxsZWwgYXJyYXkuXG4gICAgLy8gU2VlIGJyaWFubWh1bnQva25vY2tvdXQtZmFzdC1mb3JlYWNoIzYvIzhcbiAgICBjbGVhckRlbGV0ZWRJbmRleGVzICgpIHtcbiAgICAgIC8vIFdlIGl0ZXJhdGUgaW4gcmV2ZXJzZSBvbiB0aGUgcHJlc3VtcHRpb24gKGZvbGxvd2luZyB0aGUgdW5pdCB0ZXN0cykgdGhhdCBLTydzIGRpZmYgZW5naW5lXG4gICAgICAvLyBwcm9jZXNzZXMgZGlmZnMgKGVzcC4gZGVsZXRlcykgbW9ub3RvbmljYWxseSBhc2NlbmRpbmcgaS5lLiBmcm9tIGluZGV4IDAgLT4gTi5cbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4ZXNUb0RlbGV0ZS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB0aGlzLmZpcnN0TGFzdE5vZGVzTGlzdC5zcGxpY2UodGhpcy5pbmRleGVzVG9EZWxldGVbaV0sIDEpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbmRleGVzVG9EZWxldGUgPSBbXTtcbiAgICB9XG5cbiAgICB1cGRhdGVJbmRleGVzIChmcm9tSW5kZXgpIHtcbiAgICAgIGxldCBjdHg7XG4gICAgICBmb3IgKGxldCBpID0gZnJvbUluZGV4LCBsZW4gPSB0aGlzLmZpcnN0TGFzdE5vZGVzTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBjdHggPSB0aGlzLmdldENvbnRleHRTdGFydGluZ0Zyb20odGhpcy5maXJzdExhc3ROb2Rlc0xpc3RbaV0uZmlyc3QpO1xuICAgICAgICBpZiAoY3R4KSB7IGN0eC4kaW5kZXgoaSk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDb250ZXh0U3RhcnRpbmdGcm9tIChub2RlKSB7XG4gICAgICBsZXQgY3R4O1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgY3R4ID0gY29udGV4dEZvcihub2RlKTtcbiAgICAgICAgaWYgKGN0eCkgeyByZXR1cm4gY3R4IH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdGhlIGJpbmRpbmcgaXMgYWx3YXlzIHN5bmNocm9ub3VzLlxuICAgICAqIFVzZWZ1bCBkdXJpbmcgdGVzdGluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0U3luYyAodG9nZ2xlKSB7XG4gICAgICBjb25zdCB3ID0gb3B0aW9ucy5nbG9iYWw7XG4gICAgICBpZiAodG9nZ2xlKSB7XG4gICAgICAgIEZvckVhY2hCaW5kaW5nLmFuaW1hdGVGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZSkgeyBmcmFtZSgpOyB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRm9yRWFjaEJpbmRpbmcuYW5pbWF0ZUZyYW1lID0gdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICB3Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgZnVuY3Rpb24gKGNiKSB7IHJldHVybiB3LnNldFRpbWVvdXQoY2IsIDEwMDAgLyA2MCkgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY29udHJvbHNEZXNjZW5kYW50cyAoKSB7IHJldHVybiB0cnVlIH1cbiAgICBzdGF0aWMgZ2V0IGFsbG93VmlydHVhbEVsZW1lbnRzICgpIHsgcmV0dXJuIHRydWUgfVxuXG4gICAgLyogVE9ETzogUmVtb3ZlOyBmb3IgbGVnYWN5L3Rlc3RpbmcgKi9cbiAgICBzdGF0aWMgZ2V0IEZvckVhY2ggKCkgeyByZXR1cm4gdGhpcyB9XG4gICAgc3RhdGljIGdldCBQRU5ESU5HX0RFTEVURV9JTkRFWF9TWU0gKCkgeyByZXR1cm4gUEVORElOR19ERUxFVEVfSU5ERVhfU1lNIH1cbiAgfVxuXG4gIHZhciBiaW5kaW5ncyQzID0ge1xuICAgIGZvcmVhY2g6IEZvckVhY2hCaW5kaW5nXG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgZm9yZWFjaCB3aWxsIGJlIGFzeW5jLlxuICBGb3JFYWNoQmluZGluZy5zZXRTeW5jKGZhbHNlKTtcblxuICBjb25zdCBERUxBWV9NUyA9IDI1O1xuICBjb25zdCBNQVhfQ0xFQU5fQVRfT05DRSA9IDEwMDA7XG4gIGNvbnN0IGNsZWFuTm9kZVF1ZXVlID0gW107XG4gIGxldCBjbGVhbk5vZGVUaW1lb3V0SUQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHF1ZXVlQ2xlYW5Ob2RlIChub2RlKSB7XG4gICAgY2xlYW5Ob2RlUXVldWUucHVzaChub2RlKTtcbiAgICB0cmlnZ2VyQ2xlYW5UaW1lb3V0KCk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmlnZ2VyQ2xlYW5UaW1lb3V0ICgpIHtcbiAgICBpZiAoIWNsZWFuTm9kZVRpbWVvdXRJRCAmJiBjbGVhbk5vZGVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNsZWFuTm9kZVRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZmx1c2hDbGVhblF1ZXVlLCBERUxBWV9NUyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hDbGVhblF1ZXVlICgpIHtcbiAgICBjbGVhbk5vZGVUaW1lb3V0SUQgPSBudWxsO1xuICAgIGNvbnN0IG5vZGVzID0gY2xlYW5Ob2RlUXVldWUuc3BsaWNlKDAsIE1BWF9DTEVBTl9BVF9PTkNFKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHsgY2xlYW5Ob2RlKG5vZGUpOyB9XG4gICAgdHJpZ2dlckNsZWFuVGltZW91dCgpO1xuICB9XG5cbiAgY29uc3QgT1JJR0lOQUxfSlNYX1NZTSA9IFN5bWJvbCgnS25vY2tvdXQgLSBPcmlnaW5hbCBKU1gnKTtcblxuICBjb25zdCBOQU1FU1BBQ0VTID0ge1xuICAgIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICBodG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsXG4gICAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJyxcbiAgICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgIHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNJdGVyYWJsZSAodikge1xuICAgIHJldHVybiB2ICYmIHR5cGVvZiB2W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbidcbiAgfVxuXG4gIC8qKlxuICAgKiBKU1ggb2JqZWN0IGZyb20gYSBwcmUtcHJvY2Vzc29yLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBKU1hcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGVsZW1lbnROYW1lIGJlY29tZXMgdGhlIGB0YWdOYW1lYFxuICAgKiBAcHJvcGVydHkge0FycmF5LjxKU1g+fSBjaGlsZHJlblxuICAgKiBAcHJvcGVydHkge29iamVjdH0gYXR0cmlidXRlc1xuICAgKi9cblxuICAvKipcbiAgICogT2JzZXJ2ZSBhIHZhcmlldHkgb2YgcG9zc2libGUgY2FzZXMgZnJvbSBKU1gsIG1vZGlmeWluZyB0aGVcbiAgICogYHBhcmVudE5vZGVgIGF0IGBpbnNlcnRCZWZvcmVgIHdpdGggdGhlIHJlc3VsdC5cbiAgICovXG4gIGNsYXNzIEpzeE9ic2VydmVyIGV4dGVuZHMgTGlmZUN5Y2xlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0ganN4T3JPYnNlcnZhYmxlIHRha2UgYSBsb25nIGxpc3Qgb2YgcGVybXV0YXRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKGpzeE9yT2JzZXJ2YWJsZSwgcGFyZW50Tm9kZSwgaW5zZXJ0QmVmb3JlID0gbnVsbCwgeG1sbnMsIG5vSW5pdGlhbEJpbmRpbmcpIHtcbiAgICAgIHN1cGVyKCk7XG5cbiAgICAgIGNvbnN0IHBhcmVudE5vZGVJc0NvbW1lbnQgPSBwYXJlbnROb2RlLm5vZGVUeXBlID09PSA4O1xuXG4gICAgICBjb25zdCBwYXJlbnROb2RlVGFyZ2V0ID0gdGhpcy5nZXRQYXJlbnRUYXJnZXQocGFyZW50Tm9kZSk7XG5cbiAgICAgIGlmIChpc09ic2VydmFibGUoanN4T3JPYnNlcnZhYmxlKSkge1xuICAgICAgICBqc3hPck9ic2VydmFibGUuZXh0ZW5kKHsgdHJhY2tBcnJheUNoYW5nZXM6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKGpzeE9yT2JzZXJ2YWJsZSwgdGhpcy5vYnNlcnZhYmxlQXJyYXlDaGFuZ2UsICdhcnJheUNoYW5nZScpO1xuXG4gICAgICAgIGlmICghaW5zZXJ0QmVmb3JlKSB7XG4gICAgICAgICAgY29uc3QgaW5zZXJ0QXQgPSBwYXJlbnROb2RlSXNDb21tZW50ID8gcGFyZW50Tm9kZS5uZXh0U2libGluZyA6IG51bGw7XG4gICAgICAgICAgaW5zZXJ0QmVmb3JlID0gdGhpcy5jcmVhdGVDb21tZW50KCdPJyk7XG4gICAgICAgICAgcGFyZW50Tm9kZVRhcmdldC5pbnNlcnRCZWZvcmUoaW5zZXJ0QmVmb3JlLCBpbnNlcnRBdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hZG9wdGVkSW5zZXJ0QmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Tm9kZUlzQ29tbWVudCAmJiAhaW5zZXJ0QmVmb3JlKSB7XG4gICAgICAgIC8vIFR5cGNpYWxseTogaW5zZXJ0QmVmb3JlIGJlY29tZXMgPCEtLSAva28gLS0+XG4gICAgICAgIGluc2VydEJlZm9yZSA9IHBhcmVudE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIC8vIE1hcmsgdGhpcyBzbyB3ZSBkb24ndCByZW1vdmUgdGhlIG5leHQgbm9kZSAtIHNpbmNlIHdlIGRpZG4ndCBjcmVhdGUgaXQuXG4gICAgICAgIHRoaXMuYWRvcHRlZEluc2VydEJlZm9yZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYW5jaG9yVG8oaW5zZXJ0QmVmb3JlIHx8IHBhcmVudE5vZGUpO1xuXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgaW5zZXJ0QmVmb3JlLFxuICAgICAgICBub0luaXRpYWxCaW5kaW5nLFxuICAgICAgICBwYXJlbnROb2RlLFxuICAgICAgICBwYXJlbnROb2RlVGFyZ2V0LFxuICAgICAgICB4bWxucyxcbiAgICAgICAgbm9kZUFycmF5T3JPYnNlcnZhYmxlQXRJbmRleDogW10sXG4gICAgICAgIHN1YnNjcmlwdGlvbnNGb3JOb2RlOiBuZXcgTWFwKCksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QganN4ID0gdW53cmFwKGpzeE9yT2JzZXJ2YWJsZSk7XG4gICAgICBjb25zdCBjb21wdXRlZCQkMSA9IGlzQ29tcHV0ZWQoanN4T3JPYnNlcnZhYmxlKTtcblxuICAgICAgaWYgKGNvbXB1dGVkJCQxIHx8IChqc3ggIT09IG51bGwgJiYganN4ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZUFycmF5Q2hhbmdlKHRoaXMuY3JlYXRlSW5pdGlhbEFkZGl0aW9ucyhqc3gpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm9Jbml0aWFsQmluZGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SE1UTEVsZW1lbnR8Q29tbWVudHxIVE1MVGVtcGxhdGVFbGVtZW50fSBwYXJlbnROb2RlXG4gICAgICovXG4gICAgZ2V0UGFyZW50VGFyZ2V0IChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAoJ2NvbnRlbnQnIGluIHBhcmVudE5vZGUpIHsgcmV0dXJuIHBhcmVudE5vZGUuY29udGVudCB9XG4gICAgICBpZiAocGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gOCkgeyByZXR1cm4gcGFyZW50Tm9kZS5wYXJlbnROb2RlIH1cbiAgICAgIHJldHVybiBwYXJlbnROb2RlXG4gICAgfVxuXG4gICAgcmVtb3ZlICgpIHsgdGhpcy5kaXNwb3NlKCk7IH1cbiAgICBkaXNwb3NlICgpIHtcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICAgIGNvbnN0IGliID0gdGhpcy5pbnNlcnRCZWZvcmU7XG4gICAgICBjb25zdCBpbnNlcnRCZWZvcmVJc0NoaWxkID0gaWIgJiYgdGhpcy5wYXJlbnROb2RlVGFyZ2V0ID09PSBpYi5wYXJlbnROb2RlO1xuICAgICAgaWYgKGluc2VydEJlZm9yZUlzQ2hpbGQgJiYgIXRoaXMuYWRvcHRlZEluc2VydEJlZm9yZSkge1xuICAgICAgICB0aGlzLnBhcmVudE5vZGVUYXJnZXQucmVtb3ZlQ2hpbGQoaWIpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW1vdmVBbGxQcmlvck5vZGVzKCk7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICAgICAgcGFyZW50Tm9kZVRhcmdldDogbnVsbCxcbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBudWxsLFxuICAgICAgICBub2RlQXJyYXlPck9ic2VydmFibGVBdEluZGV4OiBbXVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbnMgb2YgdGhpcy5zdWJzY3JpcHRpb25zRm9yTm9kZS52YWx1ZXMoKSkge1xuICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2gocyA9PiBzLmRpc3Bvc2UoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnNGb3JOb2RlLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgY3JlYXRlSW5pdGlhbEFkZGl0aW9ucyAocG9zc2libGVJdGVyYWJsZSkge1xuICAgICAgY29uc3Qgc3RhdHVzID0gJ2FkZGVkJztcbiAgICAgIGlmICh0eXBlb2YgcG9zc2libGVJdGVyYXRhYmxlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBwb3NpYmxlSXRlcmFibGUgIT09IG51bGwgJiZcbiAgICAgICAgU3ltYm9sLml0ZXJhdG9yIGluIHBvc3NpYmxlSXRlcmFibGUpIHtcbiAgICAgICAgcG9zc2libGVJdGVyYWJsZSA9IFsuLi5wb3NzaWJsZUl0ZXJhYmxlXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocG9zc2libGVJdGVyYWJsZSlcbiAgICAgICAgPyBwb3NzaWJsZUl0ZXJhYmxlLm1hcCgodmFsdWUsIGluZGV4KSA9PiAoeyBpbmRleCwgc3RhdHVzLCB2YWx1ZSB9KSlcbiAgICAgICAgOiBbeyBzdGF0dXMsIGluZGV4OiAwLCB2YWx1ZTogcG9zc2libGVJdGVyYWJsZSB9XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGU6IGFycmF5IGNoYW5nZSBub3RpZmljYXRpb24gaW5kZXhlcyBhcmU6XG4gICAgICogICAtIHRvIHRoZSBvcmlnaW5hbCBhcnJheSBpbmRleGVzIGZvciBkZWxldGVzXG4gICAgICogICAtIHRvIHRoZSBuZXcgYXJyYXkgaW5kZXhlcyBmb3IgYWRkc1xuICAgICAqICAgLSBzb3J0ZWQgYnkgaW5kZXggaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICovXG4gICAgb2JzZXJ2YWJsZUFycmF5Q2hhbmdlIChjaGFuZ2VzKSB7XG4gICAgICBsZXQgYWRkcyA9IFtdO1xuICAgICAgbGV0IGRlbHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gY2hhbmdlcykge1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBjaGFuZ2VzW2luZGV4XTtcbiAgICAgICAgaWYgKGNoYW5nZS5zdGF0dXMgPT09ICdhZGRlZCcpIHtcbiAgICAgICAgICBhZGRzLnB1c2goW2NoYW5nZS5pbmRleCwgY2hhbmdlLnZhbHVlXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVscy51bnNoaWZ0KFtjaGFuZ2UuaW5kZXgsIGNoYW5nZS52YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWxzLmZvckVhY2goY2hhbmdlID0+IHRoaXMuZGVsQ2hhbmdlKC4uLmNoYW5nZSkpO1xuICAgICAgYWRkcy5mb3JFYWNoKGNoYW5nZSA9PiB0aGlzLmFkZENoYW5nZSguLi5jaGFuZ2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjaGFuZ2UgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbnR9IGluZGV4XG4gICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fEFycmF5fE9ic2VydmFibGUuc3RyaW5nfE9ic2VydmFibGUuQXJyYXl8T2JzZXJhdmJsZS5vYmplY3R9IGpzeFxuICAgICAqL1xuICAgIGFkZENoYW5nZSAoaW5kZXgsIGpzeCkge1xuICAgICAgdGhpcy5ub2RlQXJyYXlPck9ic2VydmFibGVBdEluZGV4LnNwbGljZShpbmRleCwgMCxcbiAgICAgICAgdGhpcy5pbmplY3ROb2RlKGpzeCwgdGhpcy5sYXN0Tm9kZUZvcihpbmRleCkpKTtcbiAgICB9XG5cbiAgICBpbmplY3ROb2RlIChqc3gsIG5leHROb2RlKSB7XG4gICAgICBsZXQgbm9kZUFycmF5T3JPYnNlcnZhYmxlO1xuXG4gICAgICBpZiAoaXNPYnNlcnZhYmxlKGpzeCkpIHtcbiAgICAgICAgY29uc3Qge3BhcmVudE5vZGUsIHhtbG5zfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEpzeE9ic2VydmVyKGpzeCwgcGFyZW50Tm9kZSwgbmV4dE5vZGUsIHhtbG5zLCB0aGlzLm5vSW5pdGlhbEJpbmRpbmcpO1xuICAgICAgICBub2RlQXJyYXlPck9ic2VydmFibGUgPSBbb2JzZXJ2ZXJdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YganN4ICE9PSAnc3RyaW5nJyAmJiBpc0l0ZXJhYmxlKGpzeCkpIHtcbiAgICAgICAgbm9kZUFycmF5T3JPYnNlcnZhYmxlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YganN4KSB7XG4gICAgICAgICAgbm9kZUFycmF5T3JPYnNlcnZhYmxlLnVuc2hpZnQoXG4gICAgICAgICAgICB0aGlzLmluamVjdE5vZGUoY2hpbGQsIG5leHROb2RlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0ICRjb250ZXh0ID0gY29udGV4dEZvcih0aGlzLnBhcmVudE5vZGUpO1xuICAgICAgICBjb25zdCBpc0luc2lkZVRlbXBsYXRlID0gJ2NvbnRlbnQnIGluIHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3Qgc2hvdWxkQXBwbHlCaW5kaW5ncyA9ICRjb250ZXh0ICYmICFpc0luc2lkZVRlbXBsYXRlICYmICF0aGlzLm5vSW5pdGlhbEJpbmRpbmc7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoanN4KSkge1xuICAgICAgICAgIG5vZGVBcnJheU9yT2JzZXJ2YWJsZSA9IGpzeC5tYXAoaiA9PiB0aGlzLmFueVRvTm9kZShqKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZUFycmF5T3JPYnNlcnZhYmxlID0gW3RoaXMuYW55VG9Ob2RlKGpzeCldO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVBcnJheU9yT2JzZXJ2YWJsZSkge1xuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZVRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dE5vZGUpO1xuICAgICAgICAgIGlmIChzaG91bGRBcHBseUJpbmRpbmdzICYmIHRoaXMuY2FuQXBwbHlCaW5kaW5ncyhub2RlKSkge1xuICAgICAgICAgICAgYXBwbHlCaW5kaW5ncygkY29udGV4dCwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlQXJyYXlPck9ic2VydmFibGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIHdoZW4gTm9kZSBpcyBhIHR5cGUgc3VpdGFibGUgZm9yIGFwcGx5QmluZGluZ3MgaS5lLiBhIEhUTUxFbGVtZW50XG4gICAgICogb3IgYSBDb21tZW50LlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqL1xuICAgIGNhbkFwcGx5QmluZGluZ3MgKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxIHx8IG5vZGUubm9kZVR5cGUgPT09IDhcbiAgICB9XG5cbiAgICBkZWxDaGFuZ2UgKGluZGV4KSB7XG4gICAgICB0aGlzLnJlbW92ZU5vZGVBcnJheU9yT2JzZXJ2YWJsZShcbiAgICAgICAgdGhpcy5ub2RlQXJyYXlPck9ic2VydmFibGVBdEluZGV4W2luZGV4XSk7XG4gICAgICB0aGlzLm5vZGVBcnJheU9yT2JzZXJ2YWJsZUF0SW5kZXguc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICBnZXRTdWJzY3JpcHRpb25zRm9yTm9kZSAobm9kZSkge1xuICAgICAgaWYgKCF0aGlzLnN1YnNjcmlwdGlvbnNGb3JOb2RlLmhhcyhub2RlKSkge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc0Zvck5vZGUuc2V0KG5vZGUsIHN1YnNjcmlwdGlvbnMpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uc1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9uc0Zvck5vZGUuZ2V0KG5vZGUpXG4gICAgfVxuXG4gICAgaXNKc3ggKGpzeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBqc3guZWxlbWVudE5hbWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICdjaGlsZHJlbicgaW4ganN4ICYmXG4gICAgICAgICdhdHRyaWJ1dGVzJyBpbiBqc3hcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgYWNjZXB0YWJsZSB0byB0dXJuIGludG8gYSBOb2RlXG4gICAgICpcbiAgICAgKiBUaGUgb25lIHRoaW5nIGBhbnlgIGNhbm5vdCBiZSBoZXJlIGlzIGFuIEFycmF5IG9yIE9ic2VydmFibGU7IGJvdGggdGhvc2VcbiAgICAgKiBjYXNlcyBhcmUgaGFuZGxlZCB3aXRoIG5ldyBKc3hPYnNlcnZlcnMuXG4gICAgICovXG4gICAgYW55VG9Ob2RlIChhbnkpIHtcbiAgICAgIGlmIChpc1RoZW5hYmxlKGFueSkpIHsgcmV0dXJuIHRoaXMuZnV0dXJlSnN4Tm9kZShhbnkpIH1cblxuICAgICAgc3dpdGNoICh0eXBlb2YgYW55KSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgaWYgKGFueSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb21tZW50KGFueS50b1N0cmluZygpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYW55ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb21tZW50KFN0cmluZyhhbnkpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYW55IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmVKU1hvck1vdmVOb2RlKGFueSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBhbnkpIHtcbiAgICAgICAgICAgIHJldHVybiBhbnlcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOiByZXR1cm4gdGhpcy5hbnlUb05vZGUoYW55KCkpXG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIGNhc2UgJ0Vycm9yJzpcbiAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb21tZW50KFN0cmluZyhhbnkpKVxuICAgICAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gdGhpcy5jcmVhdGVUZXh0Tm9kZShhbnkpXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRleHROb2RlKFN0cmluZyhhbnkpKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5pc0pzeChhbnkpXG4gICAgICAgID8gdGhpcy5qc3hUb05vZGUoYW55KVxuICAgICAgICA6IHRoaXMuY3JlYXRlQ29tbWVudChzYWZlU3RyaW5naWZ5KGFueSkpXG4gICAgfVxuXG4gICAgY3JlYXRlQ29tbWVudCAoc3RyaW5nKSB7XG4gICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChzdHJpbmcpO1xuICAgICAgbm9kZVtOQVRJVkVfQklORElOR1NdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBub2RlXG4gICAgfVxuXG4gICAgY3JlYXRlVGV4dE5vZGUgKHN0cmluZykge1xuICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0cmluZyk7XG4gICAgICBub2RlW05BVElWRV9CSU5ESU5HU10gPSB0cnVlO1xuICAgICAgcmV0dXJuIG5vZGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZSBhIG5vZGU7IGlmIHRoYXQgbm9kZSB3YXMgb3JpZ2luYWxseSBmcm9tIEpTWCwgd2UgY2xvbmUgZnJvbSB0aGVyZVxuICAgICAqIHNvIHdlIHByZXNlcnZlIGJpbmRpbmcgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICovXG4gICAgY2xvbmVKU1hvck1vdmVOb2RlIChub2RlKSB7XG4gICAgICByZXR1cm4gT1JJR0lOQUxfSlNYX1NZTSBpbiBub2RlXG4gICAgICAgID8gdGhpcy5qc3hUb05vZGUobm9kZVtPUklHSU5BTF9KU1hfU1lNXSlcbiAgICAgICAgOiBub2RlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtKU1h9IGpzeCB0byBjb252ZXJ0IHRvIGEgbm9kZS5cbiAgICAgKi9cbiAgICBqc3hUb05vZGUgKGpzeCkge1xuICAgICAgY29uc3QgeG1sbnMgPSBqc3guYXR0cmlidXRlcy54bWxucyB8fCBOQU1FU1BBQ0VTW2pzeC5lbGVtZW50TmFtZV0gfHwgdGhpcy54bWxucztcbiAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoeG1sbnMgfHwgTkFNRVNQQUNFUy5odG1sLCBqc3guZWxlbWVudE5hbWUpO1xuXG4gICAgICAvKiogU2xvdHMgbmVlZCB0byBiZSBhYmxlIHRvIHJlcGxpY2F0ZSB3aXRoIHRoZSBhdHRyaWJ1dGVzLCB3aGljaFxuICAgICAgICogIGFyZSBub3QgcHJlc2VydmVkIHdoZW4gY2xvbmluZyBmcm9tIHRlbXBsYXRlIG5vZGVzLiAqL1xuICAgICAgbm9kZVtPUklHSU5BTF9KU1hfU1lNXSA9IGpzeDtcblxuICAgICAgaWYgKGlzT2JzZXJ2YWJsZShqc3guYXR0cmlidXRlcykpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRoaXMuZ2V0U3Vic2NyaXB0aW9uc0Zvck5vZGUobm9kZSk7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgICBqc3guYXR0cmlidXRlcy5zdWJzY3JpYmUoYXR0cnMgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRyaWJ1dGVzKG5vZGUsIHVud3JhcChhdHRycykpO1xuICAgICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlQXR0cmlidXRlcyhub2RlLCB1bndyYXAoanN4LmF0dHJpYnV0ZXMpKTtcblxuICAgICAgdGhpcy5hZGREaXNwb3NhYmxlKG5ldyBKc3hPYnNlcnZlcihqc3guY2hpbGRyZW4sIG5vZGUsIG51bGwsIHhtbG5zLCB0aGlzLm5vSW5pdGlhbEJpbmRpbmcpKTtcblxuICAgICAgcmV0dXJuIG5vZGVcbiAgICB9XG5cbiAgICBmdXR1cmVKc3hOb2RlIChwcm9taXNlKSB7XG4gICAgICBjb25zdCBvYnMgPSBvYnNlcnZhYmxlKCk7XG4gICAgICBwcm9taXNlLnRoZW4ob2JzKS5jYXRjaChlID0+IG9icyhlIGluc3RhbmNlb2YgRXJyb3IgPyBlIDogRXJyb3IoZSkpKTtcbiAgICAgIGNvbnN0IGpvID0gbmV3IEpzeE9ic2VydmVyKG9icywgdGhpcy5wYXJlbnROb2RlLCBudWxsLCB0aGlzLnhtbG5zLCB0aGlzLm5vSW5pdGlhbEJpbmRpbmcpO1xuICAgICAgdGhpcy5hZGREaXNwb3NhYmxlKGpvKTtcbiAgICAgIHJldHVybiBqby5pbnNlcnRCZWZvcmVcbiAgICB9XG5cbiAgICB1cGRhdGVBdHRyaWJ1dGVzIChub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5nZXRTdWJzY3JpcHRpb25zRm9yTm9kZShub2RlKTtcbiAgICAgIGNvbnN0IHRvUmVtb3ZlID0gbmV3IFNldChbLi4ubm9kZS5hdHRyaWJ1dGVzXS5tYXAobiA9PiBuLm5hbWUpKTtcblxuICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMgfHwge30pKSB7XG4gICAgICAgIHRvUmVtb3ZlLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICAgICAgICB2YWx1ZS5zdWJzY3JpYmUoYXR0ciA9PiB0aGlzLnNldE5vZGVBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXROb2RlQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRvUmVtb3ZlKSB7XG4gICAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZShub2RlLCBuYW1lLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTI1NzIwNDhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ciBlbGVtZW50IGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gbmFtZXNwYWNlIGFyZ3VtZW50IGZvciBzZXRBdHR0cmlidXRlTlNcbiAgICAgKi9cbiAgICBnZXROYW1lc3BhY2VPZkF0dHJpYnV0ZSAoYXR0cikge1xuICAgICAgY29uc3QgW3ByZWZpeCwgLi4udW5xdWFsaWZpZWROYW1lXSA9IGF0dHIuc3BsaXQoJzonKTtcbiAgICAgIGlmIChwcmVmaXggPT09ICd4bWxucycgfHwgKHVucXVhbGlmaWVkTmFtZS5sZW5ndGggJiYgTkFNRVNQQUNFU1twcmVmaXhdKSkge1xuICAgICAgICByZXR1cm4gTkFNRVNQQUNFU1twcmVmaXhdXG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHthbnl9IHZhbHVlT3JPYnNlcnZhYmxlXG4gICAgICovXG4gICAgc2V0Tm9kZUF0dHJpYnV0ZSAobm9kZSwgbmFtZSwgdmFsdWVPck9ic2VydmFibGUpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdW53cmFwKHZhbHVlT3JPYnNlcnZhYmxlKTtcbiAgICAgIE5hdGl2ZVByb3ZpZGVyLmFkZFZhbHVlVG9Ob2RlKG5vZGUsIG5hbWUsIHZhbHVlT3JPYnNlcnZhYmxlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlTlMobnVsbCwgbmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzVGhlbmFibGUodmFsdWVPck9ic2VydmFibGUpKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZU9yT2JzZXJ2YWJsZSlcbiAgICAgICAgICAudGhlbih2ID0+IHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZShub2RlLCBuYW1lLCB2KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBucyA9IHRoaXMuZ2V0TmFtZXNwYWNlT2ZBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobnMsIG5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW50fSBpbmRleFxuICAgICAqIEByZXR1cm4ge0NvbW1lbnR9IHRoYXQgaW1tZWRpYXRlbHkgcHJlY2VkZXMgdGhpcy5cbiAgICAgKi9cbiAgICBsYXN0Tm9kZUZvciAoaW5kZXgpIHtcbiAgICAgIGNvbnN0IG5vZGVzQXRJbmRleCA9IHRoaXMubm9kZUFycmF5T3JPYnNlcnZhYmxlQXRJbmRleFtpbmRleF0gfHwgW107XG4gICAgICBjb25zdCBbbGFzdE5vZGVPZlByaW9yXSA9IG5vZGVzQXRJbmRleC5zbGljZSgtMSk7XG4gICAgICBjb25zdCBpbnNlcnRCZWZvcmUgPSBsYXN0Tm9kZU9mUHJpb3IgaW5zdGFuY2VvZiBKc3hPYnNlcnZlclxuICAgICAgICA/IGxhc3ROb2RlT2ZQcmlvci5pbnNlcnRCZWZvcmUgOiBsYXN0Tm9kZU9mUHJpb3IgfHwgdGhpcy5pbnNlcnRCZWZvcmU7XG4gICAgICBpZiAoaW5zZXJ0QmVmb3JlKSB7IHJldHVybiBpbnNlcnRCZWZvcmUucGFyZW50Tm9kZSA/IGluc2VydEJlZm9yZSA6IG51bGwgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZW1vdmVBbGxQcmlvck5vZGVzICgpIHtcbiAgICAgIGNvbnN0IHtub2RlQXJyYXlPck9ic2VydmFibGVBdEluZGV4fSA9IHRoaXM7XG4gICAgICB3aGlsZSAobm9kZUFycmF5T3JPYnNlcnZhYmxlQXRJbmRleC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVOb2RlQXJyYXlPck9ic2VydmFibGUobm9kZUFycmF5T3JPYnNlcnZhYmxlQXRJbmRleC5wb3AoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlTm9kZUFycmF5T3JPYnNlcnZhYmxlIChub2RlQXJyYXlPck9ic2VydmFibGUpIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZU9yT2JzZXJ2YWJsZSBvZiBub2RlQXJyYXlPck9ic2VydmFibGUpIHtcbiAgICAgICAgaWYgKG5vZGVPck9ic2VydmFibGUgaW5zdGFuY2VvZiBKc3hPYnNlcnZlcikge1xuICAgICAgICAgIG5vZGVPck9ic2VydmFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVPck9ic2VydmFibGU7XG4gICAgICAgIGRlbGV0ZSBub2RlW09SSUdJTkFMX0pTWF9TWU1dO1xuICAgICAgICB0aGlzLmRldGFjaEFuZERpc3Bvc2Uobm9kZSk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnNGb3JOb2RlLmdldChub2RlKTtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2gocyA9PiBzLmRpc3Bvc2UoKSk7XG4gICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zRm9yTm9kZS5kZWxldGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggdGhlIGdpdmVuIG5vZGUsIGFuZCBkaXNwb3NlIG9mIGl0cyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIFRoZSBjbGVhbmluZyBjYW4gdHJpZ2dlciBhIGxvdCBvZiBnYXJiYWdlIGNvbGxlY3Rpb24sIHNvIHdlIGRlZmVyIHRoYXQuXG4gICAgICovXG4gICAgZGV0YWNoQW5kRGlzcG9zZSAobm9kZSkge1xuICAgICAgaWYgKGlzSXRlcmFibGUobm9kZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlKSB7XG4gICAgICAgICAgdGhpcy5kZXRhY2hBbmREaXNwb3NlKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlQ2xlYW5Ob2RlKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gcG9zc2libGVKc3ggVGVzdCB3aGV0aGVyIHRoaXMgdmFsdWUgaXMgSlNYLlxuICAgKlxuICAgKiBUcnVlIGZvclxuICAgKiAgICB7IGVsZW1lbnROYW1lIH1cbiAgICogICAgW3tlbGVtZW50TmFtZX1dXG4gICAqICAgIG9ic2VydmFibGUoe2VsZW1lbnROYW1lfSB8IFtdKVxuICAgKlxuICAgKiBBbnkgb2JzZXJ2YWJsZSB3aWxsIHJldHVybiB0cnV0aHkgaWYgaXRzIHZhbHVlIGlzIGFuIGFycmF5IHRoYXQgZG9lc24ndFxuICAgKiBjb250YWluIEhUTUwgZWxlbWVudHMuICBUZW1wbGF0ZSBub2RlcyBzaG91bGQgbm90IGJlIG9ic2VydmFibGUgdW5sZXNzIHRoZXlcbiAgICogYXJlIEpTWC5cbiAgICpcbiAgICogVGhlcmUncyBhIGJpdCBvZiBndWVzc3dvcmsgaGVyZSB0aGF0IHdlIGNvdWxkIG5haWwgZG93biB3aXRoIG1vcmUgdGVzdCBjYXNlcy5cbiAgICovXG4gIGZ1bmN0aW9uIG1heWJlSnN4IChwb3NzaWJsZUpzeCkge1xuICAgIGlmIChpc09ic2VydmFibGUocG9zc2libGVKc3gpKSB7IHJldHVybiB0cnVlIH1cbiAgICBjb25zdCB2YWx1ZSA9IHVud3JhcChwb3NzaWJsZUpzeCk7XG4gICAgaWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh2YWx1ZS5lbGVtZW50TmFtZSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAhdmFsdWUubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHZhbHVlWzBdIGluc3RhbmNlb2Ygd2luZG93Lk5vZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3JpZ2luYWxKc3hGb3JOb2RlIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGVbT1JJR0lOQUxfSlNYX1NZTV1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgSlNYIGludG8gYW4gb2JqZWN0IHRoYXQgY2FuIGJlIGNvbnN1bWVkIGJ5IFRLTy5cbiAgICogTWltaWNzIFJlYWN0LmNyZWF0ZUVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGUgdGFnTmFtZSBvZiB0aGUgZWxlbWVudFxuICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBhIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgICogQHBhcmFtICB7Li4uc3RyaW5nfG9iamVjdH0gYyBjaGlsZHJlbiBvZiB0aGUgZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoZWxlbWVudE5hbWUsIGF0dHJpYnV0ZXMsIC4uLmNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGVsZW1lbnROYW1lID09PSBGcmFnbWVudCA/IGNoaWxkcmVuXG4gICAgICA6IHtcbiAgICAgICAgZWxlbWVudE5hbWU6IGVsZW1lbnROYW1lLFxuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzIHx8IHt9LFxuICAgICAgICBjaGlsZHJlbjogWy4uLmNoaWxkcmVuXVxuICAgICAgfVxuICB9XG5cbiAgY29uc3QgRnJhZ21lbnQgPSBTeW1ib2woJ0pTWCBGcmFnbWVudCcpO1xuXG4gIC8vXG5cbiAgdmFyIGNvbXBvbmVudExvYWRpbmdPcGVyYXRpb25VbmlxdWVJZCA9IDA7XG5cbiAgY2xhc3MgQ29tcG9uZW50QmluZGluZyBleHRlbmRzIERlc2NlbmRhbnRCaW5kaW5nSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IgKHBhcmFtcykge1xuICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgIHRoaXMub3JpZ2luYWxDaGlsZE5vZGVzID0gbWFrZUFycmF5KFxuICAgICAgICBjaGlsZE5vZGVzKHRoaXMuJGVsZW1lbnQpXG4gICAgICApO1xuICAgICAgdGhpcy5jb21wdXRlZCgnY29tcHV0ZUFwcGx5Q29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgY2xvbmVUZW1wbGF0ZUludG9FbGVtZW50IChjb21wb25lbnROYW1lLCB0ZW1wbGF0ZSwgZWxlbWVudCkge1xuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCBcXCcnICsgY29tcG9uZW50TmFtZSArICdcXCcgaGFzIG5vIHRlbXBsYXRlJylcbiAgICAgIH1cblxuICAgICAgaWYgKG1heWJlSnN4KHRlbXBsYXRlKSkge1xuICAgICAgICBlbXB0eU5vZGUoZWxlbWVudCk7XG4gICAgICAgIHRoaXMuYWRkRGlzcG9zYWJsZShuZXcgSnN4T2JzZXJ2ZXIodGVtcGxhdGUsIGVsZW1lbnQsIG51bGwsIHVuZGVmaW5lZCwgdHJ1ZSkpO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjbG9uZWROb2Rlc0FycmF5ID0gY2xvbmVOb2Rlcyh0ZW1wbGF0ZSk7XG4gICAgICAgIHNldERvbU5vZGVDaGlsZHJlbiQxKGVsZW1lbnQsIGNsb25lZE5vZGVzQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZVZpZXdNb2RlbCAoY29tcG9uZW50RGVmaW5pdGlvbiwgZWxlbWVudCwgb3JpZ2luYWxDaGlsZE5vZGVzLCBjb21wb25lbnRQYXJhbXMpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudFZpZXdNb2RlbEZhY3RvcnkgPSBjb21wb25lbnREZWZpbml0aW9uLmNyZWF0ZVZpZXdNb2RlbDtcbiAgICAgIHJldHVybiBjb21wb25lbnRWaWV3TW9kZWxGYWN0b3J5XG4gICAgICAgID8gY29tcG9uZW50Vmlld01vZGVsRmFjdG9yeS5jYWxsKGNvbXBvbmVudERlZmluaXRpb24sIGNvbXBvbmVudFBhcmFtcywgeyBlbGVtZW50LCB0ZW1wbGF0ZU5vZGVzOiBvcmlnaW5hbENoaWxkTm9kZXMgfSlcbiAgICAgICAgOiBjb21wb25lbnRQYXJhbXMgLy8gVGVtcGxhdGUtb25seSBjb21wb25lbnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlICRjb21wb25lbnRUZW1wbGF0ZVNsb3ROb2RlcyBmb3IgdGhlIGdpdmVuIHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxqc3h9IHRlbXBsYXRlXG4gICAgICovXG4gICAgbWFrZVRlbXBsYXRlU2xvdE5vZGVzIChvcmlnaW5hbENoaWxkTm9kZXMpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAuLi50aGlzLmdlblNsb3RzQnlOYW1lKG9yaWdpbmFsQ2hpbGROb2RlcykpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIHRoZSB0ZW1wbGF0ZU5vZGVzLCB5aWVsZGluZyBlYWNoICc8ZWxlbWVudCBzbG90PW5hbWU+J1xuICAgICAqIGFzIGFuIG9iamVjdCAqIG9mIHtuYW1lOiBlbGVtZW50fS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0ZW1wbGF0ZU5vZGVzXG4gICAgICovXG4gICAgKiBnZW5TbG90c0J5TmFtZSAodGVtcGxhdGVOb2Rlcykge1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRlbXBsYXRlTm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHsgY29udGludWUgfVxuICAgICAgICBjb25zdCBzbG90TmFtZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdzbG90Jyk7XG4gICAgICAgIGlmICghc2xvdE5hbWUpIHsgY29udGludWUgfVxuICAgICAgICB5aWVsZCB7W3Nsb3ROYW1lXTogbm9kZX07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcHV0ZUFwcGx5Q29tcG9uZW50ICgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdW53cmFwKHRoaXMudmFsdWUpO1xuICAgICAgbGV0IGNvbXBvbmVudE5hbWU7XG4gICAgICBsZXQgY29tcG9uZW50UGFyYW1zO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb21wb25lbnROYW1lID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnROYW1lID0gdW53cmFwKHZhbHVlLm5hbWUpO1xuICAgICAgICBjb21wb25lbnRQYXJhbXMgPSBOYXRpdmVQcm92aWRlci5nZXROb2RlVmFsdWVzKHRoaXMuJGVsZW1lbnQpIHx8XG4gICAgICAgICAgdW53cmFwKHZhbHVlLnBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGF0ZXN0Q29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWU7XG5cbiAgICAgIGlmICghY29tcG9uZW50TmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbXBvbmVudCBuYW1lIHNwZWNpZmllZCcpXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9hZGluZ09wZXJhdGlvbklkID0gdGhpcy5jdXJyZW50TG9hZGluZ09wZXJhdGlvbklkID0gKytjb21wb25lbnRMb2FkaW5nT3BlcmF0aW9uVW5pcXVlSWQ7XG4gICAgICByZWdpc3RyeSQxLmdldChjb21wb25lbnROYW1lLCAoZGVmbikgPT4gdGhpcy5hcHBseUNvbXBvbmVudERlZmluaXRpb24oY29tcG9uZW50TmFtZSwgY29tcG9uZW50UGFyYW1zLCBkZWZuKSk7XG4gICAgfVxuXG4gICAgbWFrZUNoaWxkQmluZGluZ0NvbnRleHQgKCRjb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IGN0eEV4dGVuZGVyID0gKGN0eCkgPT4gT2JqZWN0LmFzc2lnbihjdHgsIHtcbiAgICAgICAgJGNvbXBvbmVudCxcbiAgICAgICAgJGNvbXBvbmVudFRlbXBsYXRlTm9kZXM6IHRoaXMub3JpZ2luYWxDaGlsZE5vZGVzLFxuICAgICAgICAkY29tcG9uZW50VGVtcGxhdGVTbG90Tm9kZXM6IHRoaXMubWFrZVRlbXBsYXRlU2xvdE5vZGVzKFxuICAgICAgICAgIHRoaXMub3JpZ2luYWxDaGlsZE5vZGVzKVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmNyZWF0ZUNoaWxkQ29udGV4dCgkY29tcG9uZW50LCB1bmRlZmluZWQsIGN0eEV4dGVuZGVyKVxuICAgIH1cblxuICAgIGFwcGx5Q29tcG9uZW50RGVmaW5pdGlvbiAoY29tcG9uZW50TmFtZSwgY29tcG9uZW50UGFyYW1zLCBjb21wb25lbnREZWZpbml0aW9uKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgY3VycmVudCBsb2FkIG9wZXJhdGlvbiBmb3IgdGhpcyBlbGVtZW50LCBpZ25vcmUgaXQuXG4gICAgICBpZiAodGhpcy5jdXJyZW50TG9hZGluZ09wZXJhdGlvbklkICE9PSB0aGlzLmxvYWRpbmdPcGVyYXRpb25JZCB8fFxuICAgICAgICAgIHRoaXMubGF0ZXN0Q29tcG9uZW50TmFtZSAhPT0gY29tcG9uZW50TmFtZSkgeyByZXR1cm4gfVxuXG4gICAgICAvLyBDbGVhbiB1cCBwcmV2aW91cyBzdGF0ZVxuICAgICAgdGhpcy5jbGVhblVwU3RhdGUoKTtcblxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuJGVsZW1lbnQ7XG5cbiAgICAgIC8vIEluc3RhbnRpYXRlIGFuZCBiaW5kIG5ldyBjb21wb25lbnQuIEltcGxpY2l0bHkgdGhpcyBjbGVhbnMgYW55IG9sZCBET00gbm9kZXMuXG4gICAgICBpZiAoIWNvbXBvbmVudERlZmluaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbXBvbmVudCBcXCcnICsgY29tcG9uZW50TmFtZSArICdcXCcnKVxuICAgICAgfVxuXG4gICAgICBpZiAoY29tcG9uZW50RGVmaW5pdGlvbi50ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLmNsb25lVGVtcGxhdGVJbnRvRWxlbWVudChjb21wb25lbnROYW1lLCBjb21wb25lbnREZWZpbml0aW9uLnRlbXBsYXRlLCBlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tcG9uZW50Vmlld01vZGVsID0gdGhpcy5jcmVhdGVWaWV3TW9kZWwoY29tcG9uZW50RGVmaW5pdGlvbiwgZWxlbWVudCwgdGhpcy5vcmlnaW5hbENoaWxkTm9kZXMsIGNvbXBvbmVudFBhcmFtcyk7XG5cbiAgICAgIHRoaXMuY2hpbGRCaW5kaW5nQ29udGV4dCA9IHRoaXMubWFrZUNoaWxkQmluZGluZ0NvbnRleHQoY29tcG9uZW50Vmlld01vZGVsKTtcblxuICAgICAgY29uc3Qgdmlld1RlbXBsYXRlID0gY29tcG9uZW50Vmlld01vZGVsICYmIGNvbXBvbmVudFZpZXdNb2RlbC50ZW1wbGF0ZTtcblxuICAgICAgaWYgKCF2aWV3VGVtcGxhdGUgJiYgIWNvbXBvbmVudERlZmluaXRpb24udGVtcGxhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgXFwnJyArIGNvbXBvbmVudE5hbWUgKyAnXFwnIGhhcyBubyB0ZW1wbGF0ZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghY29tcG9uZW50RGVmaW5pdGlvbi50ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLmNsb25lVGVtcGxhdGVJbnRvRWxlbWVudChjb21wb25lbnROYW1lLCB2aWV3VGVtcGxhdGUsIGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcG9uZW50Vmlld01vZGVsIGluc3RhbmNlb2YgTGlmZUN5Y2xlKSB7XG4gICAgICAgIGNvbXBvbmVudFZpZXdNb2RlbC5hbmNob3JUbyh0aGlzLiRlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdXJyZW50Vmlld01vZGVsID0gY29tcG9uZW50Vmlld01vZGVsO1xuXG4gICAgICBjb25zdCBvbkJpbmRpbmcgPSB0aGlzLm9uQmluZGluZ0NvbXBsZXRlLmJpbmQodGhpcywgY29tcG9uZW50Vmlld01vZGVsKTtcbiAgICAgIHRoaXMuYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHModGhpcy5jaGlsZEJpbmRpbmdDb250ZXh0LCBvbkJpbmRpbmcpO1xuICAgIH1cblxuICAgIG9uQmluZGluZ0NvbXBsZXRlIChjb21wb25lbnRWaWV3TW9kZWwsIGJpbmRpbmdSZXN1bHQpIHtcbiAgICAgIGlmIChjb21wb25lbnRWaWV3TW9kZWwgJiYgY29tcG9uZW50Vmlld01vZGVsLmtvRGVzY2VuZGFudHNDb21wbGV0ZSkge1xuICAgICAgICBjb21wb25lbnRWaWV3TW9kZWwua29EZXNjZW5kYW50c0NvbXBsZXRlKHRoaXMuJGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb21wbGV0ZUJpbmRpbmcoYmluZGluZ1Jlc3VsdCk7XG4gICAgfVxuXG4gICAgY2xlYW5VcFN0YXRlICgpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRWaWV3ID0gdGhpcy5jdXJyZW50Vmlld01vZGVsO1xuICAgICAgY29uc3QgY3VycmVudFZpZXdEaXNwb3NlID0gY3VycmVudFZpZXcgJiYgY3VycmVudFZpZXcuZGlzcG9zZTtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZpZXdEaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGN1cnJlbnRWaWV3RGlzcG9zZS5jYWxsKGN1cnJlbnRWaWV3KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudFZpZXdNb2RlbCA9IG51bGw7XG4gICAgICAvLyBBbnkgaW4tZmxpZ2h0IGxvYWRpbmcgb3BlcmF0aW9uIGlzIG5vIGxvbmdlciByZWxldmFudCwgc28gbWFrZSBzdXJlIHdlIGlnbm9yZSBpdHMgY29tcGxldGlvblxuICAgICAgdGhpcy5jdXJyZW50TG9hZGluZ09wZXJhdGlvbklkID0gbnVsbDtcbiAgICB9XG5cbiAgICBkaXNwb3NlICgpIHtcbiAgICAgIHRoaXMuY2xlYW5VcFN0YXRlKCk7XG4gICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGNvbnRyb2xzRGVzY2VuZGFudHMgKCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgc3RhdGljIGdldCBhbGxvd1ZpcnR1YWxFbGVtZW50cyAoKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTbG90cyB3b3JrIGFzIGZvbGxvd3MgKHlvdSdsbCBub3RlIGEgc2ltaWxhcml0eSB0byB2dWUpLlxuICAgKlxuICAgKiBDb21wb25lbnQgdGVtcGxhdGUgZGVmaW5pdGlvbnMgaGF2ZSA8c2xvdCBuYW1lPSdhYmMnPiB0YWdzLlxuICAgKlxuICAgKiAgICA8dGVtcGxhdGUgaWQ9J2N1c3RvbS1jb21wb25lbnQtdGVtcGxhdGUnPlxuICAgKiAgICAgIDxzbG90IG5hbWU9J2FiYyc+XG4gICAqXG4gICAqIENvbXBvbmVudCB1c2UgdGhlc2Ugc2xvdHMgd2l0aCBlLmcuXG4gICAqXG4gICAqICAgIDxjdXN0b20tY29tcG9uZW50PlxuICAgKiAgICAgICA8dGVtcGxhdGUgc2xvdD0nYWJjJz5cbiAgICpcbiAgICogV2hlbiB0aGUgY29tcG9uZW50IHRlbXBsYXRlIGlzIHJlbmRlcmVkLCB0aGUgYHNsb3RgIGJpbmRpbmcgd2lsbCBtYXBcbiAgICogZXZlcnkgYmluZGluZyB0byBpdHMgcmVzcGVjdGl2ZSBzbG90LlxuICAgKi9cblxuICAvKipcbiAgICogU2xvdEJpbmRpbmcgcmVwbGFjZXMgYSBzbG90IHdpdGhcbiAgICovXG4gIGNsYXNzIFNsb3RCaW5kaW5nIGV4dGVuZHMgRGVzY2VuZGFudEJpbmRpbmdIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoLi4ucGFyYW1zKSB7XG4gICAgICBzdXBlciguLi5wYXJhbXMpO1xuICAgICAgY29uc3Qgc2xvdE5vZGUgPSB0aGlzLmdldFNsb3QodGhpcy52YWx1ZSk7XG4gICAgICBjb25zdCAkc2xvdENvbnRleHQgPSBjb250ZXh0Rm9yKHNsb3ROb2RlKTtcblxuICAgICAgY29uc3QgY2hpbGRDb250ZXh0ID0gdGhpcy4kY29udGV4dC5leHRlbmQoe1xuICAgICAgICAkc2xvdENvbnRleHQsXG4gICAgICAgICRzbG90RGF0YTogJHNsb3RDb250ZXh0ICYmICRzbG90Q29udGV4dC4kZGF0YVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucmVwbGFjZVNsb3RXaXRoTm9kZSh0aGlzLiRlbGVtZW50LCBzbG90Tm9kZSk7XG5cbiAgICAgIHRoaXMuYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHMoY2hpbGRDb250ZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVUb1JlcGxhY2VcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fX0gc2xvdFZhbHVlXG4gICAgICovXG4gICAgcmVwbGFjZVNsb3RXaXRoTm9kZSAobm9kZUluQ29tcG9uZW50VGVtcGxhdGUsIHNsb3ROb2RlKSB7XG4gICAgICBjb25zdCBub2RlcyA9IHRoaXMuY2xvbmVOb2RlRnJvbU9yaWdpbmFsKHNsb3ROb2RlKTtcbiAgICAgIGVtcHR5Tm9kZShub2RlSW5Db21wb25lbnRUZW1wbGF0ZSk7XG4gICAgICB0aGlzLmFkZERpc3Bvc2FibGUobmV3IEpzeE9ic2VydmVyKG5vZGVzLCBub2RlSW5Db21wb25lbnRUZW1wbGF0ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBjbG9uZU5vZGVGcm9tT3JpZ2luYWwgKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkgeyByZXR1cm4gW10gfVxuICAgICAgY29uc3QganN4ID0gZ2V0T3JpZ2luYWxKc3hGb3JOb2RlKG5vZGUpO1xuICAgICAgaWYgKGpzeCkgeyByZXR1cm4ganN4LmNoaWxkcmVuIH1cblxuICAgICAgaWYgKCdjb250ZW50JyBpbiBub2RlKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gZG9jdW1lbnQuaW1wb3J0Tm9kZShub2RlLmNvbnRlbnQsIHRydWUpO1xuICAgICAgICByZXR1cm4gWy4uLmNsb25lLmNoaWxkTm9kZXNdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGVBcnJheSA9IEFycmF5LmlzQXJyYXkobm9kZSkgPyBub2RlIDogW25vZGVdO1xuICAgICAgcmV0dXJuIG5vZGVBcnJheS5tYXAobiA9PiBuLmNsb25lTm9kZSh0cnVlKSlcbiAgICB9XG5cblxuICAgIGdldFNsb3QgKHNsb3ROYW1lKSB7XG4gICAgICBjb25zdCB7JGNvbXBvbmVudFRlbXBsYXRlU2xvdE5vZGVzfSA9IHRoaXMuJGNvbnRleHQ7XG5cbiAgICAgIGlmICghc2xvdE5hbWUpIHtcbiAgICAgICAgcmV0dXJuICRjb21wb25lbnRUZW1wbGF0ZVNsb3ROb2Rlc1snJ10gfHxcbiAgICAgICAgICBbLi4udGhpcy4kY29udGV4dC4kY29tcG9uZW50VGVtcGxhdGVOb2Rlc11cbiAgICAgICAgICAgIC5maWx0ZXIobiA9PiAhbi5nZXRBdHRyaWJ1dGUgfHwgIW4uZ2V0QXR0cmlidXRlKCdzbG90JykpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkY29tcG9uZW50VGVtcGxhdGVTbG90Tm9kZXNbc2xvdE5hbWVdXG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBhbGxvd1ZpcnR1YWxFbGVtZW50cyAoKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuXG4gIHZhciBiaW5kaW5ncyQ0ID0geyBjb21wb25lbnQ6IENvbXBvbmVudEJpbmRpbmcsIHNsb3Q6IFNsb3RCaW5kaW5nIH07XG5cbiAgdmFyIHNwcm90byA9IFN0cmluZy5wcm90b3R5cGU7XG5cbiAgdmFyIGZpbHRlcnMgPSB7fTtcblxuICAvLyBDb252ZXJ0IHZhbHVlIHRvIHVwcGVyY2FzZVxuICBmaWx0ZXJzLnVwcGVyY2FzZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBzcHJvdG8udG9VcHBlckNhc2UuY2FsbCh1bndyYXAodmFsdWUpKVxuICB9O1xuXG4gIC8vIENvbnZlcnQgdmFsdWUgdG8gbG93ZXJjYXNlXG4gIGZpbHRlcnMubG93ZXJjYXNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHNwcm90by50b0xvd2VyQ2FzZS5jYWxsKHVud3JhcCh2YWx1ZSkpXG4gIH07XG5cbiAgLy8gUmV0dXJuIGRlZmF1bHQgdmFsdWUgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGVtcHR5IG9yIG51bGxcbiAgZmlsdGVyc1snZGVmYXVsdCddID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YWx1ZSA9IHVud3JhcCh2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gc3Byb3RvLnRyaW0uY2FsbCh2YWx1ZSkgPT09ICcnID8gZGVmYXVsdFZhbHVlIDogdmFsdWVcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09IDAgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZVxuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgdmFsdWUgd2l0aCB0aGUgc2VhcmNoIHN0cmluZyByZXBsYWNlZCB3aXRoIHRoZSByZXBsYWNlbWVudCBzdHJpbmdcbiAgZmlsdGVycy5yZXBsYWNlID0gZnVuY3Rpb24gKHZhbHVlLCBzZWFyY2gsIHJlcGxhY2UpIHtcbiAgICByZXR1cm4gc3Byb3RvLnJlcGxhY2UuY2FsbCh1bndyYXAodmFsdWUpLCBzZWFyY2gsIHJlcGxhY2UpXG4gIH07XG5cbiAgZmlsdGVycy5maXQgPSBmdW5jdGlvbiAodmFsdWUsIGxlbmd0aCwgcmVwbGFjZW1lbnQsIHRyaW1XaGVyZSkge1xuICAgIHZhbHVlID0gdW53cmFwKHZhbHVlKTtcbiAgICBpZiAobGVuZ3RoICYmICgnJyArIHZhbHVlKS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgIHJlcGxhY2VtZW50ID0gJycgKyAocmVwbGFjZW1lbnQgfHwgJy4uLicpO1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIC0gcmVwbGFjZW1lbnQubGVuZ3RoO1xuICAgICAgdmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgc3dpdGNoICh0cmltV2hlcmUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50ICsgdmFsdWUuc2xpY2UoLWxlbmd0aClcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB2YXIgbGVmdExlbiA9IE1hdGguY2VpbChsZW5ndGggLyAyKTtcbiAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKDAsIGxlZnRMZW4pICsgcmVwbGFjZW1lbnQgKyB2YWx1ZS5zbGljZShsZWZ0TGVuIC0gbGVuZ3RoKVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHIoMCwgbGVuZ3RoKSArIHJlcGxhY2VtZW50XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgfTtcblxuICAvLyBDb252ZXJ0IGEgbW9kZWwgb2JqZWN0IHRvIEpTT05cbiAgZmlsdGVycy5qc29uID0gZnVuY3Rpb24gKHJvb3RPYmplY3QsIHNwYWNlLCByZXBsYWNlcikge1xuICAgICAgICAgLy8gcmVwbGFjZXIgYW5kIHNwYWNlIGFyZSBvcHRpb25hbFxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0b0pTKHJvb3RPYmplY3QpLCByZXBsYWNlciwgc3BhY2UpXG4gIH07XG5cbiAgLy8gRm9ybWF0IGEgbnVtYmVyIHVzaW5nIHRoZSBicm93c2VyJ3MgdG9Mb2NhbGVTdHJpbmdcbiAgZmlsdGVycy5udW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gKCt1bndyYXAodmFsdWUpKS50b0xvY2FsZVN0cmluZygpXG4gIH07XG5cbiAgdmFyIGJ1aWxkZXIgPSBuZXcgQnVpbGRlcih7XHJcbiAgICAgIGZpbHRlcnM6IGZpbHRlcnMsXHJcbiAgICAgIHByb3ZpZGVyOiBuZXcgTXVsdGlQcm92aWRlcih7XHJcbiAgICAgICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICAgICAgICBuZXcgQ29tcG9uZW50UHJvdmlkZXIoKSxcclxuICAgICAgICAgICAgICBuZXcgTmF0aXZlUHJvdmlkZXIoKSxcclxuICAgICAgICAgICAgICBuZXcgQXR0cmlidXRlTXVzdGFjaGVQcm92aWRlcigpLFxyXG4gICAgICAgICAgICAgIG5ldyBUZXh0TXVzdGFjaGVQcm92aWRlcigpLFxyXG4gICAgICAgICAgICAgIG5ldyBEYXRhQmluZFByb3ZpZGVyKCksXHJcbiAgICAgICAgICAgICAgbmV3IFZpcnR1YWxQcm92aWRlcigpLFxyXG4gICAgICAgICAgICAgIG5ldyBBdHRyUHJvdmlkZXIoKSxcclxuICAgICAgICAgIF1cclxuICAgICAgfSksXHJcbiAgICAgIGJpbmRpbmdzOiBbXHJcbiAgICAgICAgICBiaW5kaW5ncyQxLFxyXG4gICAgICAgICAgYmluZGluZ3MsXHJcbiAgICAgICAgICBiaW5kaW5ncyQyLFxyXG4gICAgICAgICAgYmluZGluZ3MkMyxcclxuICAgICAgICAgIGJpbmRpbmdzJDQsXHJcbiAgICAgICAgICB7IGVhY2g6IGJpbmRpbmdzJDMuZm9yZWFjaCB9XHJcbiAgICAgIF1cclxuICB9KTtcclxuICB2YXIgaW5kZXggPSBidWlsZGVyLmNyZWF0ZSh7XHJcbiAgICAgIGpzeDoge1xyXG4gICAgICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcclxuICAgICAgICAgIEZyYWdtZW50OiBGcmFnbWVudFxyXG4gICAgICB9LFxyXG4gICAgICBjb21wb25lbnRzOiByZWdpc3RyeSQxLFxyXG4gICAgICB2ZXJzaW9uOiAnNC4wLjAtYWxwaGE5LjAnLFxyXG4gICAgICBDb21wb25lbnQ6IHJlZ2lzdHJ5JDEuQ29tcG9uZW50QUJDXHJcbiAgfSk7XG5cbiAgcmV0dXJuIGluZGV4O1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGQucmVmZXJlbmNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@tko/build.reference/dist/build.reference.js\n");

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/axios */ \"./node_modules/axios/lib/axios.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsNEZBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzPzUzZTkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/index.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./node_modules/axios/lib/helpers/cookies.js\");\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./node_modules/axios/lib/helpers/parseHeaders.js\");\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\nvar createError = __webpack_require__(/*! ../core/createError */ \"./node_modules/axios/lib/core/createError.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults.js\");\nvar Cancel = __webpack_require__(/*! ../cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      var transitional = config.transitional || defaults.transitional;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(\n        timeoutErrorMessage,\n        config,\n        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function(cancel) {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGlFQUFrQjtBQUN2QyxjQUFjLG1CQUFPLENBQUMseUVBQXNCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQywyRUFBdUI7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsNkVBQXVCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN0RCxzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDNUQsa0JBQWtCLG1CQUFPLENBQUMseUVBQXFCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyx5REFBYTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsbUVBQWtCOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzPzFhNWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4uL2NvcmUvYnVpbGRGdWxsUGF0aCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9DYW5jZWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuICAgIHZhciByZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIHZhciBvbkNhbmNlbGVkO1xuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIXJlc3BvbnNlVHlwZSB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCAgcmVzcG9uc2VUeXBlID09PSAnanNvbicgP1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUoZnVuY3Rpb24gX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIF9yZWplY3QoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnb25sb2FkZW5kJyBpbiByZXF1ZXN0KSB7XG4gICAgICAvLyBVc2Ugb25sb2FkZW5kIGlmIGF2YWlsYWJsZVxuICAgICAgcmVxdWVzdC5vbmxvYWRlbmQgPSBvbmxvYWRlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGUgdG8gZW11bGF0ZSBvbmxvYWRlbmRcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeXN0YXRlIGhhbmRsZXIgaXMgY2FsbGluZyBiZWZvcmUgb25lcnJvciBvciBvbnRpbWVvdXQgaGFuZGxlcnMsXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBjYWxsIG9ubG9hZGVuZCBvbiB0aGUgbmV4dCAndGljaydcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWRlbmQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgdmFyIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcgOiAndGltZW91dCBleGNlZWRlZCc7XG4gICAgICB2YXIgdHJhbnNpdGlvbmFsID0gY29uZmlnLnRyYW5zaXRpb25hbCB8fCBkZWZhdWx0cy50cmFuc2l0aW9uYWw7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gJ0VUSU1FRE9VVCcgOiAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuIHx8IGNvbmZpZy5zaWduYWwpIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBvbkNhbmNlbGVkID0gZnVuY3Rpb24oY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCAoY2FuY2VsICYmIGNhbmNlbC50eXBlKSA/IG5ldyBDYW5jZWwoJ2NhbmNlbGVkJykgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuICYmIGNvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICBpZiAoY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBjb25maWcuc2lnbmFsLmFib3J0ZWQgPyBvbkNhbmNlbGVkKCkgOiBjb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0RGF0YSkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/adapters/xhr.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\nvar Axios = __webpack_require__(/*! ./core/Axios */ \"./node_modules/axios/lib/core/Axios.js\");\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"./node_modules/axios/lib/cancel/CancelToken.js\");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\naxios.VERSION = (__webpack_require__(/*! ./env/data */ \"./node_modules/axios/lib/env/data.js\").version);\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \"./node_modules/axios/lib/helpers/spread.js\");\n\n// Expose isAxiosError\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ \"./node_modules/axios/lib/helpers/isAxiosError.js\");\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports[\"default\"] = axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxrREFBUztBQUM3QixXQUFXLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyw0REFBYztBQUNsQyxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBb0I7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLHdEQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrRUFBaUI7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLHNFQUFtQjtBQUM1QyxnQkFBZ0IsdUZBQTZCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvRUFBa0I7O0FBRXpDO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQXdCOztBQUVyRDs7QUFFQTtBQUNBLHlCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanM/ZmFkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuICBpbnN0YW5jZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgaW5zdGFuY2VDb25maWcpKTtcbiAgfTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5heGlvcy5WRVJTSU9OID0gcmVxdWlyZSgnLi9lbnYvZGF0YScpLnZlcnNpb247XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0F4aW9zRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/axios.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzP2QyYTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/cancel/Cancel.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n\n  // eslint-disable-next-line func-names\n  this.promise.then(function(cancel) {\n    if (!token._listeners) return;\n\n    var i;\n    var l = token._listeners.length;\n\n    for (i = 0; i < l; i++) {\n      token._listeners[i](cancel);\n    }\n    token._listeners = null;\n  });\n\n  // eslint-disable-next-line func-names\n  this.promise.then = function(onfulfilled) {\n    var _resolve;\n    // eslint-disable-next-line func-names\n    var promise = new Promise(function(resolve) {\n      token.subscribe(resolve);\n      _resolve = resolve;\n    }).then(onfulfilled);\n\n    promise.cancel = function reject() {\n      token.unsubscribe(_resolve);\n    };\n\n    return promise;\n  };\n\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Subscribe to the cancel signal\n */\n\nCancelToken.prototype.subscribe = function subscribe(listener) {\n  if (this.reason) {\n    listener(this.reason);\n    return;\n  }\n\n  if (this._listeners) {\n    this._listeners.push(listener);\n  } else {\n    this._listeners = [listener];\n  }\n};\n\n/**\n * Unsubscribe from the cancel signal\n */\n\nCancelToken.prototype.unsubscribe = function unsubscribe(listener) {\n  if (!this._listeners) {\n    return;\n  }\n  var index = this._listeners.indexOf(listener);\n  if (index !== -1) {\n    this._listeners.splice(index, 1);\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsMkRBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcz83MmM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcblxuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICB0aGlzLnByb21pc2UudGhlbihmdW5jdGlvbihjYW5jZWwpIHtcbiAgICBpZiAoIXRva2VuLl9saXN0ZW5lcnMpIHJldHVybjtcblxuICAgIHZhciBpO1xuICAgIHZhciBsID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0b2tlbi5fbGlzdGVuZXJzW2ldKGNhbmNlbCk7XG4gICAgfVxuICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICB0aGlzLnByb21pc2UudGhlbiA9IGZ1bmN0aW9uKG9uZnVsZmlsbGVkKSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICB0b2tlbi5zdWJzY3JpYmUocmVzb2x2ZSk7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XG5cbiAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uIHJlamVjdCgpIHtcbiAgICAgIHRva2VuLnVuc3Vic2NyaWJlKF9yZXNvbHZlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gKi9cblxuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICBsaXN0ZW5lcih0aGlzLnJlYXNvbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbbGlzdGVuZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGNhbmNlbCBzaWduYWxcbiAqL1xuXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/cancel/CancelToken.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcz9jMTdhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/cancel/isCancel.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./node_modules/axios/lib/core/InterceptorManager.js\");\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./node_modules/axios/lib/core/dispatchRequest.js\");\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar validator = __webpack_require__(/*! ../helpers/validator */ \"./node_modules/axios/lib/helpers/validator.js\");\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean),\n      forcedJSONParsing: validators.transitional(validators.boolean),\n      clarifyTimeoutError: validators.transitional(validators.boolean)\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyx5RUFBcUI7QUFDNUMseUJBQXlCLG1CQUFPLENBQUMsaUZBQXNCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLDJFQUFtQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBZTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBc0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanM/MjlmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL21lcmdlQ29uZmlnJyk7XG52YXIgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy92YWxpZGF0b3InKTtcblxudmFyIHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgY29uZmlnLnVybCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsO1xuXG4gIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gIHZhciByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICB2YXIgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciBwcm9taXNlO1xuXG4gIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcblxuICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgY2hhaW4gPSBjaGFpbi5jb25jYXQocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcblxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cblxuICB2YXIgbmV3Q29uZmlnID0gY29uZmlnO1xuICB3aGlsZSAocmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgdmFyIG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB2YXIgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uUmVqZWN0ZWQoZXJyb3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0KG5ld0NvbmZpZyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuXG4gIHdoaWxlIChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICByZXR1cm4gYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCAnJyk7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/Axios.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzP2M3OTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCwgb3B0aW9ucykge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZCxcbiAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICBydW5XaGVuOiBvcHRpb25zID8gb3B0aW9ucy5ydW5XaGVuIDogbnVsbFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/InterceptorManager.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ \"./node_modules/axios/lib/helpers/isAbsoluteURL.js\");\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ \"./node_modules/axios/lib/helpers/combineURLs.js\");\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBMEI7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXdCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcz9mMDJkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBmdWxsIHBhdGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/buildFullPath.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMscUVBQWdCOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzPzc3MGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/createError.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar transformData = __webpack_require__(/*! ./transformData */ \"./node_modules/axios/lib/core/transformData.js\");\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults.js\");\nvar Cancel = __webpack_require__(/*! ../cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new Cancel('canceled');\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTtBQUNoQyxvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLHVFQUFvQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMseURBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLG1FQUFrQjs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzPzRkYzkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9DYW5jZWwnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxuXG4gIGlmIChjb25maWcuc2lnbmFsICYmIGNvbmZpZy5zaWduYWwuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBDYW5jZWwoJ2NhbmNlbGVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgY29uZmlnLFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/dispatchRequest.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  };\n  return error;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcz8wZGYzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cblxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZTtcblxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBzdGF0dXM6IHRoaXMucmVzcG9uc2UgJiYgdGhpcy5yZXNwb25zZS5zdGF0dXMgPyB0aGlzLnJlc3BvbnNlLnN0YXR1cyA6IG51bGxcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXJyb3I7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/enhanceError.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(prop) {\n    if (prop in config2) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  var mergeMap = {\n    'url': valueFromConfig2,\n    'method': valueFromConfig2,\n    'data': valueFromConfig2,\n    'baseURL': defaultToConfig2,\n    'transformRequest': defaultToConfig2,\n    'transformResponse': defaultToConfig2,\n    'paramsSerializer': defaultToConfig2,\n    'timeout': defaultToConfig2,\n    'timeoutMessage': defaultToConfig2,\n    'withCredentials': defaultToConfig2,\n    'adapter': defaultToConfig2,\n    'responseType': defaultToConfig2,\n    'xsrfCookieName': defaultToConfig2,\n    'xsrfHeaderName': defaultToConfig2,\n    'onUploadProgress': defaultToConfig2,\n    'onDownloadProgress': defaultToConfig2,\n    'decompress': defaultToConfig2,\n    'maxContentLength': defaultToConfig2,\n    'maxBodyLength': defaultToConfig2,\n    'transport': defaultToConfig2,\n    'httpAgent': defaultToConfig2,\n    'httpsAgent': defaultToConfig2,\n    'cancelToken': defaultToConfig2,\n    'socketPath': defaultToConfig2,\n    'responseEncoding': defaultToConfig2,\n    'validateStatus': mergeDirectKeys\n  };\n\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    var merge = mergeMap[prop] || mergeDeepProperties;\n    var configValue = merge(prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLG1EQUFVOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJCQUEyQjtBQUMzQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzP2JkMTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGlyZWN0S2V5cyhwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbWVyZ2VNYXAgPSB7XG4gICAgJ3VybCc6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgJ21ldGhvZCc6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgJ2RhdGEnOiB2YWx1ZUZyb21Db25maWcyLFxuICAgICdiYXNlVVJMJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndHJhbnNmb3JtUmVxdWVzdCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RyYW5zZm9ybVJlc3BvbnNlJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAncGFyYW1zU2VyaWFsaXplcic6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RpbWVvdXQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0aW1lb3V0TWVzc2FnZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3dpdGhDcmVkZW50aWFscyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2FkYXB0ZXInOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdyZXNwb25zZVR5cGUnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd4c3JmQ29va2llTmFtZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnb25VcGxvYWRQcm9ncmVzcyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ29uRG93bmxvYWRQcm9ncmVzcyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2RlY29tcHJlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnbWF4Qm9keUxlbmd0aCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RyYW5zcG9ydCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2h0dHBBZ2VudCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2h0dHBzQWdlbnQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdjYW5jZWxUb2tlbic6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3NvY2tldFBhdGgnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdyZXNwb25zZUVuY29kaW5nJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndmFsaWRhdGVTdGF0dXMnOiBtZXJnZURpcmVjdEtleXNcbiAgfTtcblxuICB1dGlscy5mb3JFYWNoKE9iamVjdC5rZXlzKGNvbmZpZzEpLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSksIGZ1bmN0aW9uIGNvbXB1dGVDb25maWdWYWx1ZShwcm9wKSB7XG4gICAgdmFyIG1lcmdlID0gbWVyZ2VNYXBbcHJvcF0gfHwgbWVyZ2VEZWVwUHJvcGVydGllcztcbiAgICB2YXIgY29uZmlnVmFsdWUgPSBtZXJnZShwcm9wKTtcbiAgICAodXRpbHMuaXNVbmRlZmluZWQoY29uZmlnVmFsdWUpICYmIG1lcmdlICE9PSBtZXJnZURpcmVjdEtleXMpIHx8IChjb25maWdbcHJvcF0gPSBjb25maWdWYWx1ZSk7XG4gIH0pO1xuXG4gIHJldHVybiBjb25maWc7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/mergeConfig.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar createError = __webpack_require__(/*! ./createError */ \"./node_modules/axios/lib/core/createError.js\");\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLG1FQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanM/ODc2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/settle.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar defaults = __webpack_require__(/*! ./../defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7QUFDaEMsZUFBZSxtQkFBTyxDQUFDLDJEQUFlOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcz83NjYyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzIHx8IGRlZmF1bHRzO1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbnRleHQsIGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/transformData.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ \"./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\nvar enhanceError = __webpack_require__(/*! ./core/enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ./adapters/xhr */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ./adapters/http */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n  },\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional || defaults.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*'\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsa0RBQVM7QUFDN0IsMEJBQTBCLG1CQUFPLENBQUMsOEZBQStCO0FBQ2pFLG1CQUFtQixtQkFBTyxDQUFDLDBFQUFxQjs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ3RDLElBQUksZ0JBQWdCLE9BQU8sbURBQW1ELE9BQU87QUFDckY7QUFDQSxjQUFjLG1CQUFPLENBQUMsaUVBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzP2UyMjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9jb3JlL2VuaGFuY2VFcnJvcicpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVNhZmVseShyYXdWYWx1ZSwgcGFyc2VyLCBlbmNvZGVyKSB7XG4gIGlmICh1dGlscy5pc1N0cmluZyhyYXdWYWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgKHBhcnNlciB8fCBKU09OLnBhcnNlKShyYXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdXRpbHMudHJpbShyYXdWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubmFtZSAhPT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoZW5jb2RlciB8fCBKU09OLnN0cmluZ2lmeSkocmF3VmFsdWUpO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB7XG4gICAgc2lsZW50SlNPTlBhcnNpbmc6IHRydWUsXG4gICAgZm9yY2VkSlNPTlBhcnNpbmc6IHRydWUsXG4gICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2VcbiAgfSxcblxuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKTtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpIHx8IChoZWFkZXJzICYmIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID09PSAnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgdHJhbnNpdGlvbmFsID0gdGhpcy50cmFuc2l0aW9uYWwgfHwgZGVmYXVsdHMudHJhbnNpdGlvbmFsO1xuICAgIHZhciBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgdmFyIGZvcmNlZEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5mb3JjZWRKU09OUGFyc2luZztcbiAgICB2YXIgc3RyaWN0SlNPTlBhcnNpbmcgPSAhc2lsZW50SlNPTlBhcnNpbmcgJiYgdGhpcy5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcblxuICAgIGlmIChzdHJpY3RKU09OUGFyc2luZyB8fCAoZm9yY2VkSlNPTlBhcnNpbmcgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgZGF0YS5sZW5ndGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0cmljdEpTT05QYXJzaW5nKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZW5oYW5jZUVycm9yKGUsIHRoaXMsICdFX0pTT05fUEFSU0UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfSxcblxuICBoZWFkZXJzOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgICB9XG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/defaults.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ ((module) => {

eval("module.exports = {\n  \"version\": \"0.24.0\"\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2Vudi9kYXRhLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZW52L2RhdGEuanM/MTEwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4yNC4wXCJcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/env/data.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcz80YmVhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/bind.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanM/YzE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/buildURL.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzPzZiYzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/combineURLs.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0MsU0FBUzs7QUFFVDtBQUNBLDREQUE0RCx3QkFBd0I7QUFDcEY7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzPzFkM2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/cookies.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanM/YTIyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/isAbsoluteURL.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanM/YmQ5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gKHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JykgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/isAxiosError.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzPzg3OTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/isURLSameOrigin.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsbURBQVU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzPzZiMTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/normalizeHeaderName.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanM/NTRlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/parseHeaders.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcz8yNzI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/spread.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar VERSION = (__webpack_require__(/*! ../env/data */ \"./node_modules/axios/lib/env/data.js\").version);\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  assertOptions: assertOptions,\n  validators: validators\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdmFsaWRhdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsd0ZBQThCOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdmFsaWRhdG9yLmpzPzAxMzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2Vudi9kYXRhJykudmVyc2lvbjtcblxudmFyIHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUsIGkpIHtcbiAgdmFsaWRhdG9yc1t0eXBlXSA9IGZ1bmN0aW9uIHZhbGlkYXRvcih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IHR5cGUgfHwgJ2EnICsgKGkgPCAxID8gJ24gJyA6ICcgJykgKyB0eXBlO1xuICB9O1xufSk7XG5cbnZhciBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbnxib29sZWFuP30gdmFsaWRhdG9yIC0gc2V0IHRvIGZhbHNlIGlmIHRoZSB0cmFuc2l0aW9uYWwgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWRcbiAqIEBwYXJhbSB7c3RyaW5nP30gdmVyc2lvbiAtIGRlcHJlY2F0ZWQgdmVyc2lvbiAvIHJlbW92ZWQgc2luY2UgdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmc/fSBtZXNzYWdlIC0gc29tZSBtZXNzYWdlIHdpdGggYWRkaXRpb25hbCBpbmZvXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgVkVSU0lPTiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFwnJyArIG9wdCArICdcXCcnICsgZGVzYyArIChtZXNzYWdlID8gJy4gJyArIG1lc3NhZ2UgOiAnJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG9wdCwgb3B0cykge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpKTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAmJiAhZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0pIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgb3B0LFxuICAgICAgICAgICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2JyArIHZlcnNpb24gKyAnIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBBc3NlcnQgb2JqZWN0J3MgcHJvcGVydGllcyB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBzY2hlbWEsIGFsbG93VW5rbm93bikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgdmFyIG9wdCA9IGtleXNbaV07XG4gICAgdmFyIHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRpb25zKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uICcgKyBvcHQgKyAnIG11c3QgYmUgJyArIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbG93VW5rbm93biAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gb3B0aW9uICcgKyBvcHQpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXNzZXJ0T3B0aW9uczogYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yczogdmFsaWRhdG9yc1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/validator.js\n");

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxnRUFBZ0I7O0FBRW5DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxHQUFHLFNBQVM7QUFDNUMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0QkFBNEI7QUFDNUIsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzP2M5ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqIEByZXR1cm4ge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5mdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbSxcbiAgc3RyaXBCT006IHN0cmlwQk9NXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/utils.js\n");

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _app_Application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app/Application */ \"./resources/js/app/Application.js\");\n\nvar app = new _app_Application__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', function (event) {\n    app.boot();\n  });\n} else {\n  app.boot();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFFQSxJQUFNQyxHQUFHLEdBQUcsSUFBSUQsd0RBQUosRUFBWjs7QUFFQSxJQUFJRSxRQUFRLENBQUNDLFVBQVQsS0FBd0IsU0FBNUIsRUFBdUM7QUFDbkNELEVBQUFBLFFBQVEsQ0FBQ0UsZ0JBQVQsQ0FBMEIsa0JBQTFCLEVBQThDLFVBQVVDLEtBQVYsRUFBaUI7QUFDM0RKLElBQUFBLEdBQUcsQ0FBQ0ssSUFBSjtBQUNILEdBRkQ7QUFHSCxDQUpELE1BSU87QUFDSEwsRUFBQUEsR0FBRyxDQUFDSyxJQUFKO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYXBwLmpzP2NlZDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFwcGxpY2F0aW9uIGZyb20gXCIuL2FwcC9BcHBsaWNhdGlvblwiO1xuXG5jb25zdCBhcHAgPSBuZXcgQXBwbGljYXRpb24oKTtcblxuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgYXBwLmJvb3QoKTtcbiAgICB9KTtcbn0gZWxzZSB7XG4gICAgYXBwLmJvb3QoKTtcbn1cblxuXG4iXSwibmFtZXMiOlsiQXBwbGljYXRpb24iLCJhcHAiLCJkb2N1bWVudCIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJib290Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/app.js\n");

/***/ }),

/***/ "./resources/js/app/Application.js":
/*!*****************************************!*\
  !*** ./resources/js/app/Application.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Application)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _tko_build_reference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tko/build.reference */ \"./node_modules/@tko/build.reference/dist/build.reference.js\");\n/* harmony import */ var _tko_build_reference__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tko_build_reference__WEBPACK_IMPORTED_MODULE_1__);\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }\n\nfunction _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError(\"Private static access of wrong provenance\"); } }\n\n\n\n\nvar Application = /*#__PURE__*/function () {\n  function Application() {\n    _classCallCheck(this, Application);\n  }\n\n  _createClass(Application, [{\n    key: \"boot\",\n    value: function boot() {\n      window.axios || (window.axios = _classStaticPrivateMethodGet(Application, Application, _bootAxios).call(Application));\n      window.ko || (window.ko = _classStaticPrivateMethodGet(Application, Application, _bootKnockout).call(Application));\n    }\n    /**\n     * @returns {*}\n     */\n\n  }]);\n\n  return Application;\n}();\n\nfunction _bootKnockout() {\n  var nodes = document.querySelectorAll('[data-vm]');\n\n  var _iterator = _createForOfIteratorHelper(nodes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      var vm = __webpack_require__(\"./resources/js/view-model sync recursive ^\\\\.\\\\/.*\\\\.js$\")(\"./\".concat(node.getAttribute('data-vm'), \".js\"))[\"default\"];\n\n      _tko_build_reference__WEBPACK_IMPORTED_MODULE_1___default().applyBindings(new vm(node), node);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return (_tko_build_reference__WEBPACK_IMPORTED_MODULE_1___default());\n}\n\nfunction _bootAxios() {\n  (axios__WEBPACK_IMPORTED_MODULE_0___default().defaults.headers.common) = {\n    'X-Requested-With': 'XMLHttpRequest',\n    'X-CSRF-TOKEN': document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content')\n  };\n  return (axios__WEBPACK_IMPORTED_MODULE_0___default());\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYXBwL0FwcGxpY2F0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7O0lBRXFCRTs7Ozs7OztXQUNqQixnQkFBTztBQUNIQyxNQUFBQSxNQUFNLENBQUNILEtBQVAsS0FBaUJHLE1BQU0sQ0FBQ0gsS0FBUCxnQ0FBZUUsV0FBZixFQUZKQSxXQUVJLG1CQUFlQSxXQUFmLENBQWpCO0FBQ0FDLE1BQUFBLE1BQU0sQ0FBQ0YsRUFBUCxLQUFjRSxNQUFNLENBQUNGLEVBQVAsZ0NBQVlDLFdBQVosRUFIREEsV0FHQyxzQkFBWUEsV0FBWixDQUFkO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7Ozs7Ozs7eUJBQzJCO0FBQ25CLE1BQU1FLEtBQUssR0FBR0MsUUFBUSxDQUFDQyxnQkFBVCxDQUEwQixXQUExQixDQUFkOztBQURtQiw2Q0FHRkYsS0FIRTtBQUFBOztBQUFBO0FBR25CLHdEQUF3QjtBQUFBLFVBQWZHLElBQWU7O0FBQ3BCLFVBQUlDLEVBQUUsR0FBR0MsZ0ZBQVEsWUFBaUJGLElBQUksQ0FBQ0csWUFBTCxDQUFrQixTQUFsQixDQUFsQixTQUFQLFdBQVQ7O0FBRUFULE1BQUFBLHlFQUFBLENBQWlCLElBQUlPLEVBQUosQ0FBT0QsSUFBUCxDQUFqQixFQUErQkEsSUFBL0I7QUFDSDtBQVBrQjtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVNuQixTQUFPTiw2REFBUDtBQUNIOztzQkFTbUI7QUFDaEJELEVBQUFBLHNFQUFBLEdBQWdDO0FBQzVCLHdCQUFvQixnQkFEUTtBQUU1QixvQkFBZ0JLLFFBQVEsQ0FDbkJVLGFBRFcsQ0FDRyx5QkFESCxFQUVYTCxZQUZXLENBRUUsU0FGRjtBQUZZLEdBQWhDO0FBT0EsU0FBT1YsOENBQVA7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9hcHAvQXBwbGljYXRpb24uanM/ODEzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQga28gZnJvbSAnQHRrby9idWlsZC5yZWZlcmVuY2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHBsaWNhdGlvbiB7XG4gICAgYm9vdCgpIHtcbiAgICAgICAgd2luZG93LmF4aW9zIHx8ICh3aW5kb3cuYXhpb3MgPSBBcHBsaWNhdGlvbi4jYm9vdEF4aW9zKCkpO1xuICAgICAgICB3aW5kb3cua28gfHwgKHdpbmRvdy5rbyA9IEFwcGxpY2F0aW9uLiNib290S25vY2tvdXQoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljICNib290S25vY2tvdXQoKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdm1dJyk7XG5cbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgbGV0IHZtID0gcmVxdWlyZShgLi4vdmlldy1tb2RlbC8ke25vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXZtJyl9LmpzYCkuZGVmYXVsdDtcblxuICAgICAgICAgICAga28uYXBwbHlCaW5kaW5ncyhuZXcgdm0obm9kZSksIG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlJ2xsIGxvYWQgdGhlIGF4aW9zIEhUVFAgbGlicmFyeSB3aGljaCBhbGxvd3MgdXMgdG8gZWFzaWx5IGlzc3VlIHJlcXVlc3RzXG4gICAgICogdG8gb3VyIExhcmF2ZWwgYmFjay1lbmQuIFRoaXMgbGlicmFyeSBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgc2VuZGluZyB0aGVcbiAgICAgKiBDU1JGIHRva2VuIGFzIGEgaGVhZGVyIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiB0aGUgXCJYU1JGXCIgdG9rZW4gY29va2llLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0F4aW9zU3RhdGljfVxuICAgICAqL1xuICAgIHN0YXRpYyAjYm9vdEF4aW9zKCkge1xuICAgICAgICBheGlvcy5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vbiA9IHtcbiAgICAgICAgICAgICdYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0JyxcbiAgICAgICAgICAgICdYLUNTUkYtVE9LRU4nOiBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJjc3JmLXRva2VuXCJdJylcbiAgICAgICAgICAgICAgICAuZ2V0QXR0cmlidXRlKCdjb250ZW50JylcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYXhpb3M7XG4gICAgfVxufSJdLCJuYW1lcyI6WyJheGlvcyIsImtvIiwiQXBwbGljYXRpb24iLCJ3aW5kb3ciLCJub2RlcyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsIm5vZGUiLCJ2bSIsInJlcXVpcmUiLCJnZXRBdHRyaWJ1dGUiLCJhcHBseUJpbmRpbmdzIiwiZGVmYXVsdHMiLCJoZWFkZXJzIiwiY29tbW9uIiwicXVlcnlTZWxlY3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/app/Application.js\n");

/***/ }),

/***/ "./resources/js/view-model/MenuViewModel.js":
/*!**************************************************!*\
  !*** ./resources/js/view-model/MenuViewModel.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MenuViewModel)\n/* harmony export */ });\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar uri = window.location.pathname;\n\nvar MenuViewModel = /*#__PURE__*/_createClass(function MenuViewModel(node) {\n  _classCallCheck(this, MenuViewModel);\n\n  var selected = node.querySelector(\"a[href=\\\"\".concat(uri, \"\\\"]\"));\n\n  if (selected) {\n    selected.classList.add('active');\n  }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvdmlldy1tb2RlbC9NZW51Vmlld01vZGVsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDQSxJQUFNQSxHQUFHLEdBQUdDLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkMsUUFBNUI7O0lBRXFCQywwQ0FDakIsdUJBQVlDLElBQVosRUFBa0I7QUFBQTs7QUFDZCxNQUFNQyxRQUFRLEdBQUdELElBQUksQ0FBQ0UsYUFBTCxvQkFBOEJQLEdBQTlCLFNBQWpCOztBQUVBLE1BQUlNLFFBQUosRUFBYztBQUNWQSxJQUFBQSxRQUFRLENBQUNFLFNBQVQsQ0FBbUJDLEdBQW5CLENBQXVCLFFBQXZCO0FBQ0g7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy92aWV3LW1vZGVsL01lbnVWaWV3TW9kZWwuanM/OGQ1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IHVyaSA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVudVZpZXdNb2RlbCB7XG4gICAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IG5vZGUucXVlcnlTZWxlY3RvcihgYVtocmVmPVwiJHt1cml9XCJdYCk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgIH1cbn0iXSwibmFtZXMiOlsidXJpIiwid2luZG93IiwibG9jYXRpb24iLCJwYXRobmFtZSIsIk1lbnVWaWV3TW9kZWwiLCJub2RlIiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY2xhc3NMaXN0IiwiYWRkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/view-model/MenuViewModel.js\n");

/***/ }),

/***/ "./resources/js/view-model/VersionsPanelViewModel.js":
/*!***********************************************************!*\
  !*** ./resources/js/view-model/VersionsPanelViewModel.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ VersionsPanelViewModel)\n/* harmony export */ });\n/* harmony import */ var _tko_build_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tko/build.reference */ \"./node_modules/@tko/build.reference/dist/build.reference.js\");\n/* harmony import */ var _tko_build_reference__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tko_build_reference__WEBPACK_IMPORTED_MODULE_0__);\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar VersionsPanelViewModel = /*#__PURE__*/_createClass(\n/**\n * @type {*}\n */\nfunction VersionsPanelViewModel(context) {\n  _classCallCheck(this, VersionsPanelViewModel);\n\n  _defineProperty(this, \"fixed\", _tko_build_reference__WEBPACK_IMPORTED_MODULE_0___default().observable(false));\n\n  var self = this;\n  window.addEventListener(\"scroll\", function () {\n    var rect = context.getBoundingClientRect();\n    self.fixed(rect.top < 0);\n  });\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvdmlldy1tb2RlbC9WZXJzaW9uc1BhbmVsVmlld01vZGVsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0lBRXFCQztBQUNqQjtBQUNKO0FBQ0E7QUFHSSxnQ0FBWUMsT0FBWixFQUFxQjtBQUFBOztBQUFBLGlDQUZiRixzRUFBQSxDQUFjLEtBQWQsQ0FFYTs7QUFDakIsTUFBTUksSUFBSSxHQUFHLElBQWI7QUFDQUMsRUFBQUEsTUFBTSxDQUFDQyxnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxZQUFZO0FBQzFDLFFBQU1DLElBQUksR0FBR0wsT0FBTyxDQUFDTSxxQkFBUixFQUFiO0FBRUFKLElBQUFBLElBQUksQ0FBQ0ssS0FBTCxDQUFXRixJQUFJLENBQUNHLEdBQUwsR0FBVyxDQUF0QjtBQUNILEdBSkQ7QUFLSCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy92aWV3LW1vZGVsL1ZlcnNpb25zUGFuZWxWaWV3TW9kZWwuanM/YzcxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQga28gZnJvbSBcIkB0a28vYnVpbGQucmVmZXJlbmNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnNpb25zUGFuZWxWaWV3TW9kZWwge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIGZpeGVkID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gY29udGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgc2VsZi5maXhlZChyZWN0LnRvcCA8IDApO1xuICAgICAgICB9KTtcbiAgICB9XG59Il0sIm5hbWVzIjpbImtvIiwiVmVyc2lvbnNQYW5lbFZpZXdNb2RlbCIsImNvbnRleHQiLCJvYnNlcnZhYmxlIiwic2VsZiIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZml4ZWQiLCJ0b3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/view-model/VersionsPanelViewModel.js\n");

/***/ }),

/***/ "./resources/css/app.scss":
/*!********************************!*\
  !*** ./resources/css/app.scss ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvY3NzL2FwcC5zY3NzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9jc3MvYXBwLnNjc3M/NjE0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/css/app.scss\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz81Y2IzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./resources/js/view-model sync recursive ^\\.\\/.*\\.js$":
/*!****************************************************!*\
  !*** ./resources/js/view-model/ sync ^\.\/.*\.js$ ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./MenuViewModel.js": "./resources/js/view-model/MenuViewModel.js",
	"./VersionsPanelViewModel.js": "./resources/js/view-model/VersionsPanelViewModel.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./resources/js/view-model sync recursive ^\\.\\/.*\\.js$";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/assets/app": 0,
/******/ 			"assets/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["assets/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["assets/app"], () => (__webpack_require__("./resources/css/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;